# Source: cloud.google.com/retail/docs/a-b-monitor.txt
Monitor and analyze A/B experiments  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Monitor and analyze A/B experiments
This page describes how you can monitor A/B experiment traffic and compare key
business metrics for search in the Search for commerce
console.
Overview
You can conduct an A/B experiment to compare key business metrics between
your existing search implementation and Vertex AI Search for commerce.
After setting up the experiment and its traffic splitting, you can monitor
experiment traffic and view business metrics using the
Experiment
page in
the Search for commerce console.
To set up A/B experiment monitoring in the console, you input information about
your A/B test such as name, time range, and experiment arm information. Each
experiment variant arm maps to a experiment group that you have created for the
A/B experiment, where the first arm you set up in the console is treated as the
baseline control.
Each experiment has a
Monitoring
tab displaying traffic split metrics that
can help you determine if the A/B test is set up correctly. This is important
for validating whether bias has been introduced into the A/B test. For example, a
typical issue to look out is whether some queries or categories are served by
one experiment arm but not others.
Each experiment also has an
Analytics
tab where you can view key business
metrics comparisons. Two categories of business metrics are included:
Per search or per browse metrics, such as clicks per search.
Per search or per browse visit metrics, such as revenue per browse visit.
See
Metrics list
for a complete list of metrics.
Each business metric provides raw values, relative lift compared with the
baseline control, and a 95% confidence interval. You can view both aggregated
metrics and metrics by date.
The traffic monitoring tab displays whether unintended traffic splits have
occurred and the dates on which they occurred. An unintended traffic split is
determined by comparing the actual traffic split percentage with the intended
split percentage that you input when setting up monitoring. The traffic split is
considered correct if the relative difference is equal to or less than 10%. For
example, if traffic is intended to split evenly across two arms, an actual split
of 45% to 55% is just within the intended range.
You can use the console to monitor multiple experiments simultaneously.
The experiment date and metrics sliced by date use America/Los_Angeles as the
time zone and 12:00 AM America/Los_Angeles time for start dates and end dates.
You can update experiment details in the console such as start and end dates,
number of variant arms, experiment IDs, and intended traffic split percentage at
any time, regardless of whether the experiment is ongoing, finished, or pending.
The data is updated retroactively.
Monitoring and analyzing the A/B experiments has following
requirements/limitations:
The maximum time range of experiment data you can track is 180 days. If an
experiment started more than 180 days ago, metrics older than that are not
captured.
Per-query or per-category traffic monitoring returns only the top 100
queries or categories that get the most traffic of all variant arms in the
experiment.
Before you begin
Before you set up monitoring in the Search for commerce console for an A/B
experiment:
Set up user event ingestion for events served by your existing search
implementation and by Vertex AI Search for commerce.
Review
A/B experiment best practices
.
Set up the experiment using a third-party experiment platform such as
Google Optimize
or
Optimizely
.
Set up and note the user event
experimentIds
for each experiment group.
When you set up experiment monitoring, you need to specify the experiment
IDs for each variant arm.
Add an experiment in the console
Use the following procedures to add a new experiment to monitor in the
Search for commerce console:
Add experiment details
Add variants
In this procedure, you create variant arms in the Search for commerce
console that correspond to the existing experiment groups that you created in
your third-party experiment platform. For examples of how variant arms can map
to existing experiment groups, see
Examples of experiment
setups
.
Add experiment details
Add an experiment in the console and enter its details.
Go to the
Experiments
page in the Search for commerce console.
Go to the Experiments page
Click
Add Experiment
.
The
New Experiment
page opens.
Enter a name for your experiment.
Select the start and end dates of your experiment.
If your experiment traffic is set to ramp up gradually, set the start date to
a date when ramping up is completed and the traffic split is stabilized.
Select what kind of activity this experiment tracks:
Browse
: Navigation on your site by page category.
Browsing activity is indicated by an empty
query in the search response.
Search
: Text query searches on your site.
Next, create variant arms for your experiment.
Add variants
After adding experiment details in the console, create variant arms that
correspond to each experiment group.
The first variant arm that you set up is the baseline variant. The baseline
typically represents your existing solution.
Before starting, make sure you have the user event
experimentIds
for each
experiment group.
Click
Add Variant Arm
.
The
Create Variant Arm
panel opens.
Enter the user event
experimentId
associated with the experiment setup
that this variant arm will monitor:
If you are setting up your first variant arm:
Enter the user event
experimentId
associated with the baseline group that will serve as
your baseline.
If you have already set up your baseline variant arm
: Enter the user
event
experimentId
associated with the next experiment group.
Enter a human-readable name for this variant arm.
This name is displayed in monitoring dashboards in the console.
(Optional) Provide a description of this variant arm.
Select a serving traffic destination:
Google Vertex AI Search for Retail API
: If this variant arm monitors
traffic for Vertex AI Search for commerce results.
External
: If this variant arm monitors traffic for results from an
external service. For example, the baseline (or control) variant arm
likely represents an external destination if the experiment is comparing
an existing service's traffic to Vertex AI Search for commerce traffic.
Click
Create
to finish creating this variant arm.
The variant arm is displayed on the
New Experiment
page.
Repeat the previous steps to create variant arms associated with each
experiment group you plan to monitor.
You must have at least one
External
arm and one
Google Vertex AI Search
for Retail API
arm.
(Optional) By default, intended traffic percentage is split evenly across
all variant arms. To customize the intended traffic percentages:
Under the
Add Variants
section, click a traffic percentage value in
Traffic %
column.
The
Traffic Percentage
panel opens.
In the
Weight distribution
field, select
Custom percentages
.
In the
Traffic %
column for each variant arm, enter its intended
traffic percentage.
The total traffic percentage across all variant arms must add up to 100%.
Click
Done
.
The
Traffic Percentage
panel closes.
Click
Create
on the
New Experiment
page to finish creating your
experiment.
The experiment is displayed on the
Onboarding Experiments
page.
Examples of experiment setups
This section presents two examples of experiment setups.
Example 1 shows a baseline control and one Vertex AI Search for commerce experiment
group.
Example 2 shows comparing a baseline control with two Vertex AI Search for commerce
experiment groups.
Example 1: Two variant arms
In this example, assume that you plan to set up an A/B experiment with:
20% of search requests sent to in-house search engines as the baseline
control group
20% of search requests sent to Google Vertex AI Search for Retail API as the experiment group
60% as a holdout group that is not in the A/B test
The request and user event configuration would be:
Traffic type
Discovery engine
60%
event.experimentIds
event.attributionToken
Traffic %
Control traffic
In-house
CONTROL
N/A
20%
Experiment traffic
Google Vertex AI Search for Retail API
EXPERIMENT
Attribution token from search response
20%
Holdout traffic
Either / both
N/A
Depends on discovery engine
60%
Holdout traffic might be served by an in-house search engine,
Vertex AI Search for commerce, or both. Because they are not part of the A/B test,
they don't have an experiment ID. To indicate which user events are part of the
A/B test, make sure to provide
experimentIds
and
attributionToken
information. Your
experimentId
strings might be different from those given in
this example. Make sure that the IDs you use are consistent between your
experiments and user events.
When creating the corresponding experiment in the console, you would create only
two variant arms, because the holdout group is not part of the experiment. The
intended traffic percentage split between the two variant arms is 50% / 50%.
To set up monitoring for this example experiment, you would create corresponding
variant arms in the console for each experiment group. The following table shows
information you would enter in the console during variant arm setup for this
example.
Variant arm name
Traffic destination
User event experiment ID
Intended traffic %
Example control arm
External
CONTROL
50%
Example experiment arm
Google Vertex AI Search for Retail API
EXPERIMENT
50%
Example 2: Three variant arms
In this example, assume that you plan to conduct an A/B experiment on the head
queries (high-frequency queries) and include both turning on and off dynamic
facets. The requests and user events configurations would be:
Variant arm name
Traffic destination
event.experimentIds
event.attributionToken
Traffic %
Head queries control
In-house
CONTROL
N/A
50% of head queries
Head queries dynamic facets ON experiment
Google Vertex AI Search for Retail API
EXP_DF_ON
Attribution token from search response
25% of head queries
Head queries dynamic facets OFF experiment
Google Vertex AI Search for Retail API
EXP_DF_OFF
Attribution token from search response
25% of head queries
Non-head queries and other holdouts
Google Vertex AI Search for Retail API
N/A
Depends on engine used
N/A
To set up monitoring for this example experiment, you would create corresponding
variant arms in the console for each experiment group. The following table shows
information you would enter in the console during variant arm setup for this
example.
Variant arm name
Traffic destination
User event experiment ID
Intended traffic %
Example control arm
External
CONTROL
50%
Example experiment arm 1
Google Vertex AI Search for Retail API
EXP_DF_ON
25%
Example experiment arm 2
Google Vertex AI Search for Retail API
EXP_DF_OFF
25%
Traffic metrics
An experiment's
Monitoring
page shows if there are unintended traffic splits
for the following metrics:
Search/Browse event count per date
Search/Browse visitor count per date
Search/Browse event count per category
When unintended traffic splits occur for one of these metrics, its card at the
top of the
Monitoring
page shows the dates on which the unintended traffic
split occurred. Click
Unintended traffic splits
to see a filterable table
listing unintended traffic splits for that metric.
The following tables on an experiment's
Monitoring
page compare traffic
metrics across variant arms according to usage. Click
View more
next to any
table title to see a filterable table listing all traffic splits for that
metric:
Search/Browse event count per date
: The total number of searches or
browses that have occurred on a variant arm on a given date.
Search/Browse visitor count per date
: The number of visitors who have
queried or browsed on a variant arm on a given date.
Search/Browse event count per category
: The total number of times that a
given query or category has been searched for on a variant arm from the
experiment start date to its end date (or to today's date, if the experiment
is ongoing). This table shows only the top 100 queries or categories in
terms of the total traffic of all variant arms in the experiment.
Monitor an experiment
The
Onboarding experiments
page displays a table of your recent experiments.
To monitor an experiment:
Go to the
Experiments
page in the Search for commerce console.
Go to the Experiments page
Click the experiment name.
The
Monitoring
page for that experiment opens.
Review the page for unintended traffic splits.
Each metric displays the dates on which any unintended traffic splits
occurred.
If you see unintended splits, click
Unintended traffic splits
to see a
filterable table listing unintended traffic splits for that metric.
Address unintended traffic splits
Monitoring experiments from the Search for commerce console can help bring
your attention to potential issues in your experiment.
If you encounter unintended traffic splits, make sure events are tagged with the
correct experiment ID. For example, an event belonging to a control group being
tagged with the wrong experiment ID can cause the event to be attributed to the
wrong variant arm.
If event tagging is working correctly, unintended traffic splits reported by the
Search for commerce console can indicate traffic split issues in your
experiment platform. When this is the case, pause your A/B testing before
resolving the issue so that your experiment does not produce incorrect results.
Business metrics for analytics
Two groups of business metrics are available:
Per-search or per-browse metrics
Per-search visit or per-browse visit
Per search visit metrics
Per-search-visit metrics definitions are listed here. Per-browse-visit metrics
definitions are the similar to those of per-search-visit metrics, with all
instances of search replaced with browse.
In purchase order rate, one purchase order can include multiple SKUs. Each SKU
can have a quantity of more than or equal to one.
Metric Name
Definition
Search visit count
Count of visits that contains at least one search.
Bounce rate
Count of search visits that only has 1 user event / search visit count
-->
Page view rate
Count of clicks (page views) / search visit count
Add-to-cart (ATC) rate
Count of add-to-cart units in search visits / search visit count
Purchase order rate
Count of purchase orders in search visits / search visit count
Revenue rate
Sum of revenue in search visits / search visit count
Average order value (AOV)
Sum of revenue in search visits / count of purchase orders in search visits
Per search metrics
Per-search metrics definitions are listed here. Per-browse metrics definitions are the similar to those of per-search metrics, with all instances of search replaced with browse.
Metric Name
Definition
Search count
Count of search events
No Result rate
Count of search events without results / search count
Clickthrough rate (CTR)
Count of search-driven clicks (page views) / search count
Add-to-cart (ATC) rate
Count of search-driven add-to-cart units / search count
Purchase rate
Count of search-driven purchase units / search count
Revenue rate
Sum of search-driven revenue / search count
Average Unit Value (AUV)
Sum of search driven revenue / count of search driven purchase units
Analyze experiment business performance
Each experiment's
Analytics
tab displays business metrics dashboards. The
dashboards show performance comparisons across variant arms.
There are two dashboards of metrics:
Per search visit and per browse visit metrics
Per search and per browse metrics
Either search metrics or browse metrics are shown based on the
ProductType
attribute of the experiment.
Each dashboard displays a summary metrics table showing metrics results
aggregated across the dates shown in the date range filter. The default date
values are the experiment start and end dates.
Each metric is displayed as an aggregated
result table as well as a daily value chart that provides more detailed
information.
The aggregated table date range uses the experiment's start and end dates as
the default date values. If the experiment is ongoing, the end date is set to
the current date. You can modify the date range filter. If
userAgent
is
provided with ingested user events, you can also slice metrics by device type.
Click the
Refresh
icon to apply modified filters to metrics.
When the metrics relative lift is positive enough to exceed the confidence
interval bandwidth, a green background color is displayed for that variant.
Similarly, if the relative lift is negative enough, a red background color is
displayed for that variant. If the relative lift is smaller than the confidence
interval width, a grey background color indicates that the result does not
have statistical significance.
For example, when comparing a variant arm versus baseline control arm:
If a metric
Clickthrough rate per search
is +3.0%
and the confidence interval, displayed as
Lift CI
, is [2.1%, 4.0%], the
variant arm is highlighted in green to indicate it is a better performing
variant for this metric compared to the baseline control.
If a metric
Revenue rate per browse visit
is -1.5%
and the confidence interval is [-2.6%, -0.4%], the variant arm is
highlighted in red to indicate it performs worse in this metric compared
to the baseline control.
If a metric
Average unit value per search
is +1.0%
and the confidence interval is [-1.1%, 3.0%], the variant arm is highlighted
in gray to indicate that the difference in performance doesn't yet have
statistical significance.
Generally, the more data points, the smaller the variance is. Accumulated
metrics over a few weeks will have a lower confidence interval bandwidth than
daily metrics and are more likely to show statistical significance.
Modify experiment details
You can update experiment details in the console such as start and end date,
number of variant arms, experiment IDs, and intended traffic split percentage at
any time, regardless of whether the experiment is ongoing, finished, or pending.
The data is updated retroactively.
To edit experiment details:
Go to the
Experiments
page in the Search for commerce console.
Go to the Experiments page
In the table showing your recent experiments, find the experiment you plan to
modify.
Click the three-dot
Actions
icon to the right of its table row and click
Edit
.
The
Edit Experiment
page opens.
Modify the experiment fields you intend to update.
Click
Update
to save your changes.
Delete an experiment from the console
To delete an experiment from the Search for commerce console:
Go to the
Experiments
page in the Search for commerce console.
Go to the Experiments page
In the table showing your recent experiments, find the experiment you plan to
delete.
Click the three-dot
Actions
icon to the right of its table row and click
Delete
.
The
Delete experiment?
confirmation window opens.
Type the experiment name and click
Confirm
to confirm deletion.
When the deletion is complete, the console displays a message that your
experiment has been successfully deleted.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/a-b-testing.txt
General guidance on conducting A/B experiments  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
General guidance on conducting A/B experiments
This page describes how you can use A/B experiments to understand how
Vertex AI Search for commerce is impacting your business.
Overview
An
A/B experiment
is a randomized
experiment with two groups: an experimental group and a control group. The
experimental group receives some different treatment (in this case, predictions
or search results from Vertex AI Search for commerce); the control group does not.
When you run an A/B experiment, you include the
information about which group a user was in when you record user events.
That information is used to refine the model and provide
metrics.
Both versions of your application must be the same, except that users in the
experimental group see results generated by Vertex AI Search for commerce and
the control group does not. You log user events for both groups.
For more on traffic splitting, see
Splitting Traffic
in the App Engine documentation.
Experiment platforms
Set up the experiment using a third-party experiment platform such as
VWO
,
AB Tasty
. The control and experimental groups
each get a unique experiment ID from the platform. When you record a user event,
specify which group the user is in by including the experiment ID in the
experimentIds
field. Providing the experiment ID lets
you to compare the metrics for the versions of your
application seen by the control and experimental groups.
Best practices for A/B experiments
The goal of an A/B experiment is to accurately determine the impact of updating
your site (in this case, employing Vertex AI Search for commerce). To get an accurate measure
of the impact, you must design and implement the experiment correctly, so that
other differences don't creep in and impact the experiment results.
To design a meaningful A/B experiment, use the following tips:
Before setting up your A/B experiment, use prediction or search preview to
ensure that your model is behaving as you expect.
Make sure that the behavior of your site is identical for the experimental
group and the control group.
Site behavior includes latency, display format, text format, page layout,
image quality, and image size. There should be no discernible differences
for any of these attributes between the experience of the control and
experiment groups.
Accept and display results as they are returned from
Vertex AI Search for commerce, and display them in the same order as they are
returned.
Filtering out items that are out of stock is acceptable. However, you should
avoid filtering or ordering results based on your business
rules.
If you are using search user events and include the required attribution token with them, make sure they are
set up correctly. See the documentation for
Attribution tokens
.
Make sure that the serving config you provide when you request
recommendations or search results matches your intention for that
recommendation or search result, and the location where you display the
results.
When you use recommendations, the serving config
affects how models are trained and therefore what products are recommended.
Learn more
.
If you are comparing an existing solution with Vertex AI Search for commerce,
keep the experience of the control group strictly segregated from the
experience of the experimental group.
If the control solution does not provide a recommendation or search result,
don't provide one from Vertex AI Search for commerce in the control pages.
Doing so will skew your test results.
Make sure your users don't switch between the control group and the
experiment group. This is especially important within the same session, but
also recommended across sessions. This improves experiment performance and
helps you get statistically significant A/B test results sooner.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/apis.txt
APIs and reference  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All APIs & references
Client Libraries
Overview
C++ Reference
C Sharp Reference
Go Reference
Java Reference
Node.js Reference
PHP Reference
Python Reference
Ruby Reference
REST reference
Overview
v2
REST Resources
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
Types
BigQuerySource
BoostSpec
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalSearchCustomizationConfig
ConversationalSearchSpec
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
PredictResponse
ProductAttributeValue
QueryExpansionSpec
SearchMode
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
v2beta
REST Resources
projects
Overview
getAlertConfig
updateAlertConfig
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
batchRemoveCatalogAttributes
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
export
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
export
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
Types
AlertConfig
BigQuerySource
BoostSpec
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalSearchCustomizationConfig
ConversationalSearchSpec
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
OutputConfig
PredictResponse
ProductAttributeValue
QueryExpansionSpec
RecommendationsFilteringOption
SearchMode
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
v2alpha
REST Resources
projects
Overview
enrollSolution
getAlertConfig
getLoggingConfig
getRetailProject
listEnrolledSolutions
updateAlertConfig
updateLoggingConfig
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
batchRemoveCatalogAttributes
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches
Overview
get
list
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.places.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
export
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.merchantCenterAccountLinks
Overview
create
delete
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
conversationalSearch
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
conversationalSearch
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
export
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
projects.retailProject
Overview
acceptTerms
Types
AlertConfig
BigQuerySource
BoostSpec
BranchView
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalFilteringSpec
ConversationalSearchCustomizationConfig
ConversationalSearchResponse
ConversationalSearchSpec
Facet
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
LoggingConfig
OutputConfig
PredictResponse
ProductAttributeInterval
ProductAttributeValue
Project
QueryExpansionSpec
RecommendationsFilteringOption
RelevanceThreshold
SafetySetting
SearchMode
SearchParams
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
Shared Types
Types
Date
GetOperationRequest
HttpBody
ListOperationsRequest
ListOperationsResponse
RPC reference
Overview
google.api
google.cloud.location
google.cloud.retail.logging
google.cloud.retail.v2
google.cloud.retail.v2alpha
google.cloud.retail.v2beta
google.longrunning
google.rpc
google.type
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Reference
Send feedback
APIs and reference
Vertex AI Search for commerce client libraries
Get started with Vertex AI Search for commerce in your language of choice.
REST API Reference
Vertex AI Search for commerce REST API Reference.
RPC Reference
Vertex AI Search for commerce RPC Reference.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/attribute-config.txt
About product attributes  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About product attributes
Vertex AI Search for commerce can use product attributes for indexing,
dynamic faceting, searchability, filtering, and model quality. This page
discusses setting product attribute configurations and how they are treated
depending on the method and configuration you use.
Attribute types
Product attributes can have different default settings and allowed options
depending on their type.
System attributes
: Predefined system attributes are existing
Product
fields that provide more information about the product. These include
product attributes like brand, availability, color, and size. For all
available system attributes for products, see the
Product
reference documentation
.
Custom attributes
: Custom attributes are extra attributes that you define
using the
Product.attributes
field. For example, this could include store
names, vendors, or style. For examples and limits for custom attributes, see
the
Product.attributes
reference documentation
.
Note:
The top 20 selected custom attributes change monthly, and the (current) selected attributes are displayed in the
Attribute controls
tab on the
Controls
page in the Search for commerce console.
Some examples of top 20 custom attributes are:
Product line this product belongs to
Volume of in-store sales for this product
Occasion for clothing
Deals and coupons applicable to this product
Site-wide product popularity
Inventory-level attributes
: System or custom attributes that provide
store-level information about the product. You might use inventory-level
attributes for products whose properties vary significantly between stores and
regions, such as grocery items, or for products that have store-specific
promotions.
inventories.price
and
inventories.originalPrice
are numeric system
attributes predefined by Vertex AI Search for commerce. You can create custom
inventory-level attributes, which can be textual or numeric. Inventory-level
attributes are indexable by default. Setting searchable and dynamic faceting
is not supported for inventory-level attributes.
Note:
Providing values for predefined system attributes in
Product
such as brand, color, and size is highly encouraged. You can also include custom
attributes that you define with
Product.attributes
.
Available configuration settings
Attribute configuration settings impact search and recommendations behavior
across your site.
Search uses the following attribute settings:
Indexable
: Search can filter and facet using this attribute.
Dynamic faceting
: Search can automatically use this
    attribute as a dynamic facet based on past user behavior such as facet clicks
    and views. To enable dynamic faceting for an attribute,
Indexable
must be set to true for that attribute.
Searchable
: This attribute is searchable by search
    queries, which increases recall for that attribute. This control is applicable
    only for text attributes.
Retrievable
: If set to true, search returns this
    attribute in responses to search queries. If all attributes have
    Retrievable set to false, the search results contain only the product name
    or (for variants) the product name and color information. The REST field RetrievableFields is deprecated for products. Use the retrievable site-wide control instead.
Recommendations uses the following attribute settings:
Filterable
(Public Preview): This attribute can be used in recommendations
    filter expressions. This control is applicable only for text attributes.
Indexable
If an attribute is set to indexable, search can filter and facet
using the attribute.
System attributes
: Indexability is always enabled for predefined system
attributes. This setting can't be disabled for system attributes.
Custom attributes
: Enabled by default. You can disable indexability for
any custom attribute. If you plan to make a custom attributes indexable, it
must follow the regular expression pattern
[a-zA-Z0-9][a-zA-Z0-9_]*
. For example,
key0LikeThis
or
KEY_1_LIKE_THIS
.
Inventory-level attributes
: Always enabled for system inventory-level
attributes; this setting can't be changed. Enabled by default for
custom inventory-level attributes; this setting can be turned off.
Dependencies
: N/A
Your index configuration changes go into effect immediately after you import catalog data. Otherwise it can take up to 12 hours or more for your changes to take effect. You can test if your changes have been applied
on the
Evaluate
page.
Dynamic faceting
When dynamic faceting is enabled for an attribute, search can
use the attribute as a dynamic facet. Dynamic facets can be automatically added
to a search based on past user behavior such as facet clicks and views.
System attributes
: Enabled by default if indexability is set to true. You
can disable dynamic faceting for any system attribute.
Custom attributes
: Enabled by default if indexability is set to true. You
can disable dynamic faceting for any custom attribute.
Inventory-level attributes
: Not supported.
Dependencies
: To enable dynamic faceting for an attribute, you must first
enable indexability for that attribute.
Setting dynamic faceting for an attribute is always global. The dynamic faceting
configuration you apply to that attribute is used by products across the catalog
that use that attribute.
Dynamic faceting configuration changes take up to two days. You can test if your
changes have been applied on the
Evaluate
page.
For numerical custom attributes, buckets need to be specified in the request.
Numerical values are not bucketed automatically.
Searchable
If an attribute is set to searchable, recall for that attribute in
search queries is improved.
Only textual attributes values can have searchability enabled. It is not
applicable to numerical attributes.
System attributes
: Predefined textual system attributes for
Product
have
their searchability settings configured by Vertex AI Search for commerce. These
setting cannot be changed.
Custom attributes
: Disabled by default. You can enable this
configuration for any textual custom attribute.
Inventory-level attributes
: Not supported.
Dependencies
: N/A
Exact-searchable
: Targeted search returns for search queries that match any given product in your catalog. This option works well for serial numbers. See more information about the
exact-searchable option
.
Although products with a searchable attribute are more likely to appear in
search results for that attribute, they are not guaranteed to appear.
Recommendations filtering
Preview:
This feature is in public preview.
If an attribute has recommendations filtering turned on, it can be used in
recommendations filter expressions to filter products in
predictions.
System attributes
: Off by default. You can turn on this setting for any
predefined system textual attributes for
Product
, except for
FulfillmentInfo
and
title
. Not supported for numeric attributes.
Custom attributes
: Off by default. You can turn on this setting for any
custom textual attributes for
Product
. Not supported for numeric attributes.
Inventory-level attributes
: Supported only for the
availability
value
IN_STOCK
.
Dependencies
: N/A
Exact-searchable option
You can give a certain value for specific string queries to the
exact-searchable
option, a catalog attribute field. If a query matches any product in your catalog where the value for that field is the string given in the query, it returns exactly that product in the search query. This option works well for serial numbers, where customers expect a targeted search experience.
Usually for custom attributes, the
ExactSearchableOption
field is useful for product attributes with an exact value (like
ModelId
or
ManufacturerId
). Attributes like
product_id
are primary index fields—exact-searchable by default. The
item_id
field is always on for exact match and can't be disabled.
To avoid returning unrelated items in searches, never set the searchable option to a generic value such as
battery
.
To avoid under-serving search queries, don't set special fields like
tag
— which could have as one of its string values "iphone" — to exact-searchable. Doing so could cause those queries to limit results for all iphones in the product catalog.
For more information, see
About product attributes
.
Attribute behavior
When structuring your product catalog using primary and variant product designations, know how product attributes are handled for filtering. Their behavior depends on whether you're using search or recommendations and on how you configure your catalog taxonomy.
To ensure predictable and accurate filtering behavior, maintain consistency and completeness in your filterable attribute definitions across primary and variant products. This approach aids in precise filtering, which improves product discovery and search relevance.
Primary-variant behavior in search versus recommendations
While only primary items are returned in search and recommendation results, Vertex AI Search for commerce optimizes search and recommendation quality.
For search models, variant attributes are used for the primary product in the search index. Search results display diverse options for the primary product based on its variants' attributes.
For recommendation models, product details and attributes are not inherited from primary to variant. For optimal recommendation quality, it's crucial that primary and variant products have complete and accurate details for key attributes such as
product.categories
,
product.title
,
product.attributes
, and
product.prices
.
Handle attributes during indexing and filtering
If the same attribute is defined in
Primary
and
Variant
, the attribute in the variant is part of filtering. For example, say an attribute is defined for a primary product and its variants (color or size). Variant attribute values are mainly for filtering, during which the system checks if any of the primary's variants match the attribute value. Take product availability: A primary product can be marked
out-of-stock
, but if at least one of its variants is
in-stock
, the primary is available for search results if an
in-stock
filter is applied.
For the following reasons, set the same filterable attributes in
Primary
and
Variant
:
Variant attributes take precedence for filtering. If an attribute is defined on a primary product and its variants, the attribute from the variant is used in filtering. For example, if a primary product has a placeholder color, but its variants have actual colors, the variant's color should be populated and is used for filtering.
For inventory-related attributes like availability, if a primary product has variants, the primary product's availability should be set to
OUT_OF_STOCK
, while the true availability (such as
IN_STOCK
) should be set at the variant level. This way, the primary product is considered in stock as long as at least one variant is in stock. If so, filters such as
availability: ANY("IN_STOCK")
correctly return the primary product.
When a filter expression is used, the prediction response will return primary products that have at least one primary or variant product matching the filter's attribute value.
Optional attributes for filtering
Keep the
categories
field clean and optimized for taxonomy. If more filtering is needed, implement it based on broad categories using separate custom attributes, not in the
categories
field. This also avoids negatively impacting autocompletion training for category suggestions.
For example, say you typically set categories like
[lvl1, lvl1>lvl2, lvl1>lvl2>lvl3]
for filtering. Autocomplete counts the most frequent categories for a given query, so you end up with
lvl1
and
lvl2
(all your products) as suggested categories.
Best practices
If your catalog consists of primary and variant products
and
the same attribute is defined in both, the attribute in variant will be considered during filtering.
Populate attributes accurately
: Ensure that both primary and variant products have complete and accurate details for their attributes, especially those used for filtering, to maximize effectiveness.
Use built-in fields
: Do not rely solely on custom attributes. Map your product information to the built-in
Product
fields (
brands
,
colors
,
sizes
, and the
required fields
). Built-in fields have a greater impact on searchability, indexability, and relevance optimizations. Custom attributes (
Product.attributes
) are for product data that does not fit into predefined system attributes.
Set site-wide retrievable fields control
: The API supports
variantRollupKeys
for variants, allowing you to retrieve details in search responses.
Caution:
If you're using search,
Product.retrievableFields
, where attributes were included with a product in the search response, is deprecated. Use the retrievable site-wide control.
Consistent catalog language
: The product catalog should be in one language only, and search queries should be sent in the same language. Having multiple languages in the catalog can degrade model performance. Not setting the language code can affect features like spell correction.
Price information
: Accurately populate price information for both primary and variant products to ensure accurate recommendations and filtering. If a product lacks product-level pricing and relies solely on local inventory pricing, fill the primary product's pricing with the median from inventory-level pricing.
Configuration modes
The configuration mode determines how
attribute configurations are treated and which attribute configurations you can
set.
Catalog-level configuration mode (default)
: In this mode,
attribute configurations on the catalog level on the catalog level are used as
the source of truth.
Product-level configuration mode (deprecated)
: In this mode,
attribute configurations on the product-level are used as the source of truth.
Previously, product-level configuration was the default mode. If you are still
on product-level configuration mode and need to switch to catalog-level
configuration mode, contact Support. Search
does not support returning to product-level configuration mode after you have
switched.
To check the configuration mode, go to the Search for commerce console
Controls
page
. If the
Indexable
option is available as a column on the
Site-wide controls
tab,
then the configuration model is catalog level. If the
Indexable
column is not available on the
Site-wide controls
tab, then
the configuration model is product-level.
Configuration methods
You can set attribute configurations in the following ways:
The Search for commerce console
: Set
attribute configurations on the catalog level using the
Search for commerce console. This configures attributes globally across
all products. Which of these settings are available in the console depends on
the configuration mode. See the next section for more details on how to
configure attributes in the console
.
The
AttributeConfig
API method
: Set attribute configurations on
the catalog level using the API. This configures attributes
across all products.
The
Product
API method (deprecated)
: Set custom attributes on the
product-level using the
Product
API method. Setting attributes with this
method is not available to new users and is not
recommended.
Configure attributes in the console
You can globally set attribute options across all products from the
Search for commerce console
Controls
page
, on the
Site-wide controls
tab. For more details on how to set
this in the console, see
Manage site-wide attribute controls
.
To use this feature the configuration mode must be catalog level.
Changes to attribute configuration settings for indexable and searchable take
effect immediately upon catalog ingestion. Otherwise, it can take up to 12 hours
or more for changes to take effect. You can test if your changes have been
applied on the
Evaluate
page.
Configure attributes with
AttributesConfig
The
AttributesConfig
API resource lets you manage attribute configurations on
the catalog level.
The following fields set attribute options at the catalog level:
CatalogAttribute.indexableOption
: Sets the
indexable option for an attribute.
CatalogAttribute.dynamicFacetableOption
:
Sets the dynamic faceting option for an attribute.
CatalogAttribute.searchableOption
: Sets the
searchable option for an attribute.
CatalogAttribute.recommendationsFilteringOption
(Public Preview): Sets the recommendations filtering option for an attribute.
To retrieve all attribute configurations, use the
GetAttributesConfig
method.
Update multiple attributes
Use the
updateAttributesConfig
method to update
multiple attributes at the catalog level.
The catalog attributes you include in the request are updated in the
catalog, or inserted if they don't exist. If there is no value for a catalog
attribute field, it is assigned a default value.
The maximum number of catalog attributes allowed in a request is 1000.
Update an individual attribute
The following
methods
are used to update individual catalog attributes:
AddCatalogAttribute
: Adds an individual attribute configuration to a
catalog attribute.
See the API reference documentation for
AddCatalogAttribute
.
ReplaceCatalogAttribute
: Modifies an individual attribute configuration.
This replaces the specified
CatalogAttribute
in the
AttributesConfig
by
updating the catalog attribute with the same
CatalogAttribute.key
.
See the API reference documentation for
ReplaceCatalogAttribute
.
RemoveCatalogAttribute
: Removes an individual attribute configuration
from
AttributesConfig
.
Only
CatalogAttributes
that are not in use by products can be deleted. If a
CatalogAttribute
is in use,
RemoveCatalogAttribute
does not delete it, but
resets its configuration properties to default values.
CatalogAttribute.inUse
is set to
True
if the attribute is in use by any
products.
See the API reference documentation for
RemoveCatalogAttribute
.
Configure attributes with the
Product
method (deprecated)
Setting attributes with this method is not available to new
users and is not recommended.
The following fields set indexable and searchable settings for a specific
product using the
Product
API method:
Product.attributes.indexable
.
Product.attributes.searchable
. Only available for
custom attributes.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/attribution-tokens.txt
Attribution tokens  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Attribution tokens
Attribution tokens are unique IDs generated by Vertex AI Search for commerce and returned with each search request. They enable Vertex AI Search for commerce to associate a search request with its matching search event, which allows re-ranking models to improve the quality of search responses. Attribution tokens are also required in Vertex AI Search for commerce search events for accurate reporting.
Note:
Attribution tokens are only required for Vertex AI Search. They're not passed to all user events. Nor are they passed in the URL.
How attribution tokens work
You collect the
attributionToken
from the API response of a user's search. There is a
new attribution token for every search; attribution tokens are not repeated.
Important:
Attribution tokens are required in search impression events, but they are not to be sent for any other events, such as click, add-to-cart, and purchase.
When Vertex AI Search for commerce serves a search or recommendation request, it returns a unique
attributionToken
in its response:
This token is crucial for linking subsequent user actions (like clicks, adding to cart, and purchases) back to the specific search or recommendation that led to them.
It's important to link the correct search token into
Search Events
, so that
Detailed Page View Events
,
Add-to-Cart Events
, and
Purchase Events
can be connected properly.
A
placements.search
response should be sent back in a search or browse user event and immediately in the event a user interacts with a product. This includes user journeys such as:
search
(YES) →
add-to-cart
(YES)
search
(YES) →
detail-page-view
(YES)
search
(YES) →
purchase
(NO) (The user isn't directly interacting with a product at the time of purchase in the same way as with a click or
add-to-cart
, though the purchase is still attributed to the original search.)
Attribution token behavior
Attribution tokens are:
Visitor-specific
: The
attributionToken
is associated with a specific search response served to a particular `
visitorId
. Only the search event itself needs to be tagged with the token. All the subsequent non-search events are
not
to be tagged with a token.
Associated with events directly following search
: The
attributionToken
is particularly important for user events that represent a direct interaction with the search results of that specific search. This includes
purchase-complete events
: The purchase is still linked through the product IDs and
visitorId
.
Note: If a single user performs multiple searches, each new search request generates an attribution token, and the subsequent search event should carry that new token. An attribution token from a previous search event is not reused for a subsequent search event, because each search initiates a new token.
Attribution tokens in the Search API
Each response that the Vertex AI Search for commerce method returns includes a unique
attributionToken
at the end of the search response body. For example:
{
"results"
:
[
{
"id"
:
"727121"
,
"product"
:
{
…
}
],
"totalSize"
:
19600
,
"attributionToken"
:
"dfB0CgwIgKrltAYQ8afX4AIQARokNjZjMGEwYjEtMDAwMC0yNjAyLTk0Y2UtNTgyNDI5Y2JkMzUwKgUxMjM0NTIkxcvzF6OAlyLo5KotmNa3LY6-nRW3t4wtwvCeFdSynRWb1rctOg5kZWZhdWx0X3NlYXJjaGgB"
,
"nextPageToken"
:
"AM1MDZiNWOyQjM4UTLlNGN50iMwYjMtADMwATLwIGMhBzY2YDJaIw-bCbxQYAt1PJgIwgExEgC"
…
This token
must
be included in the subsequent search event:
{
"eventType"
:
"search"
,
"searchQuery"
:
"red t-shirt"
,
"productDetails"
:[
{
"product"
:{
"id"
:
"727121"
}},
{
"product"
:{
"id"
:
…
}
]
,
"visitorId"
:
"GA1.1.1383176924.1721324981"
,
"attributionToken"
:
"dfB0CgwIgKrltAYQ8afX4AIQARokNjZjMGEwYjEtMDAwMC0yNjAyLTk0Y2UtNTgyNDI5Y2JkMzUwKgUxMjM0NTIkxcvzF6OAlyLo5KotmNa3LY6-nRW3t4wtwvCeFdSynRWb1rctOg5kZWZhdWx0X3NlYXJjaGgB"
}
Vertex AI Search for commerce uses the event data to train its models. The attribution token provides a way to link the event with the request, encoding the full search request and response with the requested filters, facets, and response product IDs. Without a token present in the search events, those events are treated as if they were not from Google Vertex AI Search and the search events might be incorrectly used as if they were from another search provider.
It's fine (and expected) to have search events without tokens if they are served from another search provider, during an
A/B experiment
for example. However, there typically is a 1:1 mapping for search API
requests
to search
events
with tokens.
Adverse effect of missing tokens
If the
attributionToken
isn't in the relevant subsequent user events from the same visitor, Vertex AI Search for commerce treats those events as if they did not originate from its search service.
This can lead to:
Inaccurate model training.
Incorrect metrics and performance analysis.
Potential issues with achieving
higher performance tiers
(like Tier 3) that require sufficient attributable events.
Errors reported in the
Data quality dashboard
in the Search for commerce if the percentage of events with attribution tokens is less than 95%.
To learn from user behavior and optimize search results, Vertex AI Search for commerce requires accurate attribution for the initial search event only.
Attribution token data quality
The
Data quality dashboard
in the Search for commerce console will show a Critical or a Blocking non-compliance error
Status
if the percentage of events with attribution tokens is under 95%. Otherwise, the
Status
will show as Compliant:
The data quality at Tier 3 which is the revenue optimized model will usually not train without sufficient attributable events. It is strongly not recommended to deploy Vertex AI Search for commerce into production unless it is serving results in Tier 3 or Tier 4. For more information, see the Data quality section on how to
unlock perforance tiers
see the
Data quality
page of this documentation.
Attribution tokens for recommendations
Recommendations from Vertex AI Search automatically create synthetic tokens for events attributable to
predict
requests.
For recommendations predictions, if a user clicks on a recommended product, the
PredictResponse.attribution_token
should be passed as a URL parameter to the product page and then logged in the
detail-page-view
event.
Log displayed recommendations as part of
panelInfo
and set:
panelInfo
.
attributionToken
=
PredictResponse
.
attributionToken
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/audit-logging.txt
Vertex AI Search audit logging  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Vertex AI Search audit logging
This page breaks down Vertex AI Search audit logging procedures by service, methods, and API interfaces. The audit logs generated vary depending on the Vertex AI Search product (including
Recommendations AI
) and product component, such user events and models.
Recommendations AI audit logging
There are key Recommendations AI methods that generate various types of audit logs.
For data access:
PredictionService.Predict
: This method, used to get recommendations, is categorized as a
DATA_READ
operation and will appear in the data access audit logs.
ModelService.GetModel
and
ModelService.ListModels
: These methods for retrieving model information are also logged as
DATA_READ
operations.
For data modification:
Model management
:
CreateModel
,
DeleteModel
,
PauseModel
,
ResumeModel
,
TuneModel
,
UpdateModel
.
Methods that don't produce audit logs:
The
google.longrunning.Operations.GetOperation
and
google.longrunning.Operations.ListOperations
methods, which are used to check the status of long-running operations like model training don't produce audit logs.
Vertex AI Search audit logging
This document describes audit logging for Vertex AI Search. Google Cloud services
generate audit logs that record administrative and access activities within your Google Cloud resources.
For more information about Cloud Audit Logs, see the following:
Types of audit logs
Audit log entry structure
Storing and routing audit logs
Cloud Logging pricing summary
Enable Data Access audit logs
Service name
Vertex AI Search audit logs use the service name
retail.googleapis.com
.
Filter for this service:
protoPayload
.
serviceName
=
"retail.googleapis.com"
Methods by permission type
Each IAM permission has a
type
property, whose value is an enum
that can be one of four values:
ADMIN_READ
,
ADMIN_WRITE
,
DATA_READ
, or
DATA_WRITE
. When you call a method,
Vertex AI Search generates an audit log whose category is dependent on the
type
property of the permission required to perform the method.

Methods that require an IAM permission with the
type
property value
of
DATA_READ
,
DATA_WRITE
, or
ADMIN_READ
generate
Data Access
audit logs.

Methods that require an IAM permission with the
type
property value
of
ADMIN_WRITE
generate
Admin Activity
audit logs.
API methods in the following list that are marked with (LRO) are long-running operations (LROs).
These methods usually generate two audit log entries: one when the operation starts and
another when it ends. For more information see
Audit logs for long-running operations
.
Permission type
Methods
DATA_READ
google.cloud.retail.v2.AnalyticsService.ExportAnalyticsMetrics
google.cloud.retail.v2.CatalogService.GetAttributesConfig
google.cloud.retail.v2.CatalogService.GetCompletionConfig
google.cloud.retail.v2.CatalogService.GetDefaultBranch
google.cloud.retail.v2.CatalogService.ListCatalogs
google.cloud.retail.v2.CompletionService.CompleteQuery
google.cloud.retail.v2.ControlService.GetControl
google.cloud.retail.v2.ControlService.ListControls
google.cloud.retail.v2.ModelService.GetModel
google.cloud.retail.v2.ModelService.ListModels
google.cloud.retail.v2.PredictionService.Predict
google.cloud.retail.v2.ProductService.GetProduct
google.cloud.retail.v2.ProductService.ListProducts
google.cloud.retail.v2.SearchService.Search
google.cloud.retail.v2.ServingConfigService.GetServingConfig
google.cloud.retail.v2.ServingConfigService.ListServingConfigs
google.cloud.retail.v2alpha.AnalyticsService.ExportAnalyticsMetrics
(LRO)
google.cloud.retail.v2alpha.BranchService.GetBranch
google.cloud.retail.v2alpha.BranchService.ListBranches
google.cloud.retail.v2alpha.CatalogService.GetAttributesConfig
google.cloud.retail.v2alpha.CatalogService.GetCompletionConfig
google.cloud.retail.v2alpha.CatalogService.GetDefaultBranch
google.cloud.retail.v2alpha.CatalogService.ListCatalogs
google.cloud.retail.v2alpha.CompletionService.CompleteQuery
google.cloud.retail.v2alpha.ControlService.GetControl
google.cloud.retail.v2alpha.ControlService.ListControls
google.cloud.retail.v2alpha.ConversationalSearchService.ConversationalSearch
google.cloud.retail.v2alpha.ModelService.GetModel
google.cloud.retail.v2alpha.ModelService.ListModels
google.cloud.retail.v2alpha.PredictionService.Predict
google.cloud.retail.v2alpha.ProductService.ExportProducts
(LRO)
google.cloud.retail.v2alpha.ProductService.GetProduct
google.cloud.retail.v2alpha.ProductService.ListProducts
google.cloud.retail.v2alpha.ProjectService.GetAlertConfig
google.cloud.retail.v2alpha.ProjectService.GetLoggingConfig
google.cloud.retail.v2alpha.ProjectService.GetProject
google.cloud.retail.v2alpha.ProjectService.ListEnrolledSolutions
google.cloud.retail.v2alpha.SearchService.Search
google.cloud.retail.v2alpha.ServingConfigService.GetServingConfig
google.cloud.retail.v2alpha.ServingConfigService.ListServingConfigs
google.cloud.retail.v2alpha.UserEventService.ExportUserEvents
(LRO)
google.cloud.retail.v2beta.AnalyticsService.ExportAnalyticsMetrics
google.cloud.retail.v2beta.CatalogService.GetAttributesConfig
google.cloud.retail.v2beta.CatalogService.GetCompletionConfig
google.cloud.retail.v2beta.CatalogService.GetDefaultBranch
google.cloud.retail.v2beta.CatalogService.ListCatalogs
google.cloud.retail.v2beta.CompletionService.CompleteQuery
google.cloud.retail.v2beta.ControlService.GetControl
google.cloud.retail.v2beta.ControlService.ListControls
google.cloud.retail.v2beta.ModelService.GetModel
google.cloud.retail.v2beta.ModelService.ListModels
google.cloud.retail.v2beta.PredictionService.Predict
google.cloud.retail.v2beta.ProductService.ExportProducts
(LRO)
google.cloud.retail.v2beta.ProductService.GetProduct
google.cloud.retail.v2beta.ProductService.ListProducts
google.cloud.retail.v2beta.ProjectService.GetAlertConfig
google.cloud.retail.v2beta.SearchService.Search
google.cloud.retail.v2beta.ServingConfigService.GetServingConfig
google.cloud.retail.v2beta.ServingConfigService.ListServingConfigs
google.cloud.retail.v2beta.UserEventService.ExportUserEvents
(LRO)
DATA_WRITE
google.cloud.retail.v2.CatalogService.AddCatalogAttribute
google.cloud.retail.v2.CatalogService.RemoveCatalogAttribute
google.cloud.retail.v2.CatalogService.ReplaceCatalogAttribute
google.cloud.retail.v2.CatalogService.SetDefaultBranch
google.cloud.retail.v2.CatalogService.UpdateAttributesConfig
google.cloud.retail.v2.CatalogService.UpdateCatalog
google.cloud.retail.v2.CatalogService.UpdateCompletionConfig
google.cloud.retail.v2.CompletionService.ImportCompletionData
(LRO)
google.cloud.retail.v2.ControlService.CreateControl
google.cloud.retail.v2.ControlService.DeleteControl
google.cloud.retail.v2.ControlService.UpdateControl
google.cloud.retail.v2.ModelService.CreateModel
google.cloud.retail.v2.ModelService.DeleteModel
google.cloud.retail.v2.ModelService.PauseModel
google.cloud.retail.v2.ModelService.ResumeModel
google.cloud.retail.v2.ModelService.TuneModel
google.cloud.retail.v2.ModelService.UpdateModel
google.cloud.retail.v2.ProductService.AddFulfillmentPlaces
google.cloud.retail.v2.ProductService.AddLocalInventories
(LRO)
google.cloud.retail.v2.ProductService.CreateProduct
google.cloud.retail.v2.ProductService.DeleteProduct
google.cloud.retail.v2.ProductService.ImportProducts
(LRO)
google.cloud.retail.v2.ProductService.PurgeProducts
(LRO)
google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces
google.cloud.retail.v2.ProductService.RemoveLocalInventories
(LRO)
google.cloud.retail.v2.ProductService.SetInventory
(LRO)
google.cloud.retail.v2.ProductService.UpdateProduct
google.cloud.retail.v2.ServingConfigService.AddControl
google.cloud.retail.v2.ServingConfigService.CreateServingConfig
google.cloud.retail.v2.ServingConfigService.DeleteServingConfig
google.cloud.retail.v2.ServingConfigService.RemoveControl
google.cloud.retail.v2.ServingConfigService.UpdateServingConfig
google.cloud.retail.v2.UserEventService.ImportUserEvents
(LRO)
google.cloud.retail.v2.UserEventService.PurgeUserEvents
(LRO)
google.cloud.retail.v2.UserEventService.RejoinUserEvents
(LRO)
google.cloud.retail.v2.UserEventService.WriteUserEvent
google.cloud.retail.v2alpha.CatalogService.AddCatalogAttribute
google.cloud.retail.v2alpha.CatalogService.BatchRemoveCatalogAttributes
google.cloud.retail.v2alpha.CatalogService.RemoveCatalogAttribute
google.cloud.retail.v2alpha.CatalogService.ReplaceCatalogAttribute
google.cloud.retail.v2alpha.CatalogService.SetDefaultBranch
google.cloud.retail.v2alpha.CatalogService.UpdateAttributesConfig
google.cloud.retail.v2alpha.CatalogService.UpdateCatalog
google.cloud.retail.v2alpha.CatalogService.UpdateCompletionConfig
google.cloud.retail.v2alpha.CompletionService.ImportCompletionData
(LRO)
google.cloud.retail.v2alpha.ControlService.CreateControl
google.cloud.retail.v2alpha.ControlService.DeleteControl
google.cloud.retail.v2alpha.ControlService.UpdateControl
google.cloud.retail.v2alpha.ModelService.CreateModel
(LRO)
google.cloud.retail.v2alpha.ModelService.DeleteModel
google.cloud.retail.v2alpha.ModelService.PauseModel
google.cloud.retail.v2alpha.ModelService.ResumeModel
google.cloud.retail.v2alpha.ModelService.TuneModel
(LRO)
google.cloud.retail.v2alpha.ModelService.UpdateModel
google.cloud.retail.v2alpha.ProductService.AddFulfillmentPlaces
(LRO)
google.cloud.retail.v2alpha.ProductService.AddLocalInventories
(LRO)
google.cloud.retail.v2alpha.ProductService.CreateProduct
google.cloud.retail.v2alpha.ProductService.DeleteProduct
google.cloud.retail.v2alpha.ProductService.ImportProducts
(LRO)
google.cloud.retail.v2alpha.ProductService.PurgeProducts
(LRO)
google.cloud.retail.v2alpha.ProductService.RemoveFulfillmentPlaces
(LRO)
google.cloud.retail.v2alpha.ProductService.RemoveLocalInventories
(LRO)
google.cloud.retail.v2alpha.ProductService.SetInventory
(LRO)
google.cloud.retail.v2alpha.ProductService.UpdateProduct
google.cloud.retail.v2alpha.ProjectService.AcceptTerms
google.cloud.retail.v2alpha.ProjectService.EnrollSolution
(LRO)
google.cloud.retail.v2alpha.ProjectService.UpdateAlertConfig
google.cloud.retail.v2alpha.ProjectService.UpdateLoggingConfig
google.cloud.retail.v2alpha.ServingConfigService.AddControl
google.cloud.retail.v2alpha.ServingConfigService.CreateServingConfig
google.cloud.retail.v2alpha.ServingConfigService.DeleteServingConfig
google.cloud.retail.v2alpha.ServingConfigService.RemoveControl
google.cloud.retail.v2alpha.ServingConfigService.UpdateServingConfig
google.cloud.retail.v2alpha.UserEventService.ImportUserEvents
(LRO)
google.cloud.retail.v2alpha.UserEventService.PurgeUserEvents
(LRO)
google.cloud.retail.v2alpha.UserEventService.RejoinUserEvents
google.cloud.retail.v2alpha.UserEventService.WriteUserEvent
google.cloud.retail.v2beta.CatalogService.AddCatalogAttribute
google.cloud.retail.v2beta.CatalogService.BatchRemoveCatalogAttributes
google.cloud.retail.v2beta.CatalogService.RemoveCatalogAttribute
google.cloud.retail.v2beta.CatalogService.ReplaceCatalogAttribute
google.cloud.retail.v2beta.CatalogService.SetDefaultBranch
google.cloud.retail.v2beta.CatalogService.UpdateAttributesConfig
google.cloud.retail.v2beta.CatalogService.UpdateCatalog
google.cloud.retail.v2beta.CatalogService.UpdateCompletionConfig
google.cloud.retail.v2beta.CompletionService.ImportCompletionData
google.cloud.retail.v2beta.ControlService.CreateControl
google.cloud.retail.v2beta.ControlService.DeleteControl
google.cloud.retail.v2beta.ControlService.UpdateControl
google.cloud.retail.v2beta.ModelService.CreateModel
google.cloud.retail.v2beta.ModelService.DeleteModel
google.cloud.retail.v2beta.ModelService.PauseModel
google.cloud.retail.v2beta.ModelService.ResumeModel
google.cloud.retail.v2beta.ModelService.TuneModel
google.cloud.retail.v2beta.ModelService.UpdateModel
google.cloud.retail.v2beta.ProductService.AddFulfillmentPlaces
google.cloud.retail.v2beta.ProductService.AddLocalInventories
(LRO)
google.cloud.retail.v2beta.ProductService.CreateProduct
google.cloud.retail.v2beta.ProductService.DeleteProduct
google.cloud.retail.v2beta.ProductService.ImportProducts
(LRO)
google.cloud.retail.v2beta.ProductService.PurgeProducts
(LRO)
google.cloud.retail.v2beta.ProductService.RemoveFulfillmentPlaces
google.cloud.retail.v2beta.ProductService.RemoveLocalInventories
google.cloud.retail.v2beta.ProductService.SetInventory
google.cloud.retail.v2beta.ProductService.UpdateProduct
google.cloud.retail.v2beta.ProjectService.UpdateAlertConfig
google.cloud.retail.v2beta.ServingConfigService.AddControl
google.cloud.retail.v2beta.ServingConfigService.CreateServingConfig
google.cloud.retail.v2beta.ServingConfigService.DeleteServingConfig
google.cloud.retail.v2beta.ServingConfigService.RemoveControl
google.cloud.retail.v2beta.ServingConfigService.UpdateServingConfig
google.cloud.retail.v2beta.UserEventService.ImportUserEvents
(LRO)
google.cloud.retail.v2beta.UserEventService.PurgeUserEvents
(LRO)
google.cloud.retail.v2beta.UserEventService.RejoinUserEvents
google.cloud.retail.v2beta.UserEventService.WriteUserEvent
API interface audit logs
For information about how and which permissions are evaluated for each method,
see the Identity and Access Management documentation for Vertex AI Search.
google.cloud.retail.v2.AnalyticsService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.AnalyticsService
.
ExportAnalyticsMetrics
Method
:
google.cloud.retail.v2.AnalyticsService.ExportAnalyticsMetrics
Audit log type
:
Data access
Permissions
:
retail.catalogs.exportAnalyticsMetrics - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.AnalyticsService.ExportAnalyticsMetrics"
google.cloud.retail.v2.CatalogService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.CatalogService
.
AddCatalogAttribute
Method
:
google.cloud.retail.v2.CatalogService.AddCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.addCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.AddCatalogAttribute"
GetAttributesConfig
Method
:
google.cloud.retail.v2.CatalogService.GetAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.GetAttributesConfig"
GetCompletionConfig
Method
:
google.cloud.retail.v2.CatalogService.GetCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.GetCompletionConfig"
GetDefaultBranch
Method
:
google.cloud.retail.v2.CatalogService.GetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.GetDefaultBranch"
ListCatalogs
Method
:
google.cloud.retail.v2.CatalogService.ListCatalogs
Audit log type
:
Data access
Permissions
:
retail.catalogs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.ListCatalogs"
RemoveCatalogAttribute
Method
:
google.cloud.retail.v2.CatalogService.RemoveCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.removeCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.RemoveCatalogAttribute"
ReplaceCatalogAttribute
Method
:
google.cloud.retail.v2.CatalogService.ReplaceCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.replaceCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.ReplaceCatalogAttribute"
SetDefaultBranch
Method
:
google.cloud.retail.v2.CatalogService.SetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.SetDefaultBranch"
UpdateAttributesConfig
Method
:
google.cloud.retail.v2.CatalogService.UpdateAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.UpdateAttributesConfig"
UpdateCatalog
Method
:
google.cloud.retail.v2.CatalogService.UpdateCatalog
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.UpdateCatalog"
UpdateCompletionConfig
Method
:
google.cloud.retail.v2.CatalogService.UpdateCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CatalogService.UpdateCompletionConfig"
google.cloud.retail.v2.CompletionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.CompletionService
.
CompleteQuery
Method
:
google.cloud.retail.v2.CompletionService.CompleteQuery
Audit log type
:
Data access
Permissions
:
retail.catalogs.completeQuery - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CompletionService.CompleteQuery"
ImportCompletionData
Method
:
google.cloud.retail.v2.CompletionService.ImportCompletionData
Audit log type
:
Data access
Permissions
:
retail.catalogs.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.CompletionService.ImportCompletionData"
google.cloud.retail.v2.ControlService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.ControlService
.
CreateControl
Method
:
google.cloud.retail.v2.ControlService.CreateControl
Audit log type
:
Data access
Permissions
:
retail.controls.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ControlService.CreateControl"
DeleteControl
Method
:
google.cloud.retail.v2.ControlService.DeleteControl
Audit log type
:
Data access
Permissions
:
retail.controls.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ControlService.DeleteControl"
GetControl
Method
:
google.cloud.retail.v2.ControlService.GetControl
Audit log type
:
Data access
Permissions
:
retail.controls.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ControlService.GetControl"
ListControls
Method
:
google.cloud.retail.v2.ControlService.ListControls
Audit log type
:
Data access
Permissions
:
retail.controls.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ControlService.ListControls"
UpdateControl
Method
:
google.cloud.retail.v2.ControlService.UpdateControl
Audit log type
:
Data access
Permissions
:
retail.controls.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ControlService.UpdateControl"
google.cloud.retail.v2.ModelService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.ModelService
.
CreateModel
Method
:
google.cloud.retail.v2.ModelService.CreateModel
Audit log type
:
Data access
Permissions
:
retail.models.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.CreateModel"
DeleteModel
Method
:
google.cloud.retail.v2.ModelService.DeleteModel
Audit log type
:
Data access
Permissions
:
retail.models.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.DeleteModel"
GetModel
Method
:
google.cloud.retail.v2.ModelService.GetModel
Audit log type
:
Data access
Permissions
:
retail.models.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.GetModel"
ListModels
Method
:
google.cloud.retail.v2.ModelService.ListModels
Audit log type
:
Data access
Permissions
:
retail.models.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.ListModels"
PauseModel
Method
:
google.cloud.retail.v2.ModelService.PauseModel
Audit log type
:
Data access
Permissions
:
retail.models.pause - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.PauseModel"
ResumeModel
Method
:
google.cloud.retail.v2.ModelService.ResumeModel
Audit log type
:
Data access
Permissions
:
retail.models.resume - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.ResumeModel"
TuneModel
Method
:
google.cloud.retail.v2.ModelService.TuneModel
Audit log type
:
Data access
Permissions
:
retail.models.tune - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.TuneModel"
UpdateModel
Method
:
google.cloud.retail.v2.ModelService.UpdateModel
Audit log type
:
Data access
Permissions
:
retail.models.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ModelService.UpdateModel"
google.cloud.retail.v2.PredictionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.PredictionService
.
Predict
Method
:
google.cloud.retail.v2.PredictionService.Predict
Audit log type
:
Data access
Permissions
:
retail.placements.predict - DATA_READ
retail.servingConfigs.predict - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.PredictionService.Predict"
google.cloud.retail.v2.ProductService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.ProductService
.
AddFulfillmentPlaces
Method
:
google.cloud.retail.v2.ProductService.AddFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.AddFulfillmentPlaces"
AddLocalInventories
Method
:
google.cloud.retail.v2.ProductService.AddLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.AddLocalInventories"
CreateProduct
Method
:
google.cloud.retail.v2.ProductService.CreateProduct
Audit log type
:
Data access
Permissions
:
retail.products.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.CreateProduct"
DeleteProduct
Method
:
google.cloud.retail.v2.ProductService.DeleteProduct
Audit log type
:
Data access
Permissions
:
retail.products.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.DeleteProduct"
GetProduct
Method
:
google.cloud.retail.v2.ProductService.GetProduct
Audit log type
:
Data access
Permissions
:
retail.products.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.GetProduct"
ImportProducts
Method
:
google.cloud.retail.v2.ProductService.ImportProducts
Audit log type
:
Data access
Permissions
:
retail.products.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.ImportProducts"
ListProducts
Method
:
google.cloud.retail.v2.ProductService.ListProducts
Audit log type
:
Data access
Permissions
:
retail.products.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.ListProducts"
PurgeProducts
Method
:
google.cloud.retail.v2.ProductService.PurgeProducts
Audit log type
:
Data access
Permissions
:
retail.products.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.PurgeProducts"
RemoveFulfillmentPlaces
Method
:
google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces"
RemoveLocalInventories
Method
:
google.cloud.retail.v2.ProductService.RemoveLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.RemoveLocalInventories"
SetInventory
Method
:
google.cloud.retail.v2.ProductService.SetInventory
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.SetInventory"
UpdateProduct
Method
:
google.cloud.retail.v2.ProductService.UpdateProduct
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ProductService.UpdateProduct"
google.cloud.retail.v2.SearchService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.SearchService
.
Search
Method
:
google.cloud.retail.v2.SearchService.Search
Audit log type
:
Data access
Permissions
:
retail.placements.search - DATA_READ
retail.servingConfigs.search - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.SearchService.Search"
google.cloud.retail.v2.ServingConfigService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.ServingConfigService
.
AddControl
Method
:
google.cloud.retail.v2.ServingConfigService.AddControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.AddControl"
CreateServingConfig
Method
:
google.cloud.retail.v2.ServingConfigService.CreateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.CreateServingConfig"
DeleteServingConfig
Method
:
google.cloud.retail.v2.ServingConfigService.DeleteServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.DeleteServingConfig"
GetServingConfig
Method
:
google.cloud.retail.v2.ServingConfigService.GetServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.GetServingConfig"
ListServingConfigs
Method
:
google.cloud.retail.v2.ServingConfigService.ListServingConfigs
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.ListServingConfigs"
RemoveControl
Method
:
google.cloud.retail.v2.ServingConfigService.RemoveControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.RemoveControl"
UpdateServingConfig
Method
:
google.cloud.retail.v2.ServingConfigService.UpdateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.ServingConfigService.UpdateServingConfig"
google.cloud.retail.v2.UserEventService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2.UserEventService
.
ImportUserEvents
Method
:
google.cloud.retail.v2.UserEventService.ImportUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.UserEventService.ImportUserEvents"
PurgeUserEvents
Method
:
google.cloud.retail.v2.UserEventService.PurgeUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.UserEventService.PurgeUserEvents"
RejoinUserEvents
Method
:
google.cloud.retail.v2.UserEventService.RejoinUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.rejoin - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.UserEventService.RejoinUserEvents"
WriteUserEvent
Method
:
google.cloud.retail.v2.UserEventService.WriteUserEvent
Audit log type
:
Data access
Permissions
:
retail.userEvents.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2.UserEventService.WriteUserEvent"
google.cloud.retail.v2alpha.AnalyticsService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.AnalyticsService
.
ExportAnalyticsMetrics
Method
:
google.cloud.retail.v2alpha.AnalyticsService.ExportAnalyticsMetrics
Audit log type
:
Data access
Permissions
:
retail.catalogs.exportAnalyticsMetrics - DATA_READ
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.AnalyticsService.ExportAnalyticsMetrics"
google.cloud.retail.v2alpha.BranchService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.BranchService
.
GetBranch
Method
:
google.cloud.retail.v2alpha.BranchService.GetBranch
Audit log type
:
Data access
Permissions
:
retail.branches.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.BranchService.GetBranch"
ListBranches
Method
:
google.cloud.retail.v2alpha.BranchService.ListBranches
Audit log type
:
Data access
Permissions
:
retail.branches.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.BranchService.ListBranches"
google.cloud.retail.v2alpha.CatalogService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.CatalogService
.
AddCatalogAttribute
Method
:
google.cloud.retail.v2alpha.CatalogService.AddCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.addCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.AddCatalogAttribute"
BatchRemoveCatalogAttributes
Method
:
google.cloud.retail.v2alpha.CatalogService.BatchRemoveCatalogAttributes
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.batchRemoveCatalogAttributes - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.BatchRemoveCatalogAttributes"
GetAttributesConfig
Method
:
google.cloud.retail.v2alpha.CatalogService.GetAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.GetAttributesConfig"
GetCompletionConfig
Method
:
google.cloud.retail.v2alpha.CatalogService.GetCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.GetCompletionConfig"
GetDefaultBranch
Method
:
google.cloud.retail.v2alpha.CatalogService.GetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.GetDefaultBranch"
ListCatalogs
Method
:
google.cloud.retail.v2alpha.CatalogService.ListCatalogs
Audit log type
:
Data access
Permissions
:
retail.catalogs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.ListCatalogs"
RemoveCatalogAttribute
Method
:
google.cloud.retail.v2alpha.CatalogService.RemoveCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.removeCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.RemoveCatalogAttribute"
ReplaceCatalogAttribute
Method
:
google.cloud.retail.v2alpha.CatalogService.ReplaceCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.replaceCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.ReplaceCatalogAttribute"
SetDefaultBranch
Method
:
google.cloud.retail.v2alpha.CatalogService.SetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.SetDefaultBranch"
UpdateAttributesConfig
Method
:
google.cloud.retail.v2alpha.CatalogService.UpdateAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.UpdateAttributesConfig"
UpdateCatalog
Method
:
google.cloud.retail.v2alpha.CatalogService.UpdateCatalog
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.UpdateCatalog"
UpdateCompletionConfig
Method
:
google.cloud.retail.v2alpha.CatalogService.UpdateCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CatalogService.UpdateCompletionConfig"
google.cloud.retail.v2alpha.CompletionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.CompletionService
.
CompleteQuery
Method
:
google.cloud.retail.v2alpha.CompletionService.CompleteQuery
Audit log type
:
Data access
Permissions
:
retail.catalogs.completeQuery - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CompletionService.CompleteQuery"
ImportCompletionData
Method
:
google.cloud.retail.v2alpha.CompletionService.ImportCompletionData
Audit log type
:
Data access
Permissions
:
retail.catalogs.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.CompletionService.ImportCompletionData"
google.cloud.retail.v2alpha.ControlService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ControlService
.
CreateControl
Method
:
google.cloud.retail.v2alpha.ControlService.CreateControl
Audit log type
:
Data access
Permissions
:
retail.controls.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ControlService.CreateControl"
DeleteControl
Method
:
google.cloud.retail.v2alpha.ControlService.DeleteControl
Audit log type
:
Data access
Permissions
:
retail.controls.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ControlService.DeleteControl"
GetControl
Method
:
google.cloud.retail.v2alpha.ControlService.GetControl
Audit log type
:
Data access
Permissions
:
retail.controls.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ControlService.GetControl"
ListControls
Method
:
google.cloud.retail.v2alpha.ControlService.ListControls
Audit log type
:
Data access
Permissions
:
retail.controls.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ControlService.ListControls"
UpdateControl
Method
:
google.cloud.retail.v2alpha.ControlService.UpdateControl
Audit log type
:
Data access
Permissions
:
retail.controls.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ControlService.UpdateControl"
google.cloud.retail.v2alpha.ConversationalSearchService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ConversationalSearchService
.
ConversationalSearch
Method
:
google.cloud.retail.v2alpha.ConversationalSearchService.ConversationalSearch
Audit log type
:
Data access
Permissions
:
retail.placements.conversationalSearch - DATA_READ
Method is a long-running or streaming operation
:
Streaming RPC
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ConversationalSearchService.ConversationalSearch"
google.cloud.retail.v2alpha.ModelService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ModelService
.
CreateModel
Method
:
google.cloud.retail.v2alpha.ModelService.CreateModel
Audit log type
:
Data access
Permissions
:
retail.models.create - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.CreateModel"
DeleteModel
Method
:
google.cloud.retail.v2alpha.ModelService.DeleteModel
Audit log type
:
Data access
Permissions
:
retail.models.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.DeleteModel"
GetModel
Method
:
google.cloud.retail.v2alpha.ModelService.GetModel
Audit log type
:
Data access
Permissions
:
retail.models.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.GetModel"
ListModels
Method
:
google.cloud.retail.v2alpha.ModelService.ListModels
Audit log type
:
Data access
Permissions
:
retail.models.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.ListModels"
PauseModel
Method
:
google.cloud.retail.v2alpha.ModelService.PauseModel
Audit log type
:
Data access
Permissions
:
retail.models.pause - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.PauseModel"
ResumeModel
Method
:
google.cloud.retail.v2alpha.ModelService.ResumeModel
Audit log type
:
Data access
Permissions
:
retail.models.resume - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.ResumeModel"
TuneModel
Method
:
google.cloud.retail.v2alpha.ModelService.TuneModel
Audit log type
:
Data access
Permissions
:
retail.models.tune - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.TuneModel"
UpdateModel
Method
:
google.cloud.retail.v2alpha.ModelService.UpdateModel
Audit log type
:
Data access
Permissions
:
retail.models.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ModelService.UpdateModel"
google.cloud.retail.v2alpha.PredictionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.PredictionService
.
Predict
Method
:
google.cloud.retail.v2alpha.PredictionService.Predict
Audit log type
:
Data access
Permissions
:
retail.placements.predict - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.PredictionService.Predict"
google.cloud.retail.v2alpha.ProductService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ProductService
.
AddFulfillmentPlaces
Method
:
google.cloud.retail.v2alpha.ProductService.AddFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.AddFulfillmentPlaces"
AddLocalInventories
Method
:
google.cloud.retail.v2alpha.ProductService.AddLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.AddLocalInventories"
CreateProduct
Method
:
google.cloud.retail.v2alpha.ProductService.CreateProduct
Audit log type
:
Data access
Permissions
:
retail.products.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.CreateProduct"
DeleteProduct
Method
:
google.cloud.retail.v2alpha.ProductService.DeleteProduct
Audit log type
:
Data access
Permissions
:
retail.products.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.DeleteProduct"
ExportProducts
Method
:
google.cloud.retail.v2alpha.ProductService.ExportProducts
Audit log type
:
Data access
Permissions
:
retail.products.export - DATA_READ
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.ExportProducts"
GetProduct
Method
:
google.cloud.retail.v2alpha.ProductService.GetProduct
Audit log type
:
Data access
Permissions
:
retail.products.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.GetProduct"
ImportProducts
Method
:
google.cloud.retail.v2alpha.ProductService.ImportProducts
Audit log type
:
Data access
Permissions
:
retail.products.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.ImportProducts"
ListProducts
Method
:
google.cloud.retail.v2alpha.ProductService.ListProducts
Audit log type
:
Data access
Permissions
:
retail.products.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.ListProducts"
PurgeProducts
Method
:
google.cloud.retail.v2alpha.ProductService.PurgeProducts
Audit log type
:
Data access
Permissions
:
retail.products.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.PurgeProducts"
RemoveFulfillmentPlaces
Method
:
google.cloud.retail.v2alpha.ProductService.RemoveFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.RemoveFulfillmentPlaces"
RemoveLocalInventories
Method
:
google.cloud.retail.v2alpha.ProductService.RemoveLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.RemoveLocalInventories"
SetInventory
Method
:
google.cloud.retail.v2alpha.ProductService.SetInventory
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.SetInventory"
UpdateProduct
Method
:
google.cloud.retail.v2alpha.ProductService.UpdateProduct
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProductService.UpdateProduct"
google.cloud.retail.v2alpha.ProjectService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ProjectService
.
AcceptTerms
Method
:
google.cloud.retail.v2alpha.ProjectService.AcceptTerms
Audit log type
:
Data access
Permissions
:
retail.retailProjects.acceptDataTerms - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.AcceptTerms"
EnrollSolution
Method
:
google.cloud.retail.v2alpha.ProjectService.EnrollSolution
Audit log type
:
Data access
Permissions
:
retail.solutions.enroll - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.EnrollSolution"
GetAlertConfig
Method
:
google.cloud.retail.v2alpha.ProjectService.GetAlertConfig
Audit log type
:
Data access
Permissions
:
retail.alertConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.GetAlertConfig"
GetLoggingConfig
Method
:
google.cloud.retail.v2alpha.ProjectService.GetLoggingConfig
Audit log type
:
Data access
Permissions
:
retail.loggingConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.GetLoggingConfig"
GetProject
Method
:
google.cloud.retail.v2alpha.ProjectService.GetProject
Audit log type
:
Data access
Permissions
:
retail.retailProjects.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.GetProject"
ListEnrolledSolutions
Method
:
google.cloud.retail.v2alpha.ProjectService.ListEnrolledSolutions
Audit log type
:
Data access
Permissions
:
retail.solutions.listEnrolled - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.ListEnrolledSolutions"
UpdateAlertConfig
Method
:
google.cloud.retail.v2alpha.ProjectService.UpdateAlertConfig
Audit log type
:
Data access
Permissions
:
retail.alertConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.UpdateAlertConfig"
UpdateLoggingConfig
Method
:
google.cloud.retail.v2alpha.ProjectService.UpdateLoggingConfig
Audit log type
:
Data access
Permissions
:
retail.loggingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ProjectService.UpdateLoggingConfig"
google.cloud.retail.v2alpha.SearchService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.SearchService
.
Search
Method
:
google.cloud.retail.v2alpha.SearchService.Search
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.search - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.SearchService.Search"
google.cloud.retail.v2alpha.ServingConfigService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.ServingConfigService
.
AddControl
Method
:
google.cloud.retail.v2alpha.ServingConfigService.AddControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.AddControl"
CreateServingConfig
Method
:
google.cloud.retail.v2alpha.ServingConfigService.CreateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.CreateServingConfig"
DeleteServingConfig
Method
:
google.cloud.retail.v2alpha.ServingConfigService.DeleteServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.DeleteServingConfig"
GetServingConfig
Method
:
google.cloud.retail.v2alpha.ServingConfigService.GetServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.GetServingConfig"
ListServingConfigs
Method
:
google.cloud.retail.v2alpha.ServingConfigService.ListServingConfigs
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.ListServingConfigs"
RemoveControl
Method
:
google.cloud.retail.v2alpha.ServingConfigService.RemoveControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.RemoveControl"
UpdateServingConfig
Method
:
google.cloud.retail.v2alpha.ServingConfigService.UpdateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.ServingConfigService.UpdateServingConfig"
google.cloud.retail.v2alpha.UserEventService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2alpha.UserEventService
.
ExportUserEvents
Method
:
google.cloud.retail.v2alpha.UserEventService.ExportUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.export - DATA_READ
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.UserEventService.ExportUserEvents"
ImportUserEvents
Method
:
google.cloud.retail.v2alpha.UserEventService.ImportUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.UserEventService.ImportUserEvents"
PurgeUserEvents
Method
:
google.cloud.retail.v2alpha.UserEventService.PurgeUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.UserEventService.PurgeUserEvents"
RejoinUserEvents
Method
:
google.cloud.retail.v2alpha.UserEventService.RejoinUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.rejoin - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.UserEventService.RejoinUserEvents"
WriteUserEvent
Method
:
google.cloud.retail.v2alpha.UserEventService.WriteUserEvent
Audit log type
:
Data access
Permissions
:
retail.userEvents.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2alpha.UserEventService.WriteUserEvent"
google.cloud.retail.v2beta.AnalyticsService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.AnalyticsService
.
ExportAnalyticsMetrics
Method
:
google.cloud.retail.v2beta.AnalyticsService.ExportAnalyticsMetrics
Audit log type
:
Data access
Permissions
:
retail.catalogs.exportAnalyticsMetrics - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.AnalyticsService.ExportAnalyticsMetrics"
google.cloud.retail.v2beta.CatalogService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.CatalogService
.
AddCatalogAttribute
Method
:
google.cloud.retail.v2beta.CatalogService.AddCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.addCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.AddCatalogAttribute"
BatchRemoveCatalogAttributes
Method
:
google.cloud.retail.v2beta.CatalogService.BatchRemoveCatalogAttributes
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.batchRemoveCatalogAttributes - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.BatchRemoveCatalogAttributes"
GetAttributesConfig
Method
:
google.cloud.retail.v2beta.CatalogService.GetAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.GetAttributesConfig"
GetCompletionConfig
Method
:
google.cloud.retail.v2beta.CatalogService.GetCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.GetCompletionConfig"
GetDefaultBranch
Method
:
google.cloud.retail.v2beta.CatalogService.GetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.GetDefaultBranch"
ListCatalogs
Method
:
google.cloud.retail.v2beta.CatalogService.ListCatalogs
Audit log type
:
Data access
Permissions
:
retail.catalogs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.ListCatalogs"
RemoveCatalogAttribute
Method
:
google.cloud.retail.v2beta.CatalogService.RemoveCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.removeCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.RemoveCatalogAttribute"
ReplaceCatalogAttribute
Method
:
google.cloud.retail.v2beta.CatalogService.ReplaceCatalogAttribute
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.replaceCatalogAttribute - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.ReplaceCatalogAttribute"
SetDefaultBranch
Method
:
google.cloud.retail.v2beta.CatalogService.SetDefaultBranch
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.SetDefaultBranch"
UpdateAttributesConfig
Method
:
google.cloud.retail.v2beta.CatalogService.UpdateAttributesConfig
Audit log type
:
Data access
Permissions
:
retail.attributesConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.UpdateAttributesConfig"
UpdateCatalog
Method
:
google.cloud.retail.v2beta.CatalogService.UpdateCatalog
Audit log type
:
Data access
Permissions
:
retail.catalogs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.UpdateCatalog"
UpdateCompletionConfig
Method
:
google.cloud.retail.v2beta.CatalogService.UpdateCompletionConfig
Audit log type
:
Data access
Permissions
:
retail.completionConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CatalogService.UpdateCompletionConfig"
google.cloud.retail.v2beta.CompletionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.CompletionService
.
CompleteQuery
Method
:
google.cloud.retail.v2beta.CompletionService.CompleteQuery
Audit log type
:
Data access
Permissions
:
retail.catalogs.completeQuery - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CompletionService.CompleteQuery"
ImportCompletionData
Method
:
google.cloud.retail.v2beta.CompletionService.ImportCompletionData
Audit log type
:
Data access
Permissions
:
retail.catalogs.import - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.CompletionService.ImportCompletionData"
google.cloud.retail.v2beta.ControlService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.ControlService
.
CreateControl
Method
:
google.cloud.retail.v2beta.ControlService.CreateControl
Audit log type
:
Data access
Permissions
:
retail.controls.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ControlService.CreateControl"
DeleteControl
Method
:
google.cloud.retail.v2beta.ControlService.DeleteControl
Audit log type
:
Data access
Permissions
:
retail.controls.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ControlService.DeleteControl"
GetControl
Method
:
google.cloud.retail.v2beta.ControlService.GetControl
Audit log type
:
Data access
Permissions
:
retail.controls.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ControlService.GetControl"
ListControls
Method
:
google.cloud.retail.v2beta.ControlService.ListControls
Audit log type
:
Data access
Permissions
:
retail.controls.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ControlService.ListControls"
UpdateControl
Method
:
google.cloud.retail.v2beta.ControlService.UpdateControl
Audit log type
:
Data access
Permissions
:
retail.controls.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ControlService.UpdateControl"
google.cloud.retail.v2beta.ModelService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.ModelService
.
CreateModel
Method
:
google.cloud.retail.v2beta.ModelService.CreateModel
Audit log type
:
Data access
Permissions
:
retail.models.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.CreateModel"
DeleteModel
Method
:
google.cloud.retail.v2beta.ModelService.DeleteModel
Audit log type
:
Data access
Permissions
:
retail.models.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.DeleteModel"
GetModel
Method
:
google.cloud.retail.v2beta.ModelService.GetModel
Audit log type
:
Data access
Permissions
:
retail.models.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.GetModel"
ListModels
Method
:
google.cloud.retail.v2beta.ModelService.ListModels
Audit log type
:
Data access
Permissions
:
retail.models.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.ListModels"
PauseModel
Method
:
google.cloud.retail.v2beta.ModelService.PauseModel
Audit log type
:
Data access
Permissions
:
retail.models.pause - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.PauseModel"
ResumeModel
Method
:
google.cloud.retail.v2beta.ModelService.ResumeModel
Audit log type
:
Data access
Permissions
:
retail.models.resume - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.ResumeModel"
TuneModel
Method
:
google.cloud.retail.v2beta.ModelService.TuneModel
Audit log type
:
Data access
Permissions
:
retail.models.tune - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.TuneModel"
UpdateModel
Method
:
google.cloud.retail.v2beta.ModelService.UpdateModel
Audit log type
:
Data access
Permissions
:
retail.models.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ModelService.UpdateModel"
google.cloud.retail.v2beta.PredictionService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.PredictionService
.
Predict
Method
:
google.cloud.retail.v2beta.PredictionService.Predict
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.predict - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.PredictionService.Predict"
google.cloud.retail.v2beta.ProductService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.ProductService
.
AddFulfillmentPlaces
Method
:
google.cloud.retail.v2beta.ProductService.AddFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.AddFulfillmentPlaces"
AddLocalInventories
Method
:
google.cloud.retail.v2beta.ProductService.AddLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.AddLocalInventories"
CreateProduct
Method
:
google.cloud.retail.v2beta.ProductService.CreateProduct
Audit log type
:
Data access
Permissions
:
retail.products.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.CreateProduct"
DeleteProduct
Method
:
google.cloud.retail.v2beta.ProductService.DeleteProduct
Audit log type
:
Data access
Permissions
:
retail.products.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.DeleteProduct"
ExportProducts
Method
:
google.cloud.retail.v2beta.ProductService.ExportProducts
Audit log type
:
Data access
Permissions
:
retail.products.export - DATA_READ
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.ExportProducts"
GetProduct
Method
:
google.cloud.retail.v2beta.ProductService.GetProduct
Audit log type
:
Data access
Permissions
:
retail.products.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.GetProduct"
ImportProducts
Method
:
google.cloud.retail.v2beta.ProductService.ImportProducts
Audit log type
:
Data access
Permissions
:
retail.products.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.ImportProducts"
ListProducts
Method
:
google.cloud.retail.v2beta.ProductService.ListProducts
Audit log type
:
Data access
Permissions
:
retail.products.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.ListProducts"
PurgeProducts
Method
:
google.cloud.retail.v2beta.ProductService.PurgeProducts
Audit log type
:
Data access
Permissions
:
retail.products.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.PurgeProducts"
RemoveFulfillmentPlaces
Method
:
google.cloud.retail.v2beta.ProductService.RemoveFulfillmentPlaces
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.RemoveFulfillmentPlaces"
RemoveLocalInventories
Method
:
google.cloud.retail.v2beta.ProductService.RemoveLocalInventories
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.RemoveLocalInventories"
SetInventory
Method
:
google.cloud.retail.v2beta.ProductService.SetInventory
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.SetInventory"
UpdateProduct
Method
:
google.cloud.retail.v2beta.ProductService.UpdateProduct
Audit log type
:
Data access
Permissions
:
retail.products.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProductService.UpdateProduct"
google.cloud.retail.v2beta.ProjectService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.ProjectService
.
GetAlertConfig
Method
:
google.cloud.retail.v2beta.ProjectService.GetAlertConfig
Audit log type
:
Data access
Permissions
:
retail.alertConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProjectService.GetAlertConfig"
UpdateAlertConfig
Method
:
google.cloud.retail.v2beta.ProjectService.UpdateAlertConfig
Audit log type
:
Data access
Permissions
:
retail.alertConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ProjectService.UpdateAlertConfig"
google.cloud.retail.v2beta.SearchService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.SearchService
.
Search
Method
:
google.cloud.retail.v2beta.SearchService.Search
Audit log type
:
Data access
Permissions
:
retail.placements.search - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.SearchService.Search"
google.cloud.retail.v2beta.ServingConfigService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.ServingConfigService
.
AddControl
Method
:
google.cloud.retail.v2beta.ServingConfigService.AddControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.AddControl"
CreateServingConfig
Method
:
google.cloud.retail.v2beta.ServingConfigService.CreateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.CreateServingConfig"
DeleteServingConfig
Method
:
google.cloud.retail.v2beta.ServingConfigService.DeleteServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.delete - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.DeleteServingConfig"
GetServingConfig
Method
:
google.cloud.retail.v2beta.ServingConfigService.GetServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.get - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.GetServingConfig"
ListServingConfigs
Method
:
google.cloud.retail.v2beta.ServingConfigService.ListServingConfigs
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.list - DATA_READ
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.ListServingConfigs"
RemoveControl
Method
:
google.cloud.retail.v2beta.ServingConfigService.RemoveControl
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.RemoveControl"
UpdateServingConfig
Method
:
google.cloud.retail.v2beta.ServingConfigService.UpdateServingConfig
Audit log type
:
Data access
Permissions
:
retail.servingConfigs.update - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.ServingConfigService.UpdateServingConfig"
google.cloud.retail.v2beta.UserEventService
The following audit logs are associated with methods belonging to
google.cloud.retail.v2beta.UserEventService
.
ExportUserEvents
Method
:
google.cloud.retail.v2beta.UserEventService.ExportUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.export - DATA_READ
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.UserEventService.ExportUserEvents"
ImportUserEvents
Method
:
google.cloud.retail.v2beta.UserEventService.ImportUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.import - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.UserEventService.ImportUserEvents"
PurgeUserEvents
Method
:
google.cloud.retail.v2beta.UserEventService.PurgeUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.purge - DATA_WRITE
Method is a long-running or streaming operation
:
Long-running operation
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.UserEventService.PurgeUserEvents"
RejoinUserEvents
Method
:
google.cloud.retail.v2beta.UserEventService.RejoinUserEvents
Audit log type
:
Data access
Permissions
:
retail.userEvents.rejoin - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.UserEventService.RejoinUserEvents"
WriteUserEvent
Method
:
google.cloud.retail.v2beta.UserEventService.WriteUserEvent
Audit log type
:
Data access
Permissions
:
retail.userEvents.create - DATA_WRITE
Method is a long-running or streaming operation
:
No.
Filter for this method
:
protoPayload.methodName="google.cloud.retail.v2beta.UserEventService.WriteUserEvent"
Methods that don't produce audit logs
A method might not produce audit logs for one or more of the following
reasons:
It is a high volume method involving significant log generation and storage
  costs.
It has low auditing value.
Another audit or platform log already provides method coverage.
The following methods don't produce audit logs:
google.cloud.retail.v2.UserEventService.CollectUserEvent
google.cloud.retail.v2alpha.MerchantCenterAccountLinkService.CreateMerchantCenterAccountLink
google.cloud.retail.v2alpha.MerchantCenterAccountLinkService.DeleteMerchantCenterAccountLink
google.cloud.retail.v2alpha.MerchantCenterAccountLinkService.ListMerchantCenterAccountLinks
google.cloud.retail.v2alpha.UserEventService.CollectUserEvent
google.cloud.retail.v2beta.UserEventService.CollectUserEvent
google.longrunning.Operations.GetOperation
google.longrunning.Operations.ListOperations
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/authentication.txt
Authenticate to Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Authenticate to Vertex AI Search for commerce
This document describes how to authenticate to Vertex AI Search for commerce programmatically. How
      you authenticate to Vertex AI Search for commerce depends on the interface you use to access the API
      and the environment where your code is running.
For more information about Google Cloud authentication, see the
Authentication methods
.
API access
Vertex AI Search for commerce supports programmatic access. You can access the API in
      the following ways:
Client libraries
REST
Client libraries
The
Vertex AI Search for commerce client libraries
provide
        high-level language support for authenticating to Vertex AI Search for commerce
        programmatically.
        

To authenticate calls to Google Cloud APIs, client libraries support
Application Default Credentials (ADC)
;
the libraries look for credentials in a set of defined locations and use those credentials
to authenticate requests to the API. With ADC, you can make
credentials available to your application in a variety of environments, such as local
development or production, without needing to modify your application code.
REST
You can authenticate to
the Vertex AI Search for commerce API
by using your gcloud CLI credentials or by using
Application Default Credentials
.
        For more information about authentication for REST requests, see
Authenticate for using REST
.
        For information about the types of credentials, see
gcloud CLI credentials and ADC credentials
.
API keys
API keys provide a way to associate an API call with a project, which is used for billing
        and quota purposes, without determining the identity of the caller. API keys can be used
        only with API methods that support API keys.
Vertex AI Search for commerce supports API keys for the following API methods:
userEvents.collect
For more information about using API keys with Vertex AI Search for commerce, see
Create an API key
.
        
        For general information about using API keys, see
Authenticate using API keys
.
User credentials and ADC for Vertex AI Search for commerce
One way to provide credentials to ADC is to use the gcloud CLI to insert your
        user credentials into a credential file. This file is placed on your local file system where
        ADC can find it; ADC then uses the provided user credentials to authenticate requests. This
        method is often used for local development.
If you use this method, you might encounter an authentication error when you try to
        authenticate to Vertex AI Search for commerce. For more information about this error and how
        to address it, see
User credentials not working
.
Set up authentication for Vertex AI Search for commerce
How you set up authentication depends on the environment where your code is running.
The following options for setting up authentication are the most commonly used. For more
        options and information about authentication, see
Authentication methods
.
Before you complete these instructions, you must complete the basic setup for
          Vertex AI Search for commerce, as described in
Before you begin
.
For a local development environment
You can set up credentials for a local development environment in the following ways:
User credentials for client libraries or third-party tools
User credentials for REST requests from the command line
Service account impersonation
Client libraries or third-party tools
Set up
Application Default Credentials (ADC)
in your local environment:
Install
the Google Cloud CLI.
        
          After installation,
initialize
the Google Cloud CLI by running the following command:
gcloud
init
If you're using an external identity provider (IdP), you must first
sign in to the gcloud CLI with your federated identity
.
If you're using a local shell, then create local authentication credentials for your user
        account:
gcloud
auth
application-default
login
You don't need to do this if you're using Cloud Shell.
Note:
If the gcloud CLI prints a warning that your account
          doesn't have the
serviceusage.services.use
permission, then some
          gcloud CLI commands and client libraries might not work. Ask an
          administrator to grant you the Service Usage Consumer IAM role
          (
roles/serviceusage.serviceUsageConsumer
), then run the following command:
gcloud
auth
application-default
set-quota-project
PROJECT_ID
If an authentication error is returned, and you are using an external identity provider
        (IdP), confirm that you have
signed in to the gcloud CLI with your federated identity
.
A sign-in screen appears. After you sign in, your credentials are stored in the
local credential file used by ADC
.
For more information about working with ADC in a local environment, see
Set up ADC for a local development environment
.
REST requests from the command line
When you make a REST request from the command line,
          you can use your gcloud CLI credentials by including
gcloud auth print-access-token
as part of the command that sends the request.
The following example lists service accounts for the specified project. You can use the
          same pattern for any REST request.
Before using any of the request data,
  make the following replacements:
PROJECT_ID
: Your Google Cloud project ID.
To send your request, expand one of these options:
curl (Linux, macOS, or Cloud Shell)
Execute the following command:
curl -X GET \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "x-goog-user-project:
PROJECT_ID
" \
"https://iam.googleapis.com/v1/projects/
PROJECT_ID
/serviceAccounts"
PowerShell (Windows)
Execute the following command:
$cred = gcloud auth print-access-token
$headers = @{ "Authorization" = "Bearer $cred"; "x-goog-user-project" = "
PROJECT_ID
" }
Invoke-WebRequest `
-Method GET `
-Headers $headers `
-Uri "https://iam.googleapis.com/v1/projects/
PROJECT_ID
/serviceAccounts" | Select-Object -Expand Content
For more information about authenticating using REST and gRPC, see
Authenticate for using REST
.
          For information about the difference between your local ADC credentials and your
          gcloud CLI credentials, see
gcloud CLI authentication configuration and ADC configuration
.
Service account impersonation
In most cases, you can use your user credentials to authenticate from a local development
        environment. If that is not feasible, or if you need to test the permissions assigned to
        a service account, you can use service account impersonation. You must have the
iam.serviceAccounts.getAccessToken
permission, which is included in the
Service Account Token Creator
(
roles/iam.serviceAccountTokenCreator
) IAM role.
You can set up the gcloud CLI to use service account impersonation by using the
gcloud config set
command
:
gcloud
config
set
auth/impersonate_service_account
SERVICE_ACCT_EMAIL
For select languages, you can use service account impersonation to create a local ADC file
        for use by client libraries. This approach is supported only for the Go, Java, Node.js, and
        Python client libraries—it is not supported for the other languages.
        To set up a local ADC file with service account impersonation, use the
--impersonate-service-account
flag
with the
gcloud auth application-default login
command
:
gcloud
auth
application-default
login
--impersonate-service-account
=
SERVICE_ACCT_EMAIL
For more information about service account impersonation, see
Use service account impersonation
.
On Google Cloud
To authenticate a workload running on Google Cloud, you use the credentials of the
          service account attached to the compute resource where your code is running, such as a
Compute Engine virtual machine (VM) instance
.
          This approach is the preferred authentication method for code running on a
          Google Cloud compute resource.
For most services, you must attach the service account when you create the
          resource that will run your code; you cannot add or replace the service account
          later. Compute Engine is an exception—it lets you attach a service
          account to a VM instance at any time.
Use the gcloud CLI to create a service account and attach it to your
          resource:
Install
the Google Cloud CLI.
        
          After installation,
initialize
the Google Cloud CLI by running the following command:
gcloud
init
If you're using an external identity provider (IdP), you must first
sign in to the gcloud CLI with your federated identity
.
Set up authentication:
Ensure that you have the Create Service Accounts IAM role
    (
roles/iam.serviceAccountCreator
).
Learn how to grant roles
.
Create the service account:
gcloud
iam
service-accounts
create
SERVICE_ACCOUNT_NAME
Replace
SERVICE_ACCOUNT_NAME
with a name for the service account.
To provide access to your project and your resources, grant a role to the service account:
gcloud
projects
add-iam-policy-binding
PROJECT_ID
--member
=
"serviceAccount:
SERVICE_ACCOUNT_NAME
@
PROJECT_ID
.iam.gserviceaccount.com"
--role
=
ROLE
Replace the following:
SERVICE_ACCOUNT_NAME
: the name of the service account
PROJECT_ID
: the project ID where you created the service account
ROLE
: the role to grant
Note
: The
--role
flag affects which resources the service account can access in your
    project. You can revoke these roles or grant additional roles later.
    
      
  In production environments, do not grant the Owner, Editor, or Viewer roles. Instead, grant a
predefined role
or
custom role
that meets your needs.
To grant another role to the service account, run the command as you did in the previous step.
Grant the required role to the principal that
      will attach the service account to other resources.
gcloud
iam
service-accounts
add-iam-policy-binding
SERVICE_ACCOUNT_NAME
@
PROJECT_ID
.iam.gserviceaccount.com
--member
=
"user:
USER_EMAIL
"
--role
=
roles/iam.serviceAccountUser
Replace the following:
SERVICE_ACCOUNT_NAME
: the name of the service account
PROJECT_ID
: the project ID where you created the service account
USER_EMAIL
: the email address for a Google Account
Create the resource that will run your code, and attach the service account to that
              resource. For example, if you use Compute Engine:
Create a Compute Engine instance. Configure the instance as follows:
Replace
INSTANCE_NAME
with your preferred
          instance name.
Set the
--zone
flag to the
zone
in which you want to create
          your instance.
Set the
--service-account
flag to the email address for the service account
          that you created.
gcloud
compute
instances
create
INSTANCE_NAME
--zone=
ZONE
--service-account=
SERVICE_ACCOUNT_EMAIL
For more information about authenticating to Google APIs, see
Authentication methods
.
On-premises or on a different cloud provider
The preferred method to set up authentication from outside of Google Cloud is to use
          workload identity federation. For more information, see
Set up ADC for on-premises or another cloud provider
in the authentication documentation.
Access control for Vertex AI Search for commerce
After you authenticate to Vertex AI Search for commerce, you must be authorized to access
        Google Cloud resources. Vertex AI Search for commerce uses
        Identity and Access Management (IAM) for authorization.
For more information about the roles for Vertex AI Search for commerce, see
Identity and Access Management (IAM)
.
        For more information about IAM and authorization, see
IAM overview
.
What's next
Learn about
Google Cloud authentication methods
.
See a list of
authentication use cases
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/billing-questions.txt
Billing questions  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All support
Get support
Billing questions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Support
Send feedback
Billing questions
Note:
The following resources are available for recommendations.
They are not applicable to search while it is in preview.
Use the following resources to get help with billing questions:
To learn more about billing, read the
Cloud Billing documentation
.
Resolve billing concerns by using the
billing concerns troubleshooter
.
Request help with billing questions by using the
billing support form
.
To change or disable billing on a project, go to the
Billing
page in the
Google Cloud console. For more information, see
Modify a Project's Billing Settings
in the Google Cloud console Help.
Caution:
When you disable billing for a project, you also disable all
product resources in that project.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/boosting.txt
Boost results  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Boost results
Vertex AI Search for commerce offers a feature that lets you specify records that should be elevated in searches. You can control the result ranking by applying a boosting rule to
prioritize or deprioritize returned search items.
Boosting rules
Boosting rules can only be applied when there's a base relevance score, such as in relevance-ordered searches or browse results with pre-sort scores. Boosting is a multiplier function applied to these search and browse results.
Note:
Filtering rules always take precedence over boost rules. For more information about filtering and ordering search results, see
Filter and order results
.
Boost or bury
One product can be conditioned by multiple boost or bury rules, which are set in the
boostspec
class of the search service API.
A positive number indicates a boost rule, a promotion.
A negative number indicates a bury rule, which is a demotion instead of promotion.
Configuration options
Sum of boost effect
: If there's a demotion plus a promotion, Vertex AI Search for commerce adds up these values. The resulting sum is either a lowered boost or net bury effect.
Max boost rule (default
): Vertex AI Search for commerce checks whichever is the maximum value and ignores the other rules.
Multiple boost or bury rules set to one product
Multiple boost or bury rules can affect a product, with either a sum or max of the boost values determining the final score.
When several boosting rules are applied to the same product, always check if another product's score has ousted the product from the top spot. Max mode is set to default so that this problem is less likely to occur.
Assume one product gets boosts of 2, 3, and 0.5, and another product gets one boost of 0.5. Although the product only received a 0.5 boost score, when it's boosted repeatedly, it outranks the other product. Carefully check the boosting spec to make sure it's not overlapping, or it's overlapping as intended.
Overriding filters
Two types of filters that take precedence on top of boosting rules:
User-specified
: These can be things like price or brand, and appear to the end user as tiles or facets on the website.
Topicality (relevance)
: These filters only exist for search queries (not browsing). They exclude less relevant products from the search results. For example, the search
refrigerator
doesn't return microwaves or accessories, such as refrigerator handles. The filter recognizes not to boost a microwave for a refrigerator search.
Filters available in search and browse
Search
: Topicality filter plus any other user-applied filters such as on-site facets.
Browse
: Since there is no text-query, only the user-applied filters are applied. Filters are also applied to check that the product (let's say, suits) belongs to the correct product category (not sweaters, for example).
Debugging and troubleshooting
Every product is eligible for unlimited boosting, but user-applied filters eliminate products from the search response. To troubleshoot why a boosted product might not appear in search and browse results, check for:
Multiple boost rules (including bury demotions)
: Check boost mode configuration (sum or max) and determine the final score.
Relevance
: A product must be relevant for the query and pass the relevance filters. If a search query is for Nike shoes and the product title is
Air Jordans,
the words don't match, but their close semantic relationship results in a high relevance score. A product title such as
yellow jacket
has a low relevance score with a Nike search query. Similarly, if the product title is a cryptic model number that has no relationship to any word whatsoever, the relevance score will be low for any query.
Filters
: Filtering rules override any boost rule, and prevent boosted products from appearing in results. The filter is always applied atop the boost. If a product has user-applied filters, or if a product category filters for browsing, the boost won't work at all.
Boosting tutorial
This tutorial shows you some examples of product boosting.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Configure boost
This page uses the following dataset as an example. Only the fields necessary
for explanation are included.
Example dataset
Example product dataset
id
title
brands
categories
price_info.price
"nest_mini_2nd_gen"
"Nest Mini (2nd gen)"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"nest_audio"
"Nest Audio"
["Google", "Nest"]
["Nest > speakers and displays"]
99.99
"nest_hub_max"
"Nest Hub Max"
["Google", "Nest"]
["Nest > speakers and displays"]
229.00
"nest_hub"
"Nest Hub"
["Google", "Nest"]
["Nest > speakers and displays"]
88.99
"google_home_max"
"Google Home Max"
["Google", "Nest"]
["Nest > speakers and displays"]
299.00
"google_home_mini"
"Google Home Mini"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"google_pixel_5"
"Google Pixel 5"
["Google", "Pixel"]
["Pixel > phones"]
699.00
"google_pixel_4a_with_5g"
"Google Pixel 4a with 5G"
["Google", "Pixel"]
["Pixel > phones"]
499.00
"google_pixel_4a"
"Google Pixel 4a Phones"
["Google", "Pixel"]
["Pixel > phones"]
349.00
"google_pixel_stand"
"Google Pixel Stand"
["Google", "Pixel"]
["Pixel > featured accessories"]
79.00
"google_pixel_buds"
"Google Pixel Buds"
["Google", "Pixel"]
["Pixel > featured accessories"]
179.00
"google_pixel_5_case"
"Google Pixel 5 Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_5g_case"
"Google Pixel 4a (5G) Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_case"
"Google Pixel 4a Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
Example search request and response
For example, if you search for "Google speaker", then you would get
"nest_mini_2nd_gen", "nest_audio", "nest_hub_max", "nest_hub", "google_home_max"
and "google_home_mini" in no specific order.
Example search request and response
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchRequest
.
BoostSpec
;
import
com.google.cloud.retail.v2.
SearchRequest
.
BoostSpec
.
ConditionBoostSpec
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchProductsWithBoostSpec
(
String
query
,
int
pageSize
,
String
condition
,
float
boostStrength
)
throws
IOException
,
InterruptedException
{
BoostSpec
boostSpec
=
BoostSpec
.
newBuilder
()
.
addConditionBoostSpecs
(
ConditionBoostSpec
.
newBuilder
()
.
setCondition
(
condition
)
.
setBoost
(
boostStrength
)
.
build
())
.
build
();
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setBoostSpec
(
boostSpec
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
Example boost spec
Suppose that you want to prioritize the cheaper products (less than 95
dollars) and deprioritize the expensive ones (higher than 95 dollars). You can
apply a boost spec as:
JSON
{
condition_boost_specs
{
condition:
"price: IN(*, 95.0e)"
boost:
0
.5
}
condition_boost_specs
{
condition:
"price: IN(95.0e, *)"
boost:
-0.5
}
}
In the result,
"nest_mini_2nd_gen"
,
"google_home_mini"
and
"nest_hub"
might be the
first three, while
"nest_audio"
,
"nest_hub_max"
and
"google_home_max"
might be
last three. However, no specific order is predetermined, in contrast to 
ordering by price, as discussed in
Filter and order results
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/catalog.txt
About catalogs and products  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About catalogs and products
This page provides best practices for creating your catalog information and
populating your catalog data.
Overview
The catalog is a collection of product objects.
The catalog data you import into Vertex AI Search for commerce has a direct effect on the
quality of the resulting model, and therefore on the quality of search and
recommendation results. In general, the more accurate and specific
catalog information you can provide, the higher quality your model.
Your catalog should be kept up to date. You can upload catalog changes as often
as needed; ideally, every day for catalogs with a high rate of change. You can
upload (patch) existing product items; only the changed fields will be updated.
There is no charge for uploading catalog information. For more information, see
Keeping your catalog up to date
.
Note:
There is only one catalog per Google Cloud project. It is named
default_catalog
. You don't need to create the default catalog; it is there by
default.
Catalog branches
Warning:
If you use recommendations, do not use multiple catalog branches. Branch switching can negatively impact prediction
results.
Catalog branches with search
If you use search, you can use catalog branches to test new data
that you've uploaded offline before making it live on your site.
You can use up to three branches, identified as
0
,
1
, and
2
. Your live site points to
default_branch
for its catalog
data. Specify which branch is your live
default_branch
(the default is set to
branch
0
) using either
setDefaultBranch
or the Data tab in
Search for commerce console. Your site then uses the catalog data provided
by the branch that
default_branch
points to.
As an example, say
default_branch
is set to branch ID
0
, so your
site is using the catalog data that you've uploaded to that branch. You can
upload new catalog data to branch
1
and preview it. After you've confirmed
that the catalog has been uploaded correctly, you can switch to branch
1
as
the live
default_branch
.
The catalog cache can take up to 30 minutes to update after branch switching.
If you use recommendations, we recommend using only the default
branch due to the update delay during branch switching. If the data difference
between branches is large, update delay can negatively impact prediction
results.
Required product information
The following fields are required; you must provide values for them when you
create product items in your catalog. They should also correspond with the
values used in your internal product database, and should accurately reflect the
product represented, because they are included in training your models.
In some cases, other fields are also required. Refer to the complete list of all
product fields on the
Product
reference page.
All product information you provide can be used to improve the quality of
recommendations and search results. Be sure to provide as many fields as
possible.
Field
Notes
name
The full, unique resource name of the product. Required for all
Product
methods except for
import
. During
       import, the name is automatically generated and does not need to be
       manually provided.
id
The product ID used by your product database. The ID field must be
       unique across your entire catalog. The same value is used when you
       record a user event, and is also returned by the
predict
and
search
methods.
title
Product title from your product database. A UTF-8 encoded string.
     Limited to 1250 characters.
categories
Product categories. Every product must be assigned to at least one category. 
    If a product belongs to more than one category, repeat the field for each category.
    The value must be a non-empty UTF-8 encoded string with a length limit of
    5,000 characters. Always specify the full category path, for example:
["Sports & Fitness > Athletic Clothing > Shoes"]
.
Product description enrichment
Vertex AI Search for commerce uses product URLs to enrich product descriptions. Product URLs enhance catalogs by:
Enriching product data
: Vertex AI Search for commerce extracts supplemental information by crawling the product's URI, the unique resource identifier behind the exact location of each product on the web (URL). This process helps in derive additional details and signals from the linked web pages. The deeper understanding of products gained through URI crawling directly contributes to the quality of the catalog's data.
Improving search quality and relevance
: Web signals gathered from the crawled URIs are used to enhance search quality. The backend utilizes the crawled information, including how the URI was interacted with on the web, such as when your user clicks backlinks, for relevance and popularity scoring in search results.
Providing a foundation for model training
: Besides product ID, title, category hierarchy, and price, URLs are considered one of the primary fields used as inputs for model training.
Note:
To help ensure quality service and prevent degraded performance, it is strongly recommended to provide a valid URI for each product.
To maximize the benefits of product URLs, adhere to these best practices:
The linked web page must be publicly accessible and load correctly, not located behind a login or authentication wall.
Each URI should be unique and consistently point to the correct product's web page. Its content should accurately reflect the product information in the catalog. It is also recommended to maintain the same top-level domain name across all product URIs
Catalog categories
This section describes the catalog structure and how to designate it for use in taxonomy and filtering.
Catalog structure
The
categories
field in the catalog should contain the most granular category path for each product. Parent categories are not required and should not be included.
Here is an example of how to structure your catalog:
Correct
:
categories: ["Flowers, Cards, Occasion > Seasonal Items > Christmas"]
Incorrect
:
categories: ["Flowers, Cards, Occasion", "Flowers, Cards, Occasion > Seasonal Items", "Flowers, Cards, Occasion > Seasonal Items > Christmas"]
Parent categories
The parent categories for a given product should not be included in the
categories
field. Filtering for browsing should be handled using
other custom attributes
.
Category naming
Category names should be chosen carefully to avoid introducing incorrect keywords and improve performance. Using more specific and accurate terms will enhance relevance and reduce issues.
Recommended
:
Frozen Food > Frozen Fruits
Not recommended
:
Frozen Fruits & Vegetables > Frozen Fruits
Project-specific, catalog-level structure
Create a single catalog for each language. If you operate in multiple countries, you can use the same catalog to provide
search results in different countries.
Provide prices, which are determined through local inventories, in the same
currency across countries. If prices differ among countries, create a local inventory for each country. Specify its prices there.
To optimize your search results, provide each country name as the
SearchRequest.entity
and
UserEvent.entity
. Use country entities for ranking purposes
only.
Product hierarchy overview
When managing your product catalog in Vertex AI Search for commerce, understanding how attributes are handled for primary and variant products is crucial for effective search and recommendations. Product SKU designations determine catalog hierarchy.
Product designation types
There are three product designation types:
Primary
or parent items are returned in recommendation or search results and serve as logical containers or groups of similar items. Primaries can be individual (SKU-level) items and groups of similar items (SKU groups).
Variant
or child items are specific, individual versions of a SKU-group primary product. For example, if the primary product is
V-neck shirt,
variants could be
Brown V-neck shirt, size XL
and
White V-neck shirt, size S
.
Collection
items are bundles of primary products or variant products,
such as a jewelry set with a necklace, earrings, and a ring. Hierarchical
structures similar to products and variants, collections group related
primary products. Customers can't buy them directly, they're not widely used,
and they're only available in search.
Note:
The system strictly enforces primary to variant taxonomic relationships, and incorrect mapping will cause import failures. This product
type
is immutable, so changing it requires deleting and recreating the product.
Product examples
As an example, according to these product designation types, grocery items are better cataloged as primary products, each consisting of a single SKU product, such as
"bananas, fresh"
.
On the other hand, tee-shirts would be better structured hierarchically, as primaries with their corresponding set of variants. Each variant represents an individual
SKU (for each size) and each primary item represents a
group of SKUs, where each SKU is a different size for one overarching tee-shirt style. This organization by SKU structure allows the search results and recommendation panels to show a range of tee-shirt styles. It allows the shopper to drill down on a particular primary (style) to select the variant
(size) to purchase.
Collections group related products that a customer might buy. To accurately
represent them in the reranking model, Vertex AI Search for commerce has a logic that
credits them with purchases. For example: A shopper clicks on products in a
bedsheets set, then adds to cart or purchases a primary product in that
collection. The collection is credited with that purchase, and the model
accurately represents the popularity and value of collections.
There is also a variant-only catalog type, which is now deprecated. This catalog
type can only be used with recommendations. For the variant-only
catalog, the
ingestionProductType
is set to
variant
during import. A primary
is inferred for each variant, based on a primary product ID specified for each
variant.
Set up your product catalog
When planning your product catalog, you need to decide whether it contains products designated as only primaries, primaries and variants, or a mixture of the two arrangements. Think of it in terms of your products' SKU structure. Your products can be primary items, which may or may not have variants.
Based on how your product SKUs are designated, consider your options for setting up your product catalog:
You want your SKU to be shown as an individual search result or recommendation
: SKU=primary
Your SKU should be part of a group of similar SKUs
: SKU=variant, group of SKUs=primary
A mixture of both combinations
: SKU=primary, SKU=variant, group of SKUs=primary
If your product detail page shows an option, size, or color selector, these options are typically uploaded as variants into your product catalog. Consider whether or not you want different types of the same product with different attributes such as size and color to appear as a single search result or separate ones. For example, for a book you want to decide if you want a hard cover SKU and a soft cover SKU of the same book to appear as separate search results (SKU = primary), or as one (SKU = variant, group of SKUs = primary).
When setting up your product catalog, keep in mind that recommendation and search results only return primary items.
Minimal primary products
If you determine that your catalog should have both primaries and variants, that
is, SKU groups and SKUs, but you only have SKUs now, you need to create
primaries for the SKU groups. These primaries are sometimes called virtual
primaries or fake primaries.
These primaries only need to contain minimal information:
id
,
title
, and
categories
.
If
type
is not specified, the product type defaults to primary. If you are
importing, you don't need to specify
name
. For more information, see
the preceding section,
Required product information
.
Catalog import
If your catalog is in
Cloud Storage or BigQuery or some other storage, then
do a bulk data import.
For detailed information about how to upload a catalog, see
Import catalog
information
.
Product inventory
Product inventory encompasses:
Price, both the current and original prices
Availability, such as in stock, out-of-stock, back ordered, and pre-ordered
Quantity available
Fulfillment information such as pickup-in-store, ship-to-store, and next-day-delivery
There are two levels of inventory: product-level and local.
Product-level inventory
For retailers who only sell online, inventory is specified at the product level.
Price, availability, and other inventory data is set for each product in the
catalog.
For more information about product-level inventory, including how to maintain
inventory data, see
Update inventory for
Vertex AI Search for commerce
.
Local inventory
Retailers who have brick-and-mortar stores and an online store need to keep
inventory information on a per-store basis. They use local inventory to do this.
There are two product fields that can be used to store local inventory. Both
fields are lists of locations (place IDs) with associated inventory information:
Product.fulfillmentInfo
.
Pickup and shipping methods at
each store location
Product.localInventories
.
Price information, product
attributes, and pickup and shipping methods at each store location
You can use either or both fields for your store-level information.
For more information about local inventories, see
Update local inventory for
Vertex AI Search for commerce
.
Primary-variant-inventory structure
The primary-variant-inventory data structure is composed of primary, variant, and local inventory products:
Primary products
: Primary product data is stored without prices.
Variant products (with the lowest price across the country)
: For example, the variant for the primary (color, size) should have the lowest price across country. Variant price data is rolled up to the primary product data, the primary price in turn being used for ranking purposes. Location-specific prices are ignored.
Local inventory (region or store-specific pricing)
: Use the price information from the local inventory in reranking at serving time
Primary product attributes
: Primary products must only include attributes common to all their associated variants.
Catalog data quality metrics
The
Data quality
page in the
Search for commerce console assesses if you need to update
catalog data to improve the quality of search results and unlock
search performance tiers.
The following table describes the quality metrics that Vertex AI Search for commerce uses to
help you evaluate your product data. For details about how to view data quality
metrics and search performance tiers in the Search for commerce console,
see
Unlock search performance tiers
.
Catalog quality metric
Quality rule
Notes
URI is
present and accessible
Product has a valid
Product.uri
. The URI needs to be accessible and match your domain.
Search uses web signals crawled using this URI to improve search quality.
Meets time conformance
Product.availableTime
is before current time, and
Product.expireTime
is after current time.
Only products that meet the time conformance are available for search.
Searchable attribute is present
Product has at least one
attribute
set to searchable.
Custom attributes that are marked searchable can be searched by text queries.
Description is present
Product has non-empty
Product.description
.
A comprehensive description helps to improve search quality.
Title consists of at least two words
Product.title
consists of at least two words.
A comprehensive title helps to improve search quality.
Has variant with image
The
variant
product has at least one
Product.image
. You may ignore this metric if all your products are at
primary
level.
This metric is for informational purposes and does not impact search quality.
Has variant with price info
The
variant
product has
Product.priceInfo
set. You may ignore this metric if all your products are at
primary
level.
This metric is for informational purposes and does not impact search quality.
Product schema
When importing a catalog from BigQuery, use the following
Vertex AI Search for commerce product schema to create a BigQuery table
with the correct format and load it with your catalog data. Then,
import the catalog
.
Vertex AI Search for commerce product schema
BigQuery
[
{
"name"
:
"name"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"type"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"primaryProductId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"collectionMemberIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"gtin"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"categories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"title"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"brands"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"description"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"languageCode"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"attributes"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"key"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"value"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"text"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"numbers"
,
"type"
:
"FLOAT"
,
"mode"
:
"REPEATED"
}
]
}
]
},
{
"name"
:
"tags"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"priceInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"price"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"originalPrice"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"priceEffectiveTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"priceExpireTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"rating"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"ratingCount"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"averageRating"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ratingHistogram"
,
"type"
:
"INTEGER"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"expireTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ttl"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"seconds"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"nanos"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"availableTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"availability"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"availableQuantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"fulfillmentInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"type"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"placeIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"images"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"height"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"width"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"audience"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"genders"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"ageGroups"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"colorInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"colorFamilies"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"colors"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"sizes"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"materials"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"patterns"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"conditions"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"publishTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"promotions"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"promotionId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
}
]
Note:
For reranking on inventory prices, use
placeId
in the search request.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/completion-overview.txt
Autocomplete for search  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Autocomplete for search
This page introduces the autocomplete feature and how to use it.
Search provides autocomplete for driving search
box type-ahead suggestions.
Autocomplete
is a feature for predicting the rest of a
query a user is entering, which can improve the user search experience and
accelerate the shopping process before checkout. It can also improve the search
response quality and thus create higher revenue by providing well-formatted
queries.
Overview
When an end user begins typing a search term on your site,
search can provide a list of suggestions that the user may want.
For example,
shoes
and
shirts
might be suggested when the user enters
sh
.
Data source
You can choose one of the following data sources for your suggestion
predictions:
A BigQuery dataset that you upload.
A dataset that is generated from user events and other metadata using machine
learning.
Uploaded dataset
A BigQuery suggestion table you upload as a dataset, which is
used to suggest queries. For how to upload a dataset, see
Importing autocomplete data
.
Auto-learning dataset
A machine learning-powered suggestion dataset generated by
search based on users' search events.
To enable auto-learning:
Cloud console
Go to the Controls page
Go to the
Autocomplete Controls
tab.
Click
Edit settings
.
Turn on
Auto learning
.
Click
Save settings
.
Auto-learning can take 1-2 days to update.
cURL
curl -X PATCH -H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/completionConfig?update_mask.paths=auto_learning"  --data "{auto_learning: true}"
Auto-learning dataset prerequisite
Auto-learning generates suggestions from search type
user events
(
eventType = "search"
). The generation uses the past 180 days of user events. 
It requires a good quality and quantity of imported user events.
Auto-learning
filters out rare suggestions
, so if the
search type user event quantity is too small (less than 20,000), many suggestion
candidates may be filtered out. In this scenario, you may want to first test
autocomplete function with a more frequent search query.
Auto-learning dataset release schedule
The auto-learning dataset is generated daily, then pushed to indexing and
release. The full cycle takes around two days.
Auto-learning features
Search applies machine learning techniques to clean up and
format queries and suggestion data for
auto-learning dataset
only.
Feature
Description
Example
Remove 0-result searches
Remove queries that have zero search results.
For grocery retailer,
Gucci handbags
has 0 search results, so it is removed.
Correct typos
Correct word spellings that are typos.
Also clean real-time input queries before matching.
Milc
→
Milk
Add allowlist queries
Queries you explicitly allow are added.
Check
More information
section
Remove blocklist queries
Queries you explicitly block are removed.
Check
More information
section
Remove unsafe terms
Uses Google safe search.
Remove inappropriate queries.
Porn, racy, vulgar, or violent content
Remove very rare terms
AI system adjusts cutoff depending on query statistics.
If
     terms are unusually rare, they're removed.
74x39x9 inches 2 layer twin air mattress with 120V handheld pump.
Deduplicate terms
Based on AI-driven semantic understanding
For near-identical
     terms, either term will match, but only the more popular one will be suggested.
Shoes for women, womens shoes,
and
womans shoes
are deduplicated,
     so only one will be suggested.
Get completion suggestions
Use the
completeQuery
API to fetch the suggestions.
Example:
cURL
curl -H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog:completeQuery?query=sho&dataset=user-data&deviceType=DESKTOP&maxSuggestions=5"
Autocomplete options and controls
This section explains what options and controls are available for autocomplete.
See an overview in the following table and more details.
Control
Details
Location
Denylist
Manually removes queries from the suggestion data.
API Request: CompletionData:import
.
   For more information, see
Import autocomplete data
.
Allowlist
Manually adds queries to the suggestion data.
API Request: CompletionData:import
(also see
Import Autocomplete Data
)
Minimum length to trigger autocomplete
Controls number of characters before autocomplete is triggered.
Google Cloud console > Controls
Matching order
Matching order determines how user query and suggestions are matched.
Google Cloud console > Controls
Suggestion count
This is the number of suggestions that will be returned from autocomplete.
Google Cloud console > Controls
or
API Request: completeQuery.maxSuggestions
Device type
When device types are specified, the suggestions are generated
     based on the popularity of the given device types.
Not specifying this
     returns suggestions based on combined popularity from all device types.
API Request: completeQuery.deviceType
Suggestion data source
If you have both auto-generated and uploaded data sources,
               you can choose which one to use at query time.
API Request: completeQuery.dataset
Language
You can specify which language or languages suggestions are in.
API Request: completeQuery.languageCodes[]
Allowlist (do-not-remove list)
Search does post processing, such as spell correction,
on autocomplete suggestion data. You can create an allowlist of terms that
search skips when post processing.
Allowed terms are never filtered out from suggestions. The allowlist works
for both
uploaded datasets
and
auto-learning dataset
.
Examples: there are some intentionally misspelled brand names,
such as "froot loops" instead of "fruit" or "foot".
See detailed upload instruction in
import completion data
.
For data import, you can use
Google Cloud console >
Controls
>
Autocomplete Controls
>
Do Not Remove list
or use
CompletionData:import
in the API.
Changes take effect in around 2 days.
Denylist
The denylist only works for
auto-learning datasets
.
The denylist does not work for
uploaded datasets
.
The terms in a denylist never appear in suggestions.
To import a denylist, you can use
Google Cloud console >
Controls
>
Autocomplete Controls
>
Deny list
or use API
CompletionData:import
. For
detailed instructions on how to import a denylist, see
import completion data
.
Changes take effect in around 2 days.
Minimum length to trigger
You can set the number of characters required before autocomplete queries
will return results. The setting can be found on
Google Cloud console >
Controls
>
Autocomplete Controls
>
Minimum length to trigger
.
Changes take effect immediately.
Matching order
This determines how to match suggestions with user input terms.
When set to
Suggestion starts with the term
, auto-complete matches the user
input term as an exact prefix to suggestions. For example, the user input "sh"
matches the suggestions "shoes" and "shirts", but not the suggestion "red shoes".
When set to
Suggestion can start from anywhere in the term
, auto-complete
tokenizes the user input term into words and matches it to the words in
suggestions, regardless of word order. For example, the user input term "red
sh" matches the suggestions "shirts red", "red shoes", and "kid red shoes".
However, the input term "hoes" is not matched with these suggestions, because
none of words in the suggestions begin with "hoes".
The setting can be found on
Google Cloud console >
Controls
>
Autocomplete Controls
>
Matching order
.
Changes take effect immediately.
Suggestion count
This is the number of suggestions that will be returned from autocomplete
queries and it cannot exceed 20. The setting can be found on
Google Cloud console >
Controls
>
Autocomplete Controls
>
Suggestion Count
or can be set in
completeQuery
.
Changes take effect immediately.
Device type
Search autocomplete supports different device types, such as
mobile
and
desktop
. You can upload or get different suggestions based on
device types. If
deviceType
is not specified in
completeQuery
, the suggestion will be across all device types.
For an auto-learning dataset based on search user events, set
user_agent
in
UserEvent.user_info
to support different device types.
See
user agent
in wiki.
Advanced features
This section describes the advanced autocomplete features available with
search. For example, you can supplement query autocomplete
suggestions with other suggestions, such as brands and categories.
These advanced features are available only for auto-learning datasets.
Suggestion FeatureSet
We provide an additional FeatureSet for each query suggestion term to allow
customers to show advanced functions on their websites.
The FeatureSet appears in the response as a key value map.
Vertex AI Search for commerce returns up to five popular categories and brands related to
each query suggestion in the
completeQuery.completionResults.attributes
API response. FeatureSet suggestions don't have to match the query strings
input by the end user.
You can use the FeatureSet in the response to enrich search suggestions. For example:
Aggregate and create
Popular Brands
and
Popular Categories
sections that appear below the search suggestion list.
Display the most popular brand or category next to search suggestion terms.
After making changes to the catalog, such as changing categories for products,
expect to wait two weeks to 30 days until the FeatureSet suggestions reflect the
product catalog changes. This wait time is because auto-learning trains on the
past 30 days of search event data.
Attribute suggestions
Search provides attribute suggestions that match user input
strings. Supported attribute suggestions types are brands and categories.
Attribute suggestions differ from a suggestion FeatureSet. Attribute suggestions
are lists of suggested product attributes (like brands and categories), similar
to how query suggestions are lists of suggested queries. Attribute suggestions 
can be used independently from query suggestions. A suggestion FeatureSet is 
metadata for a query suggestion, and so is dependent on query suggestions.
Attribute suggestions can be used to auto-complete brands or categories that
an end user is typing, in separate sections below the search suggestion list.
Suggestion facet with product counts (Experimental)
This is an experimental feature for limited customers. To use it, contact the
support team.
When the suggestion facet with product count feature is enabled, the returned
completeQuery.completionResults
gives a list of autocomplete suggestions as normal but
also product counts for each suggestion with the total count and product count by facet (like
color
,
category
).
For example, if the search query is "shoe", the returned Autocomplete suggestions might be:
womens shoes
mens shoes
Furthermore, if the facet key of interest is
color
, a product count and product
count by color is also returned with each Autocomplete suggestion:
womens shoes (32)
black (10)
taupe (16)
white (10)
mens shoes (43)
black (10)
brown (5)
green (17)
As a retailer, you don't need to present the product count to the shopper,
but you might decide to order the list of suggestions based on product count
instead of the order returned in
completeQuery.completionResults
.
For example, you might want to encourage shoppers to look at green shoes for men by having
green shoes appear at the top of the suggestion box even though they are not the most popular
item.
For example:
{
  "completion_results": [{ 
    "suggestion": "womens shoes"
    "facets": [ 
      {
        "key": "color"
        "values": [ 
          {
            "value": "black"
            "count": 10
          }
          {
            "value": "taupe"
            "count": 16
          }
          {
            "value": "white"
            "count": 10
          }
        ]
      }
    ]
    "total_product_count": 32
  },
  (...)
  ],
}
The facet count information appears as a list of
Facets
in
completeQuery.completionResults.facets
for each suggested search query. Each facet has a
FacetValues
list that contains the
product count per facet value. The total product count for each suggested search
query is returned in
completeQuery.completionResults.totalProductCount
.
To turn on and use suggestion facets with product counts, follow these steps:
Contact the support team and ask them to turn on the feature,
Suggestion facet with product counts
. Specify which
FacetKeys
you want product counts for. Only
textual_fields
facets are allowed.
For at least 7 days, make sure that when using the
search
API, include the facet key in
FacetSpecs
include the facet key in
search.searchRequest.facetSpecs
.
This wait time is because facet information is calculated using the past week of
search histories data.
After the feature has been turned on for you, the returned suggestions of the
completeQuery
API contain the product counts by facet and by suggestion.
Suggestion filtered by entity
Entities allow you to filter autocomplete search suggestions. An entity might be
a website for a different brand or region. You want autocomplete to best reflect
the behavior of the users shopping that particular brand or regional website.
For more information about entities, see
Entities
.
Notice that entity filtering will only apply to
completion_results
(relevant to
UserEvent
). This filter won't apply to
attribute_results
(relevant to
Product
). So regardless of the value of
entity
, the
attribute_results
is the same.
To include entities in autocomplete suggestions:
Include the
entity
field in your search user events
(
eventType = "search"
). For information, see the complete object example
for the
Search
user event.
Set the
entity
field in your
CompleteQuery
API request
to get suggestions for only that entity.
The entity string in the user events and the API requests must be an exact
match. Otherwise, autocomplete returns empty suggestions.
Make sure the entity (whether in search user events or
AutoComplete requests) has at most 256 characters. A longer one
is truncated to 256 characters when the events or the requests are
processed, risking a mismatch.
Typically, it takes 30-90 days of user event data before the entity feature
can return optimal autocomplete suggestions.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/configs.txt
About serving configs  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About serving configs
This page describes serving configs. A serving config is a serving
entity that associates a model or a set of controls that are used to generate
your recommendation or search results.
Relationship with models and controls
When you
create a serving config
, you select a model
(for recommendations) or controls (for search) to
attach. Serving configs are invoked by your site when surfacing recommendations
or search results. At serving time, the serving config's associated model or
controls are referenced to determine what the recommendations or search results
generate.
Models
A recommendations serving config can have a single model
associated with it. However, any model can be associated with multiple serving
configurations, enabling you to deploy the same model on different pages using
different serving configs.
Serving controls
Search serving configs have a multi-to-multi relationship with
serving controls. You can add multiple serving controls to a serving config, and
a single serving control can be associated with multiple serving configs.
You can create serving controls and then add or swap them into a live
search serving config.
API resource and permissions
A serving config is passed into the API using the
placements
resource:
Recommendations uses the URL
projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/placements/
SERVING_CONFIG_ID
:predict
.
Search uses the URL
projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/placements/
SERVING_CONFIG_ID
:search
.
The permissions used on these resources are the
placements.search
and
placements.predict
permissions.
Support for placements in Vertex AI Search for commerce
Serving configurations are available as of Recommendations AI v2 and
  Retail Search v2alpha.
The
servingConfig
resource is available in the API versions
  v2beta and v2alpha. You can use this resource to create, view, edit, and remove
  serving configurations.
If you have existing placements, or create new placements, serving
  configurations associated with each placement are automatically created.
  Creating a serving configuration does not create a corresponding placement.
Deleting a serving configuration deletes its corresponding placement, and deleting a
  placement deletes its corresponding serving configuration.
Serving configurations allow you to edit diversity and price reranking options and have them take
  effect in near real-time. With placements, diversity and pricing settings can only be changed from
  the recommendation model that the placement points to.
Placements are still supported, but using serving configurations instead is recommended. If a random
serving_config_id
is placed as part of the search request, search will default to essentially an empty or non-configured serving control, allowing Vertex AI Search for commerce to still work with default search capability.
Recommendations options for serving configs
The following options allow you to change the behavior of a
recommendations serving config.
These options were previously available when creating models; they are now
associated with serving configs instead.
Price reranking
Price reranking causes recommended catalog items with a similar recommendation
probability to be ordered by price, with the highest-priced items first.
Price reranking is disabled by default.
Enabling price reranking helps balance conversion rates and average order
values. Because relevance is also used to order the items returned, enabling
price reranking is not the same as sorting by price.
This option can be edited after creating a serving config.
Result diversification
If you want to ensure that results returned from a single prediction request are
more diversified rather than looking similar, you can enable diversification.
Generally, diversification reduces the likelihood that similar products are
shown in a recommendation panel, at the risk of removing some good
recommendations. Diversification settings can be edited after creating a serving
configuration. It is disabled by default.
Two types of diversification are available: rule-based diversity and data-driven
diversity.
Note:
Boost controls and diversity (rule-based or data-driven) are not compatible with each other. Only specify one of these settings at a time.
Rule-based diversity
Rule-based diversity relies on categories of your product catalog. Use
rule-based diversity to recommend products from a variety of categories.
Diversification is configured by level, with higher levels of diversification
causing fewer items to be displayed per category. This diversification type
works best if your catalog provides high-quality product categories.
Diversification level
Max items per category
None
Unlimited
Low
3
Medium
2
High
1
Auto
Depends on catalog
Data-driven diversity
Use data-driven diversity to produce recommendations results that balance
relevance and diversity. Data-driven diversity learns from product catalog
metadata, such as titles or categories. Instead of relying on the title or
category words, data-driven diversity captures semantic similarity to produce
better-performing diversification.
Diversification level
Max similar items
None
Unlimited
Low
3
Medium
2
High
1
Auto
Depends on catalog
Category matching
If the serving config includes a Similar Items model for
recommendations, you can enable category matching. When category
matching is used, the only product results returned are those that share at
least one category with the context product.
If your categories have deeply nested hierarchies, they are
truncated using heuristics to improve the possibility of a match. For
example, if the context product's categories are
a > b > c > d > e > f
, the
returned results are those whose categories are
a > b > c
.
Category matching can be used in combination with other filtering options, such
as price, availability, and filter tags. For example, if you use the filter tag
fall_Sale
and have category match enabled, the returned results are those that
have both the required tag and a category match.
This option can be edited after creating a serving config. By default,
category matching is disabled.
Dynamic faceting search option for serving configs
You can turn on dynamic faceting when you create or edit a serving
configuration.
When dynamic faceting is enabled for a serving config,
search can automatically use attributes as dynamic facets in
search results for this configuration, based on past user behavior such as facet
clicks and views. Whether a given attribute can be used as a facet is by default
defined by the product-level
attribute
configuration.
Dynamic faceting settings in the API can be overwritten
by site-wide attribute controls in the Search for commerce console. See
Managing site-wide controls
.
Note that dynamic facets can be created based just on accurate product catalog data.
However, for the feature to work optimally for your site, the facet models need
to learn from activity on your site. For this, you need to set query, category
and filter fields in your
search
event
uploads accurately.
Next steps
Request predictions
from your new placement.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/console-migration.txt
Implement Vertex AI Search for commerce  |  Google Cloud Documentation
Skip to main content
Technology areas
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
/
Console
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Sign in
Vertex AI Search for commerce
Start free
Guides
Reference
Support
Resources
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Console
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Implement Vertex AI Search for commerce
Stay organized with collections
Save and categorize content based on your preferences.
You can implement Vertex AI Search for commerce for your ecommerce application.
When you use recommendations or search, you
ingest user event and catalog data and to
serve predictions or search results on your site.
The same data is used for both
recommendations and search, so if you use both,
you don't need to ingest the same data twice.
Tip:
See the
User event requirements and best practices
for user event
data that recommendations and search use.
If you use recommendations models,
User event data requirements
lists additional requirements
depending on your model type and optimization objective. These requirements help
Vertex AI Search for commerce generate quality results.
The average integration time is in the order of
weeks. Note that for search, the actual duration depends
heavily on the quality and quantity of data to ingest.
Warning:
Never cache personalized results from an end user, and never return personalized
results to a different end user.
Commerce integration overview
Migrate in four phases
Migrating your search engine is a structured, four-phased approach that helps to ensure that every aspect of the migration is addressed to minimize risks and maximize your investment.
Manage the expectations of your merchandising teams and sellers by doing the following:
Keep merchant teams informed
: Proactively communicate the changes that are coming and why the company is moving to an AI-first approach.
Educate teams on the new paradigm
: Explain that the system is based on user behavior and intent detection, which leads to a more dynamic, personalized, and ultimately more profitable ranking. The search results will look different.
Set clear guidelines for business rules
: Emphasize that business rules can be applied only for specific, data-backed business reasons, such as contractual obligations or a clear revenue-driving strategy. The goal is to let the AI do its job.
A/B test new rules
: If a new rule is proposed post-migration, the most data driven way to validate its effectiveness is to run another A/B test, one group with the rule, one group without the rule. Let the data decide whether the rule is promoted to production.
By diligently following this four-phased approach, a typical migration to A/B testing can be achieved in about two to three months, depending on the current search system complexity and speed of execution. This methodology has been designed and proven across numerous customer adoptions.
Note:
Attempting to sprint through or skip steps can cause rework and delays.
Terms of Service
Product usage is under Google Cloud's
Terms and Conditions
or relevant
offline variant. The
Google Cloud Privacy Notice
explains how we collect and process your personal information relating to the
use of Google Cloud and other Google Cloud services.
For quality assurance, a small sample set of search queries and search results
from the logs, which include customer data, are sent for
human rating to third-party vendors
disclosed as Third-Party
Subprocessors
for search.
Additional tests using search queries and search results from Google Search logs
that are publicly collected datasets are sent for human rating to different
third-party vendors for quality assurance. The Google Search logs are
not categorized as customer data.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Products and pricing
See all products
Google Cloud pricing
Google Cloud Marketplace
Contact sales
Support
Google Cloud Community
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Code samples
Cloud Architecture Center
Training and Certification
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-commerce-dev-guide.txt
Conversational Commerce agent developer's guide  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational Commerce agent developer's guide
This guide details how to integrate with the Conversational API to provide dynamic, AI-powered chat experiences for your customers. By understanding different query types and leveraging the API's responses, you can deliver relevant product searches, answer your customer inquiries, and guide your end-users through their shopping journey.
The
conversationalFilteringMode
in the Conversational API makes the differences clear between Conversational Commerce agent and conversational product filtering.
Setup
The Conversational API supports the Conversational Commerce agent feature:
gRPC
:
conversationalSearchService
REST
:
conversationalSearch
The Conversational API enables a chat experience where your users send queries and the system returns a text response, classified query types, and potential refined search options.
This API operates as a streaming service, allowing for early detection of query intent. Subsequent interactions in the conversation require attaching a
conversation_id
.
For returning search results, the legacy Retail API must be called in parallel to the Conversational API.
Send a query from the end-user
This section describes how to initiate a Conversational Commerce agent experience. For example, your user might enter
Help me plan a party
in the search field.
Send a request to Vertex AI Search for commerce
There are two different API endpoints:
The
Conversational API
must be used to fetch the conversational experience.
The core
Search API
must be used to fetch search results.
Endpoint 1: Conversational API request
You should create a
Conversational Commerce agent request
by setting your user's input as the
query
.
The request should be sent as an HTTP POST request to the
projects/*/locations/*/catalogs/*/placements/*:conversationalSearch
endpoint.
HTTP method and endpoint
POST
h
tt
ps
:
//retail.googleapis.com/v2alpha/{placement=projects/*/locations/*/catalogs/*/placements/*}:conversationalSearch
Conversational API request:
Initial query
{
"query"
:
"Help me plan a party"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"placement"
:
"projects/799252947591/locations/global/catalogs/default_catalog/placements/default_search"
,
"visitorId"
:
"your_visitor_id"
,
"conversationId"
:
""
,
// Leave empty for the first query
"searchParams"
:
{
// IMPORTANT: These search parameters should mirror the configuration
// of your core Search API calls to ensure consistency between LLM answers and search results.
"filter"
:
"categories:(\"Party Supplies\" OR \"Decorations\" OR \"Food & Drink\")"
},
"userInfo"
:
{
// Optional: User information for enhanced personalization
// Example: "userId": "user123", "userAgent": "Chrome/120.0"
},
"conversationalFilteringSpec"
:
{
// Optional: Controls conversational filtering behavior. Defaults to DISABLED if unset.
// "conversational_filtering_mode": "DISABLED" - Otherwise you can also explicitly set to disabled.
}
placement
: The resource name of the placement (such as
projects/your-project-id/locations/global/catalogs/default_catalog/placements/default_branch
). This is a path parameter and
required
.
query
: The raw search query from your user. This is
required
.
branch
: The branch resource name, such as
projects/P/locations/L/catalogs/C/branches/B
. If unset,
default_branch
is used. This is
required
.
visitorId
: A unique identifier for tracking visitors. This is
required
.
conversationId
: A unique ID for tracking conversation sessions. For the
initial
request in a new conversation, this field should be empty. For subsequent requests within the same conversation, it must be set to the
conversation_id
received in the previous
ConversationalSearchResponse
.
searchParams
: (Optional) Standard core Search parameters, such as
filter
,
canonicalFilter
,
sortBy
, and
boostSpec
.
It is crucial that these parameters mirror the configuration used in your core Search API calls to ensure consistency between LLM answers and any product search results displayed.
userInfo
: (Optional) User information for enhanced personalization. Can include
userId
,
user_agent
,
direct_user_request
(boolean).
conversationalFilteringSpec
: (Optional) Specifies the conversational filtering mode. If unset, it defaults to DISABLED.
mode
: Integrate the Conversational API using one of these three
modes
to control conversational product filtering:
DISABLED
: In this mode, the client only implements Conversational Commerce agent search.
This is the preferred mode for this implementation guide on Conversational Commerce agent search.
Sample API request
placement
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
branch
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
query
:
"show me some monster energy drinks"
visitor_id
:
"test"
conversational_filtering_spec
{
conversational_filtering_mode
:
DISABLED
}
Sample API response
user_query_types
:
"SIMPLE_PRODUCT_SEARCH"
conversation_id
:
"479fd093-c701-4899-bcc3-9e711233bdf9"
refined_search
{
query
:
"monster energy drinks"
}
ENABLED
: In this mode, the
    client implements all conversational capabilities, which includes
    Conversational Commerce agent search and conversational product filtering.
Refer to the additional guide on
how to
    integrate both conversational products
.
Sample API request
placement
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
branch
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
query
:
"show me some monster energy drinks"
visitor_id
:
"test"
conversational_filtering_spec
{
conversational_filtering_mode
:
ENABLED
}
Sample API response
user_query_types
:
"SIMPLE_PRODUCT_SEARCH"
conversation_id
:
"479fd093-c701-4899-bcc3-9e711233bdf9"
refined_search
{
query
:
"monster energy drinks"
}
conversational_filtering_result
:
{
followup_question
{
followup_question
:
"What is the size?"
suggested_answers
{
product_attribute_value
{
name
:
"size"
,
value
:
"12oz"
}
}
}
}
CONVERSATIONAL_FILTER_ONLY
: If chosen, the client
only
implements Conversational product filtering. With this mode selected, the user experiences only conversational product filtering without generating an LLM answer, query classification, or suggested search queries.
Refer to the
Conversational product filter developer's guide
for more information.
Endpoint 2: Core Search API request
There are two primary approaches for displaying search results in your web interface.
Option 1: Always show search results
If your user experience design dictates that search results should always be displayed regardless of the conversational output, such as in a dedicated search results area alongside the chat, then send your user's original query to the core Product Search API with your call to the Conversational API. This helps ensure that product listings are immediately available.
Option 2: Show search results based on conversational output
If your user experience design is more dynamic and you only want to display search results depending on the Conversational API's response, such as only for
SIMPLE_PRODUCT_SEARCH
queries or whenever
refined_search
suggestions are provided, wait for the Conversational API's response before sending any queries to the core Product Search API. If there is a response, use the
refined_search
query provided to fetch product results.
Regardless of the user interface option you choose, when you need to fetch actual product results, you can make a call to the Retail API. For more information, see
Understand query types and retailer actions
.
HTTP method and endpoint
POST
h
tt
ps
:
//retail.googleapis.com/v2beta/{placement=projects/*/locations/*/catalogs/*/servingConfigs/*}:search
Core product Search API request:
Initial query
{
"placement"
:
"projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/servingConfigs/default_search"
,
// Or if using legacy placements:
// "placement": "projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/placements/default_search",
"query"
:
"Help me plan a party"
,
// This is the original user query
"visitorId"
:
"your_visitor_id"
,
"branch"
:
"projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/branches/default_branch"
,
"pageSize"
:
20
,
// Optional: Number of results to return per page
"filter"
:
"categories:(\"Party Supplies\" OR \"Decorations\" OR \"Food & Drink\")"
,
// Mirroring the filter from the Conversational Commerce API
"orderBy"
:
"relevance DESC"
,
// Optional
"userInfo"
:
{
// Optional: User information for enhanced personalization, should mirror Conversational Commerce API
// "userId": "user123", "userAgent": "Chrome/120.0"
},
"searchMode"
:
"PRODUCT_SEARCH"
// Typically for product searches
}
placement
(Required)
: The resource name of the Retail Search serving config or legacy placement. Example:
projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/servingConfigs/default_search
.
query
: Required. The search query. This can be your user's raw input such as
Help me plan a party
or a more optimized
refinedSearch.query
(such as
party planning supplies, decorations)
obtained from the Conversational Commerce API response.
visitorId
: Required. A unique identifier for tracking visitors. This should be consistent with the
visitorId
sent to the Conversational Commerce API for the same end user.
branch
(Required)
: The branch resource name, such as
projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/branches/default_branch
.
pageSize
(Optional)
: The maximum number of products to return.
filter
(Optional)
: Used to filter search results. This is where you would apply any filters that mirror what you send in `searchParams` to the Conversational Commerce API for consistency.
orderBy
(Optional)
: Specifies the order in which products are returned (such as by relevance or by price).
userInfo
(Optional)
: User information for personalization, should be consistent with the Conversational Commerce API call.
searchMode
(Optional)
: Defines the search behavior.
PRODUCT_SEARCH
is common for general product queries.
Understand the response
This code sample demonstrates a response from the Conversational commerce API.
The API response (
ConversationalSearchResponse
) includes
query_types
,
conversational_text_response
(if applicable),
refined_search
options, and potentially a
followup_question
or
conversational_filtering_result
. The
conversation_id
is essential for continuing the session.
Response from Vertex AI Search for commerce
This code sample demonstrates a Conversational API response:
Initial response
{
"userQueryTypes"
:
[
"INTENT_REFINEMENT"
],
"conversationalTextResponse"
:
"To plan a party, you'll need decorations, snacks, party supplies, drinks, and a cake. You can find a wide variety of decorations, snacks, and drinks. For party supplies, you can find everything from plates and cups to balloons and streamers. And for cake, you can choose from a variety of flavors and sizes."
,
"followupQuestion"
:
{
"followupQuestion"
:
"What kind of party are you planning?"
},
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"refinedSearch"
:
[
{
"query"
:
"Decorations"
},
{
"query"
:
"Snacks"
},
{
"query"
:
"Party Supplies"
},
{
"query"
:
"Drinks"
},
{
"query"
:
"Cake"
}
],
"state"
:
"SUCCEEDED"
}
What retailers should do with the response (General)
Render these fields from the response:
user_query_types
: This field provides the classification(s) of the your user's intent. For detailed actions based on these types, refer to
Understand query types and retailer actions
.
conversation_id
: You can store this unique ID in your browser session storage or similar client-side storage to maintain the conversational session with the server. This is crucial for distinguishing between multiple ongoing conversations for a single shopper. Your model retains context for a given
conversation_id
. Sending a new
conversation_id
starts a new session. It's recommended to define your session duration, such as 30 minutes of inactivity.
refined_search
: This is a list of proposed refined search queries used to fetch the relevant search results. For
SIMPLE_PRODUCT_SEARCH
, it is always a single query. For other LLM-answer seeking queries, it is one or more. The
refined_search
queries can be used for calls to the core Search API (
SearchService.Search
) or can also be displayed to your  user as suggestions.
conversational_text_response
: Display this text to your user as the primary AI-generated response to their query.
followup_question
: Optional. The
followup_question
is displayed.
state
: This field indicates the state of the response generation (
"STREAMING"
or
"SUCCEEDED"
). You can use this for user experience feedback, such as showing a loading indicator until
"SUCCEEDED"
. More details on this in the next section.
Understand the streaming API
The Conversational commerce API operates as a streaming API. This means your user receives parts of the response in multiple chunks rather than a single, complete payload.
The first chunk of the response includes the
query_types
and the
refined_search
queries, and its
state
is indicated as
STREAMING
. This early detection of intent and immediate availability of search refinements allows your model to make prompt decisions on how to handle your user's query and how to manage your user's experience concerning latency from LLM responses:
For query types that don't expect a conversational text response, such as
SIMPLE_PRODUCT_SEARCH
,
RETAIL_IRRELEVANT
,
BLOCKLISTED
,
QUERY_TYPE_UNSPECIFIED
,
ORDER_SUPPORT
,
DEALS_AND_COUPONS
,
STORE_RELEVANT
:
Because
query_types
are in the first chunk, your system knows immediately that no LLM answer is coming. You can proceed with your predefined handling for these types, such as display a static message, reroute to support, without waiting for further conversational output.
Specifically for
SIMPLE_PRODUCT_SEARCH
, your system can immediately make a direct call to the core Search API using the
refined_search
query received in the first chunk. This helps to ensure search results are displayed with minimal delay, meeting typical search experience SLAs.
For query types that
do
expect a conversational text response, such as
INTENT_REFINEMENT
,
PRODUCT_DETAILS
,
PRODUCT_COMPARISON
,
BEST_PRODUCT
:
You receive the
query_types
and
refined_search
queries in the initial chunk. You can immediately initiate a parallel call to the core Search API using these
refined_search
queries to start loading product results.
Subsequent chunks stream in, containing different sections of the conversational text response. During this time, the
state
remains
"STREAMING"
.
Finally, the last chunk includes the full, complete conversational text response, and its
state
changes to
"COMPLETED"
.
This streaming approach allows for a fluid end-user experience where search results can begin to load while the AI summary is being generated. You can choose to display a loading indicator for the conversational answer or present the conversational answer after it fully streams in.
Understand query types and retailer actions
The
query_types
field in the response is a list indicating the classification(s) of your user's intent. Your system should handle these as follows. Note that
conversational_text_response
refers to the AI-generated natural language response from the API.
Conversational Commerce agent uses search query categories to determine whether an LLM-based answer is generated and how end-user queries are handled by the Conversational and Search APIs for these scenarios:
Categories
Query classifications
#1. Irrelevant queries that don't require an LLM answer
QUERY_TYPE_UNSPECIFIED
: Unspecified query type.
RETAIL_IRRELEVANT
: Queries irrelevant to the retail domain, for example an adversarial query (such as
how to make a bomb),
a chatty query (such as
how are you),
or a jailbreak query (such as
write a poem).
BLOCKLISTED
: Queries explicitly blocked by the commerce customers (such as
What are the side effects of Advil?).
#2. Support and information queries
ORDER_SUPPORT
: Ancillary or support query (such as
Track my order, Order 12345 status).
DEALS_AND_COUPONS
: Queries relevant to deals, promotions, product deals, and discounts (such as
Are there any deals for Thanksgiving?).
STORE_RELEVANT
: Queries relevant to store locations, including working hours and product stock availability (such as
Do we have milk in stock?).
RETAIL_SUPPORT
: Queries relevant to purchases, including payment methods
(What payment method do you accept?).
#3. Keyword searches that don't require LLM
Conversational API request
:
Initial query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
,
"query"
:
"show me some monster energy drinks"
,
"visitorId"
:
"test"
}
Conversational API response
:
Initial response
{
"userQueryTypes"
:
[
"SIMPLE_PRODUCT_SEARCH"
],
"conversationId"
:
"479fd093-c701-4899-bcc3-9e711233bdf9"
,
"refinedSearch"
:
[
{
"query"
:
"monster energy drinks"
}
]
}
Search API request
:
Follow-up query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"query"
:
"monster energy drinks"
,
"visitorId"
:
"test"
}
SIMPLE_PRODUCT_SEARCH
: basic product search, such as
Red dress
or
show some monster drinks.
#4. LLM answer-seeking queries
Conversational API request
:
Initial query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
,
"query"
:
"Compare 1% milk with 2% milk"
,
"visitorId"
:
"test"
}
Conversational API response
:
Initial response
{
"userQueryTypes"
:
[
"PRODUCT_COMPARISON"
],
"conversationalTextResponse"
:
"1% milk contains 110 calories, 1.5 g of saturated fat, and 140 mg of sodium per cup. 2% milk is reduced fat with 37% less fat than regular milk and contains vitamins A & D."
,
"conversationId"
:
"0e1cfdac-802f-422d-906e-9fc9f9d733ba"
,
"refinedSearch"
:
[
{
"query"
:
"1% milk"
},
{
"query"
:
"2% milk"
}
]
}
Search API request
:
Follow-up query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"query"
:
"1% milk"
,
"visitorId"
:
"test"
}
PRODUCT_DETAILS
: Your user is looking for product details and specifications, such as
show me the specifications of [product name], What is the protein content of 2% milk?.
PRODUCT_COMPARISON
: Product comparison, such as
compare [product name] and [product name], Compare 1% milk with 2% milk.
BEST_PRODUCT
: Queries with the most matching pattern, such as
What is the healthiest cookie?, Which milk brand is the best?.
#5. Intent refinement
Conversational API request
:
Initial query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
,
"query"
:
"Help me plan a party"
,
"visitorId"
:
"test"
}
Conversational API response
:
Initial response
{
"userQueryTypes"
:
[
"INTENT_REFINEMENT"
],
"conversationalTextResponse"
:
"To plan a party, you'll need decorations, snacks, party supplies, drinks, and a cake. You can find a wide variety of decorations, snacks, and drinks. For party supplies, you can find everything from plates and cups to balloons and streamers. And for cake, you can choose from a variety of flavors and sizes."
,
"followupQuestion"
:
{
"followupQuestion"
:
"What kind of party are you planning?"
},
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"refinedSearch"
:
[
{
"query"
:
"Decorations"
},
{
"query"
:
"Snacks"
},
{
"query"
:
"Party Supplies"
},
{
"query"
:
"Drinks"
},
{
"query"
:
"Cake"
}
],
"state"
:
"SUCCEEDED"
}
INTENT_REFINEMENT
: The type is unclear and a follow-up conversation or refinement might be needed to clarify the type, such as
Help me plan a party.
This is often the most popular intent in conversations.
Category 1. Irrelevant queries that don't require an LLM answer
QUERY_TYPE_UNSPECIFIED
:
No
conversational_text_response
is provided.
Action
: Handle as a default or error case. You might prompt the user for clarification or direct them to where they can receive general help.
RETAIL_IRRELEVANT
:
No
conversational_text_response
is provided.
Action
: Handle this by showing an appropriate message, such as
I can't answer that question,
or
I am a shopping assistant, how can I help you?
, as defined by your application's design.
BLOCKLISTED
:
No
conversational_text_response
is provided.
Action
: Handle according to your blocklist policy, typically by showing a generic
cannot fulfill this request
message.
Category 2. Support and information queries
For these types, the API doesn't provide a direct
conversational_text_response
by default, but you have options to direct to the right links or resources.
ORDER_SUPPORT
:
Default action
: No
conversational_text_response
is provided. Your web interface needs to display some standard message, relevant links, or reroute the query to your own dedicated support API or customer service channel.
DEALS_AND_COUPONS
:
Default action
: No
conversational_text_response
is provided. Your web interface must display some standard message, relevant links, or reroute the query to your deals or promotion system.
STORE_RELEVANT
:
Default action
: No
conversational_text_response
is provided. Your web interface needs to display some standard message, relevant links, or reroute the query to your own store locator or information system.
RETAIL_SUPPORT
:
Default action
: No
conversational_text_response
is provided. Your web interface needs to display some standard message, relevant links, or reroute the query to your own frequently asked questions and information system.
Category 3. Keyword searches that don't require LLM answers
SIMPLE_PRODUCT_SEARCH
:
No conversational text response is generated.
Action
: The API response
always
returns a single
refined_search
query. This refined query acts as a suggested search term. Make a direct call to the core Search API (
SearchService.Search
) and fetch relevant product results using
either
the original query or the
refined_search
query. The
refined_search.query
might not be directly from the current end-user input but can be derived from the chat history context as well, such as if an end-user previously refined
party dress
to
red ones,
the refined query might become
red party dress.
For conversational interfaces (such as chatbots)
: It is
highly recommended
to use the
refined_search.query
provided by the API. In a conversational flow, natural language queries like "can you help me find bananas" are automatically optimized by the API into a precise product search term ("bananas"), leading to more relevant product results.
For core search experiences (such as the search results page)
: You have the flexibility to use either the
refined_search.query
from the API or the original query provided by the end-user, because it's more likely that the original query is already a precise product search term. Choose the option that best fits your web interface and search result display strategy.
User experience options
: The conversation does
not
need to end for
SIMPLE_PRODUCT_SEARCH
queries. Your user can continue the conversation by passing the
conversation_id
in subsequent requests.
Option A: End conversational web interface
: Many retailers choose to transition your user to a standard search results page once a
SIMPLE_PRODUCT_SEARCH
is detected, effectively closing the chat window. In this scenario, if the end-user then enters a new query into the standard search box without the previous
conversation_id
, it's treated as a new, separate conversation, and a new
conversation_id
is issued.
Option B: Continue conversational web interface
: Retailers can choose to keep the chat window open. This lets your user revert back to a conversational mode. The decision to implement Option A or B depends entirely on the retailer's preferred user experience.
To accurately attribute search queries to conversational interactions and use full analytics capabilities within Vertex AI Search for commerce, proper event tagging is crucial:
Retrieve
conversation_id
. When you make a
conversationalSearch
API call, the
ConversationalSearchResponse.conversation_id
is returned.
Tag user events
. In cases where the conversational response leads to a search query, such as if your system automatically executes a search based on the refined query for
SIMPLE_PRODUCT_SEARCH
, you
must
tag that subsequent search user event (
UserEvent
) with the
same
conversation_id
received in the
ConversationalSearchResponse
.
By correctly tagging
UserEvent.conversation_id
, your analytics can accurately attribute search queries to the preceding conversational interactions, providing valuable insights into your user's behavior and conversion paths.
Category 4. LLM answer-seeking queries
For these query types, the API generates a
conversational_text_response
(LLM answer) and might also provide one or more
refined_search
queries. The conversation doesn't end, and the end user can continue it.
PRODUCT_DETAILS
:
Action
: The
conversational_text_response
provides the requested product details. Your system should display this information clearly to the user.
The response also includes
refined_search
(one or more suggested search queries, ordered and ranked) that should be used to fetch search results using the core Search API.
PRODUCT_COMPARISON
:
Action
: The
conversational_text_response
provides a comparison of the specified products. Your system should display this information clearly to the user.
The response includes
refined_search
(one or more suggested search queries, ordered and ranked) that should be used to fetch search results using the core Search API.
BEST_PRODUCT
:
Action
: The
conversational_text_response
provides recommendations or information about products that best match the query. Your system should display this information.
The response includes
refined_search
(one or more suggested search queries, ordered and ranked) that should be used to fetch search results using the core Search API.
Category 5. Intent refinement
INTENT_REFINEMENT
:
Action
: The response includes
conversational_text_response
, a
followup_question
, and
refined_search
(one or more suggested search queries). The recommended display order is as follows:
conversational_text_response
refined_search
suggestions: These are ordered and ranked, so it is important to display them in the same order as the response.
Followup_question
The response includes
refined_search
(one or more suggested search queries, ordered and ranked) that should be used to fetch search results using the core Search API.
For subsequent interactions, send your user's answer along with the
conversation_id
.
Show suggested queries for products
This is how to configure Google Search to show questions and product suggestions in Conversational Commerce agent.
When the Conversational API returns
refinedSearch
queries, these queries represent excellent opportunities to guide the end user towards relevant products. This is particularly valuable for Category 4 (LLM answer-seeking queries) and Category 5 (
INTENT_REFINEMENT
).
Recommendation
Display
: Present the top
N
(1-3, pending testing on the ideal number for your web interface)
refinedSearch
queries to your user.
Mechanism
: These suggested queries should be run through the core Search API (
SearchService.Search
) in the background or upon user interaction.
Presentation
: Show the results as interactive carousels or clickable cards, letting your user browse related product categories or specific items. This provides immediate value and helps bridge the gap between conversational interaction and product discovery.
Search API request:
Follow-up query
{
"placement"
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
,
"query"
:
"Decorations"
,
"visitorId"
:
"test"
}
Events to send to Vertex AI Search for commerce
It's important to accurately attribute search queries to conversational interactions and use full analytics capabilities within Vertex AI Search for commerce using proper
event tagging
:
Retrieve
conversation_id
. When you make a
conversationalSearch
API call, the
ConversationalSearchResponse.conversation_id
is returned.
Tag user events
. In cases where the conversational response leads to a search query, such as by displaying a
refined_search
suggestion that the end user then clicks, or if your system automatically executes a search based on the refined query, you must tag that subsequent search user event (
UserEvent
) with the same
conversation_id
received in the
ConversationalSearchResponse
.
By correctly tagging
UserEvent.conversation_id
, your analytics can accurately attribute search queries to the preceding conversational interactions, providing valuable insights into user behavior and conversion paths.
Continue the conversation
This section describes how Conversational Commerce agent sessions are maintained by the Conversational API and continue in this final step.
The Conversational API uses a
conversation_id
to manage ongoing conversations. To ensure consistency between LLM answers and search results, subsequent
Conversational API
requests must include
SearchParams
that mirror the configuration of the core Search API calls.
View table
Session handling
Description
Conversational API integration
Start a new conversation
To start a new conversation, the client omits the
conversation_id
from the API request.
Sample API request
placement
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
branch
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
query
:
"Help me plan a party"
conversational_filtering_spec
{
conversational_filtering_mode
:
ENABLED
}
visitor_id
:
"test"
Sample API response
user_query_types
:
"INTENT_REFINEMENT"
conversational_text_response
:
"To plan a party, you\'ll need decorations, snacks, party supplies, drinks, and a cake."
followup_question
{
followup_question
:
"What kind of party are you planning?"
}
conversation_id
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
refined_search
{
query
:
"Decorations"
}
Continue the conversation
The Conversational API returns a
conversation_id
as part of the API response. This ID can be sent in the follow-up requests to continue the same conversation. This helps to ensure that Conversational Commerce agent responds to your user's queries based on the conversation history in that session.
Sample API request
placement
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
branch
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
conversation_id
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
query
:
"Help me plan a party"
conversational_filtering_spec
{
conversational_filtering_mode
:
ENABLED
}
visitor_id
:
"test"
Sample API response
user_query_types
:
"INTENT_REFINEMENT"
conversational_text_response
:
"To plan a party, you\'ll need decorations, snacks, party supplies, drinks, and a cake."
followup_question
{
followup_question
:
"What kind of party are you planning?"
}
conversation_id
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
refined_search
{
query
:
"Decorations"
}
Ensuring search result consistency
To ensure the LLM
        answers are consistent with the search results shown, the client must
        use
SearchParams
in the Conversational API request. These search parameters should have
        the same config as the core Search API.
Sample API request
placement
:
"projects/118220807021/locations/global/catalogs/default_catalog/placements/default_search"
branch
:
"projects/118220807021/locations/global/catalogs/default_catalog/branches/default_branch"
conversation_id
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
query
:
"Help me plan a party"
conversational_filtering_spec
{
conversational_filtering_mode
:
ENABLED
}
visitor_id
:
"test"
search_params
{
filter
:
"filter"
canonical_filter
:
"canonical_filter"
sort_by
:
"sort_by"
boost_spec
{
condition_boost_specs
{
condition
:
"condition"
}
}
}
Session handling
Start a new conversation:
Description
: To begin a new conversation, the client omits the
conversationId
from the API request.
When to start a new conversation
: A client would want to initiate a new conversation — thereby getting a fresh
conversationId
from the API response — in several common user experience scenarios:
New tab or session
: When a customer opens your site in a new browser tab or starts a completely new session.
New original query
: In some UX designs, if a customer enters a new, unrelated query, you might choose to restart the conversational flow to ensure the most relevant context.
Restart conversation button
: If your web interface provides an explicit
Start new chat
or
Reset conversation
button, clicking this would trigger a new conversational session.
Conversational API integration
: The API response includes a new
conversationId
that is used for subsequent requests.
Continue the Conversation:
Description
: The
Conversational API
returns a
conversation_id
as part of the API response. This ID must be sent in follow-up requests to continue the same conversation. This helps to ensure that Conversational Commerce agent responds to your user's queries based on the conversation history within that session, covering the end-user
query
, the
conversational_text_response
, and the
followup_question
.
Conversational API integration
: The client passes the
conversation_id
from the previous response in the
ConversationalSearchRequest
.
Ensure search result consistency:
Description
: To help ensure the LLM answers are consistent with the search results shown to your user, the client
must
use
searchParams
in the
Conversational API
request. These search parameters should have the same configuration, such as filters, sort order) as the
Search API
calls made to retrieve product results.
Conversational API integration
: The
searchParams
object within the
ConversationalSearchRequest
should be populated identically to the
SearchRequest
used for core product search.
Send a request to Vertex AI Search for commerce
You can retrieve the
conversation_id
from session storage. The request should include the new customer
query
, which might be a reply to the question from the previous response. The request should also include the most recent
refined_search.query
from the previous response if the end user is acting on a refined query. Otherwise, it should include a completely new and unrelated query, and the
conversationId
. Remember to always include consistent
searchParams
.
Note:
Whether the
conversationId
is maintained or reset for a new end-user query depends on your specific UX choices and the selected user experience. The
conversationId
acts as the system memory for a given conversational session.
Scenario 1
: Single search bar and persistent conversation: If your search interface has only one main search bar or a persistent conversational window, you won't reset the
conversationId
, even if the end user types a new, seemingly unrelated query. The system uses the existing conversation history (tied to the
conversationId
) to provide contextually relevant responses.
Scenario 2
: Separate conversation window and query window: If your search interface features a distinct conversational chat window and a separate, standard search query bar (such as a site-wide search box), entering a new query into the
standard search bar
might implicitly signal an intent to start a new, unrelated search, thus potentially leading to the
conversationId
being reset for that specific search action. However, within the dedicated conversational window, the
conversationId
should always be maintained for continuity.
Ultimately, the decision on when to reuse versus reset the
conversationId
is a design choice to optimize the conversational experience for your customers.
HTTP method and endpoint (same as initial query)
POST
h
tt
ps
:
//retail.googleapis.com/v2alpha/{placement=projects/*/locations/*/catalogs/*/placements/*}:conversationalSearch
Conversational API request:
Follow-up query
{
"query"
:
"A birthday party"
,
// New query continuing the conversation from the previous turn
"placement"
:
"projects/799252947591/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"visitorId"
:
"test"
,
// Or your actual visitor_id
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
// conversation_id from previous response
"searchParams"
:
{
"filter"
:
"categories:(\"Birthday Party Supplies\")"
}
}
Conversational API response:
Follow-up response
{
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"userQueryTypes"
:
[
"INTENT_REFINEMENT"
],
"conversationalTextResponse"
:
"Great! For a birthday party, you might be interested in specific themes or age-group appropriate items."
,
"followupQuestion"
:
{
"followupQuestion"
:
"What's the age group or theme?"
},
"refinedSearch"
:
[
{
"query"
:
"Birthday party decorations"
},
{
"query"
:
"Birthday party supplies"
}
],
"state"
:
"SUCCEEDED"
}
Examples of an end user continuing to receive questions:
User question:
Help me plan a party.
System answer:
What kind of party are you planning?
User reply:
A birthday party.
What retailers should do with the response
The way to render fields is similar to the initial response, but note the changes reflecting the continued conversation:
refined_search
: This field contains updated query(s) that incorporate the end user's latest input. You should update the client console for the current query correspondingly (such as showing the user-facing query having changed from "decorations" to "birthday party decorations" or "birthday party supplies"). The refined_search queries can be used for calls to the core Search API (
SearchService.Search
) or can also be displayed to the end-user as suggestions.
conversational_text_response
: Display the new AI-generated text response relevant to the latest turn.
followup_question
: If the conversation needs to continue for further refinement, a new
followup_question
is provided.
Events to send to Vertex AI Search for commerce
Event tagging is important to accurately attribute search queries to conversational interactions and to use the analytics capabilities in Vertex AI Search for commerce.
There are two steps in the process of event tagging:
Retrieve
conversation_id
. When you make a
conversationalSearch
API call, the
ConversationalSearchResponse.conversation_id
is returned.
Tag user events
. In cases where the conversational response leads to a search query, such as by displaying a
refined_search
suggestion, or if your system automatically executes a search based on the refined query, you must tag that subsequent search user event (
UserEvent
) with the same
conversation_id
received in the
ConversationalSearchResponse
.
By correctly tagging
UserEvent.conversation_id
, your analytics can accurately attribute search queries to the preceding conversational interactions, providing valuable insights into end-user behavior and conversion paths.
Integrate the agent with conversational product filtering
This guide outlines how to integrate with both the Conversational API and conversational product filtering to provide an AI-powered shopping experience. When
conversationalFilteringSpec.mode
is set to
ENABLED
, your system can directly transition between open-ended conversational interactions and guided product filtering, offering a highly refined user journey.
Understand the interplay
When both conversational commerce agent and conversational product filtering are enabled, the system leverages the strengths of each. Conversational Commerce agent handles broad inquiries, provides AI-generated responses, and refines initial intents, while conversational product filtering guides users through specific product attribute selections using a simplified chip- or tile-based interaction model.
The point of interaction and potential transition between these two modes occurs when the Conversational Commerce API's classification leads to a product-oriented search, specifically
SIMPLE_PRODUCT_SEARCH
. At this point, the API can either provide a direct search query or, if the user's intent can be further refined, it triggers a guided filtering flow through conversational product filtering.
A key principle of this integration is that all free-text input is handled by the Conversational Commerce API, while clicks on suggested answers that appear as chips are handled by conversational product filtering.
Send user query
Example user input
:
Help me plan a party
To enable both conversational commerce agent and conversational product filtering, ensure that your
ConversationalSearchRequest
includes this configuration:
Conversational Commerce API request — Initial query
{
"query"
:
"Help me plan a party"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"placement"
:
"projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/placements/default_search"
,
"visitorId"
:
"your_visitor_id"
,
"conversationId"
:
""
,
// Leave empty for the first query, or populate for ongoing conversation
"searchParams"
:
{
// IMPORTANT: These search parameters should mirror the configuration
// of your Commerce Search API calls to ensure consistency.
"filter"
:
"categories:(\"Party Supplies\" OR \"Decorations\" OR \"Food & Drink\")"
},
"userInfo"
:
{
// Optional: User information for enhanced personalization
},
"conversationalFilteringSpec"
:
{
"conversational_filtering_mode"
:
"ENABLED"
// Crucial for enabling product filtering
}
}
The key configurations are:
Conversational_filtering_mode: ENABLED
: Setting this field to
ENABLED
in your
conversationalFilteringSpec
informs the API that your system can handle conversational product filtering, allowing the API to provide relevant filtering-specific responses.
Initial response: Intent refinement
The
userQueryTypes
field remains central to understanding the user's intent. For an initial broad query like
Help me plan a party,
the API will likely classify it as
INTENT_REFINEMENT
if a more specific product search isn't immediately clear.
Response from Google
Conversational Commerce API response — Initial query
{
"userQueryTypes"
:
[
"INTENT_REFINEMENT"
],
"conversationalTextResponse"
:
"To plan a party, you'll need decorations, snacks, party supplies, drinks, and a cake. You can find a wide variety of decorations, snacks, and drinks. For party supplies, you can find everything from plates and cups to balloons and streamers. And for cake, you can choose from a variety of flavors and sizes."
,
"followupQuestion"
:
{
"followupQuestion"
:
"What kind of party are you planning?"
},
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"refinedSearch"
:
[
{
"query"
:
"Decorations"
},
{
"query"
:
"Snacks"
},
{
"query"
:
"Party Supplies"
},
{
"query"
:
"Drinks"
},
{
"query"
:
"Cake"
}
],
"state"
:
"SUCCEEDED"
}
Action
Display the
conversationalTextResponse
.
Present the
refinedSearch
suggestions like clickable chips for
Decorations, Snacks.
Alternatively, call the Commerce Search API in parallel using the
refined_search
queries to display relevant product results, such as for
Decorations, Snacks
as a carousel, alongside the conversational exchange.
Display the
followupQuestion
:
What kind of party are you planning?
Allow free-form user input to progress the conversation.
Event tagging and analytics
To ensure accurate analytics and attribution for the initial conversational interaction:
Retrieve
conversation_id
. Capture the
conversation_id
from the
ConversationalSearchResponse
. This ID is crucial for linking all subsequent actions to this specific conversational session.
Tag user events
. If the conversational response leads to a search query, such as your system automatically executes a search based on a
refined_search
query, or if the user clicks a
refined_search
suggestion, you must tag that subsequent search user event (
UserEvent
) with the same
conversation_id
.
Follow-up query
When the user responds to the
followupQuestion
, the conversation refines.
Example user input
:
A birthday party
Intent refinement | Code snippets
Conversational Commerce API request — Follow-up query
{
"query"
:
"A birthday party"
,
// New query continuing the conversation from the previous turn
"placement"
:
"projects/799252947591/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"visitorId"
:
"test"
,
// Or your actual visitor_id
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
// conversation_id from previous response
"searchParams"
:
{},
"conversationalFilteringSpec"
:
{
"conversational_filtering_mode"
:
"ENABLED"
}
}
Conversational Commerce API response — Follow-up query
{
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"userQueryTypes"
:
[
"INTENT_REFINEMENT"
],
"conversationalTextResponse"
:
"Great! For a birthday party, you might be interested in specific themes or age-group appropriate items."
,
"followupQuestion"
:
{
"followupQuestion"
:
"What's the age group or theme?"
},
"refinedSearch"
:
[
{
"query"
:
"Birthday party decorations"
},
{
"query"
:
"Birthday party supplies"
}
],
"state"
:
"SUCCEEDED"
}
Action
Similar to the initial response, update the web interface with the new
conversationalTextResponse
,
refinedSearch
suggestions, and
followupQuestion
.
Continue the conversation flow, prompting for more detail.
Event tagging and analytics
When the user continues the conversation:
Retrieve
conversation_id
. Ensure the
conversation_id
from the previous
ConversationalSearchResponse
is passed in the current
ConversationalSearchRequest
.
Tag user events
. If the conversational response leads to a new search query, such as due to a user clicking a
refined_search
suggestion or your system making a parallel search call, tag that subsequent search user event (
UserEvent
) with the same
conversation_id
. This helps track the multi-turn conversational journey.
Transition to conversational product filtering
As the conversation gets more specific, the system might classify the intent as
SIMPLE_PRODUCT_SEARCH
, and if suitable, trigger conversational product filtering.
Example user input
:
Princess theme
Conversational Commerce API request — Follow-up query
{
"query"
:
"Princess theme"
,
"placement"
:
"projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"visitorId"
:
"your_visitor_id"
,
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"searchParams"
:
{},
"userInfo"
:
{},
"conversationalFilteringSpec"
:
{
"conversational_filtering_mode"
:
"ENABLED"
}
}
Possible outcomes for core product search
When a query is classified as
SIMPLE_PRODUCT_SEARCH
, there are two possible API responses, depending on whether
Conversational Product Filtering
is triggered. The key difference lies in the presence and content of the
conversationalFilteringResult
field.
Outcome 1: Filtering is triggered
This occurs when the query is core enough to be refined further by product attributes. The response includes
conversationalFilteringResult
, which your web interface should prioritize.
Conversational Commerce API response — Transition to product filtering:
{
"userQueryTypes"
:
[
"SIMPLE_PRODUCT_SEARCH"
],
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"refinedSearch"
:
[
{
"query"
:
"princess birthday decorations"
}
],
"conversationalFilteringResult"
:
{
"followupQuestion"
:
"What specific type of princess decoration are you looking for?"
,
"suggestedAnswers"
:
[
{
"answer"
:
"Balloons"
,
"query"
:
"princess birthday balloons"
},
{
"answer"
:
"Streamers"
,
"query"
:
"princess birthday streamers"
},
{
"answer"
:
"Tablecloths"
,
"query"
:
"princess birthday tablecloths"
}
]
},
"state"
:
"SUCCEEDED"
}
Action
The query has now been classified as
SIMPLE_PRODUCT_SEARCH
. In this case, it triggers conversational product filtering. However, it could be the case the it does not trigger conversational product filtering.
Prioritize the conversational product filtering web interface
:When
conversationalFilteringResult
is populated, it signals that you've entered the product filtering mode. Your web interface should emphasize the
followupQuestion
, which appears on the user interface as something like
What specific type of princess decoration are you looking for?
, and
suggestedAnswers
, such as as clickable buttons for
Balloons, Streamers, Tablecloths.
Display product results
: Immediately call the Retail Search API using the
refined_search.query
(princess birthday decorations)
to display initial product results alongside the filtering options.
Recommended user experience practice
: There should be a single, persistent free-text input bar for the entire experience. This bar remains active at all times, including during a conversational product filtering flow.
When the
conversationalFilteringResult
is active and you display suggested answers as clickable chips, users have two clear options:
Continue the filtering flow
by clicking on a suggested answer.
Start a new conversational turn
by typing a new query into the active text bar. This new input always triggers a new call to the Conversational Commerce API, effectively ending the current filtering flow.
Note:
This design choice aligns with the core principle that free-text input is handled by the Conversational Commerce API, while clicks on suggested answers are handled by conversational product filtering.
Outcome 2: No filtering is triggered
If the query is already specific enough or doesn't lend itself to further filtering, the response doesn't include the
conversationalFilteringResult
field. In this case, you should proceed with a standard search.
Action
Treat the interaction as the end of the conversational flow and use the
refined_search
query to call the
Retail Search API
and display a standard product results page.
Event tagging and analytics
When the conversation transitions to product filtering:
Retrieve
conversation_id
. Continue to use the same
conversation_id
.
Tag user events
. If the transition leads to an immediate search, tag that
UserEvent
with the
conversation_id
. Importantly, when the user interacts with the
suggestedAnswers
such as when an end user clicks
Balloons,
this action should also trigger a
UserEvent
such as a
filter
event or a new
search
event, that is tagged with the same
conversation_id
. This allows for attribution of filtering actions within the conversational flow.
Continue in conversational product filtering
When the user selects a
suggestedAnswer
, send a new
ConversationalSearchRequest
.
Example user input (Clicking a suggested answer)
:
Balloons
Simple product search
| Code snippets
Conversational Commerce API request — Continue filtering
{
"query"
:
"Balloons"
,
// The selected answer
"placement"
:
"projects/YOUR_PROJECT_ID/locations/global/catalogs/default_catalog/placements/default_search"
,
"branch"
:
"projects/{project_id}/locations/{location_id}/catalogs/{catalog_id}/branches/default_branch"
,
"visitorId"
:
"your_visitor_id"
,
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
// Maintain conversation ID
"searchParams"
:
{},
"userInfo"
:
{},
"conversationalFilteringSpec"
:
{
"conversational_filtering_mode"
:
"ENABLED"
}
}
Conversational Commerce API response — Continue filtering
{
"userQueryTypes"
:
[
"SIMPLE_PRODUCT_SEARCH"
],
"conversationId"
:
"1577511e-36ed-4054-8e07-48d1ca016bcb"
,
"refinedSearch"
:
[
{
"query"
:
"princess birthday balloons"
}
],
"state"
:
"SUCCEEDED"
}
Action
The API responds with a
SIMPLE_PRODUCT_SEARCH
query but without the
conversationalFilteringResult
field, indicating that the guided filtering flow has concluded.
Use the final
refinedSearch
query
(princess birthday balloons)
to make a direct call to the Retail Search API.
Display the final product results to the user. At this point, the conversation can either end, or the user can enter a new query to start a new turn.
Event tagging and analytics
For each step within the product filtering process:
Retrieve
conversation_id
. Always use the same
conversation_id
for all requests within the filtering session.
Tag user events
. Each user interaction with a
suggestedAnswer
such as a click, should trigger a relevant
UserEvent
such as a
filter
event or a new
search
event if a new query is formed. This
UserEvent
must be tagged with the
conversation_id
to accurately track the filtering journey and its impact on conversion.
User interface recommendations and design choices
The interaction between Conversational Commerce agent and conversational product filtering offers significant flexibility. Here are some key UX considerations for creating a smooth and intuitive experience:
Single input bar
: There should only be
one free-text input bar
for the entire experience. There is no separate, dedicated input bar for Conversational Product Filtering. This simplifies the user interface and keeps the interaction consistent.
Seamless transitions
: Design your web interface to make transitions between conversational responses, suggested queries, and filtering options feel natural and intuitive.
Clear guidance
: Use visual cues like distinct button styles for suggested answers instead of general input, and clear instructions to guide the user on how to interact at each stage.
Balancing control
: The user should always feel in control of the conversation's direction.
Filtering vs. free-form
: The single free-text input bar remains active at all times. This gives the user a constant choice: they can either click a suggested answer to continue refining their search or type a new query into the text bar to start a new conversational turn. This design ensures that even during a filtering flow, the user can pivot to a different topic if their needs change.
Reset option
: Provide a clear
Start new conversation
or
Reset filters
option to allow users to restart their search or filtering process.
Visual persistence
: Even when transitioning to product filtering, maintaining the conversation history within the chat window, such as showing previous questions and answers, can enhance context and user experience.
Additional considerations and best practices
Additional considerations and best practices must be considered when implementing your Conversational Commerce agent interface:
Visitor ID consistency
: Help to ensure that a unique
visitor_id
is consistently sent with each request for a given end user. This is vital for accurate personalization and model training. This identifier should ideally remain consistent for an end user across sessions and sign in or sign out states.
Branch management
: While
default_branch
is common, ensure you are using the correct branch ID if your product catalog is structured with multiple branches.
Search API interaction
: For
SIMPLE_PRODUCT_SEARCH
and any cases where
refined_search
is provided, remember to make a separate call to the core Search API (
SearchService.Search
) using the
query
from the
refined_search
field or the original query to get the actual product listings. The Conversational API primarily focuses on the conversational experience and user intent understanding rather than directly returning product results.
User interface design
: Design your web interface to clearly present
conversational_text_response
,
followup_question
, and
refined_search
options in an intuitive manner to guide your user.
What's next
For additional support resources, see
conversational feature FAQs
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-commerce-ux-guide.txt
Conversational Commerce agent user experience guide  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational Commerce agent user experience guide
This page describes how to optimize the user experience for your Conversational Commerce agent implementation in Vertex AI Search for commerce.
Search optimization checklist
Take these steps to avoid common pitfalls:
Ensure relevance is based on user behavior, preferences and past interactions.
Use transparent personalization cues like
recommended based on previous searches.
Enable users to modify or reset personalization options.
Core principles
This section describes core principles and best practices for using Conversational Commerce agent as part of your guided search package.
Clarity and transparency
Configure your site in such a way that your users get the results they want, and have the ability to refine or adjust search parameters, as enabled by these features described:
Ambiguous queries
When encountering a vague search, the Conversational Commerce agent proactively seeks clarification.
Nuanced queries
Extremely detailed queries require strong content structures and detailed metadata for Vertex AI Search for commerce to return accurate results.
User expectations
The model must show results prioritized according to your user's search history.
Candid limitations
If a query can't be understood or if it returns only limited results, Vertex AI Search for commerce lets the site visitor know and offers alternatives.
Efficiency and speed
Use predictive search
Provide
autocomplete suggestions
, predict intent, and surface relevant results instantly using historical data, trending queries, and user behavior.
Enhance filtering mechanisms
Refine results through conversational inputs to accelerate the process of getting what you are looking for.
Ranking and optimization
Prioritize the most relevant products based on context, user history, and search trends.
Reduce cognitive load
Configure Vertex AI Search for commerce to harness contextual awareness to remember a user's previous selections to minimize redundant actions and accelerate user decision-making.
Create personalization without overload
To avoid overwhelming users, dynamic filtering can strike a balance between personalization and user autonomy. Instead of overwhelming a user with too many filters, Conversational Commerce agent has the capability of suggesting refinement based on preferences from a user's previous search or purchase data. Additionally, Vertex AI Search for commerce is adaptable to real-time behavior. For example, purchase history might not be relevant while searching for a gift for someone else, so Conversational Commerce agent can adjust itself to this context and not show your user this unnecessary information.
Control features to ensure context and continuity across sessions
Rather than treating every query in isolation, contextual awareness allows for more efficient searches without repeating previous inputs. Not only should contextual awareness be pervasive within and across sessions, but also across devices to ensure continuity.
Continuity within sessions
Vertex AI Search for commerce is designed to remember a user's past interactions within a session to allow for incremental refinements.
Continuity across sessions
Site visitors should be able to pick up where they left off in a previous session without Conversational Commerce agent feeling intrusive.
Integrate accessibility and inclusivity considerations
Whether site visitors interact through voice, text, or images, Vertex AI Search for commerce must provide inclusive solutions that support individuals with varying abilities, preferences, or technological constraints.
Accessibility tools
Multimodal input support
Voice-to-text correction
Screen reader compatibility
Real-time transcription
Clear semantic structuring
Predictive text assist
Voiceovers for image-based content
Autocorrect
Use targeted questions to ensure graceful error handling
Inevitably, there are instances when a query produces no results on a particular site. Instead of an unhelpful
no results
message, Conversational Commerce agent offers intelligent suggestions and alternatives. Additionally, Conversational Commerce agent prompts for clarification, asking targeted questions to narrow down preferences and needs, creating a user-centric dialogue.
Design calls-to-action to end conversations gracefully
To prevent user abandonment, Conversational Commerce agent ends conversations with clear, actionable pathways, maximizing user satisfaction and boosting the likelihood of conversion by maintaining momentum. Furthermore, Conversational Commerce agent can create opportunities for re-engagement after the initial interaction by surfacing relevant follow-up questions based on browsing activity or purchase history.
Optimize web interface components and patterns
This section details how user interface design can optimize Conversational Commerce agent experiences, particularly on mobile. It focuses on enhancing search input and presentation, managing conversational elements without disrupting browsing, and leveraging autocomplete, predictive search, and carousels for efficient product discovery. The section also covers strategies for presenting search results, handling ambiguous queries, and using communicative animations to create a smoother and more intuitive user journey.
Search input and enhancement
As the entry point for Conversational Commerce agent, the search box must balance clarity and functionality and, particularly on mobile where screen space is limited, it must do so with minimal disruption.
Optimize placement for mobile
Most people use their thumbs to navigate their phones, so placing the search box at the bottom of the screen aligns better with user behavior. This minor detail aligns with the Conversational Commerce agent goals of making search more intuitive and reducing navigation effort and friction.
Indicate support for natural language input
Suggested prompts
:
Show me red sneakers for under $100
Dynamic placeholder text
:
Ask a question
Microcopy
:
Try searching in full sentences!
Icons
: Chat bubble, microphone, or camera icons
Manage Conversational Commerce agent without disrupting browsing
When search becomes conversational, it risks taking up valuable screen space.
To mitigate this risk, you can implement:
Collapsible conversation
: Allows users to expand and contract the conversation area using a persistent icon.
Conversation overlay
: A conversation overlay floats above the page allowing users to still view results.
Embedded conversation
: The search journey begins as a standard input field but expands into a full-screen conversational web interface.
Configure autocomplete and predictive search
To reduce the need for users to type out full search terms autocomplete and predictive search reduce the need for full search terms, implement:
Intelligent predictive assistance
: Predictive terms appear within the search bar as users type, offering real-time, autocomplete suggestions in a lighter font.
Dropdown prediction list
: A dynamic list appears below the search bar, showcasing suggested queries, popular searches, and recent history
Contextual filtering chips
: Filters display below the search bar as users type, providing relevant filter options such as categories, price ranges, or brands.
Smart corrections
: Subtle autocorrect suggestions for misspelled words is displayed in the drop-down.
Present and refine search results
Optimizing search item returns through layout and refinement options can make the browsing experience smoother, ensuring site visitors can efficiently scan, compare, and filter results.
Results views and layouts
How results are presented within a Conversational Commerce agent console depends on the web interface being embedded or overlaid on the experience.
Collapsible and overlay results
: This view allows results to be decoupled, dynamically updating the main product grid while keeping the conversation accessible in a side panel or floating conversation.
Embedded results
: This view displays results directly within the conversation, as structured cards, carousels, or inline product listings, ensuring a seamless experience.
Implement dynamic filtering and refinement
When users enter a prompt, guided search proactively guides users towards more precise results by asking clarifying questions or surfacing relevant filter options inline.
Use interactive page elements to handle ambiguous queries
Instead of returning an unfocused set of results, the interface can use interactive page elements to guide users toward more relevant results.
Integrate communicative animations on your site
Subtle animations such as these examples provide visual feedback to make interactions feel smoother and more intuitive, helping users understand changes in real time.
Loading states
: A shimmer effect on product cards or a subtle pulse on the search bar can indicate that search is processing.
Typing indicators
: A brief typing animation (e.g., three dots pulsating) reassures users that the system is actively working.
Streaming responses
: Conversational Commerce agent can generate responses in real-time, with text appearing dynamically as it is processed.
Fading transitions
: When users adjust filters or guided search suggests refinements, results can fade in and out.
Utilize carousels
Carousels showcase relevant products, recommendations and trending items without overwhelming users. Especially on mobile, carousels optimize limited screen space by allowing users to browse multiple products or offers with intuitive swipe gestures.
Carousel features are:
Personalized recommendations based on user behavior
Trending or featured products
Recently viewed items
Category-based browsing
Carousel best practices are:
Ensure clear navigation
Use horizontal instead of vertical scrolling
Limit carousel items
Complement primary results
Multimodal experience
Voice search and input and transcribed text helps to ensure a multimodal model guided search experience.
Voice search
: Voice search is intended to feel natural and effortless to the site visitor. The web interface designed to support quick, clear user interactions.
Voice input button
: A microphone icon in the search bar allows the site visitor to activate voice search, with animated indicators pulsing or lighting up to provide users visual feedback when activated.
Streaming transcribed text
: Conversational Commerce agent can stream transcribed text as the user interacts using voice, letting the site visitor review and adjust their input while minimizing site clutter.
Practical guidance to web interface components
This section comprises practical guidance for how to optimize your Conversational Commerce agent components in the web interface.
Simplify the experience
A simplified user experience reduces cognitive load and helps to ensure that your users can quickly find what they are looking for without unnecessary distractions.
A reduced cognitive load in a user interface can be summed up as:
Minimizing the steps in the process.
Keeping interfaces clean and intuitive.
Streamlining AI suggestions.
Avoid misleading or irrelevant personalization
Irrelevant or misleading results can quickly frustrate users.
Understand intent and VIP questions
To refine intent, Conversational Commerce agent prompts users with relevant questions. Therefore, Conversational Commerce agent should be configured to ask targeted questions to further reduce the number of results and reduce ambiguity.
User journey
This is an example of a desirable user conversation path.
Step 1. Conversational Commerce agent prompts your user with a question.
For example:
What is the location and time of year of the wedding?
Your user might answer this prompt with something like:
It's in New York in the
summertime.
Step 2. Based on your user's answer, Conversational Commerce agent then targets your user with specialized questions and shows them related items to further reduce the number of search results and reduce ambiguity.
Conversational filtering
Conversational filtering guides users toward more relevant options without overwhelming them by:
Immediately updating results.
Suggesting useful filters.
Labeling filters clearly.
To learn more about conversational product filtering, see
Conversational product filtering
.
Handle edge cases and errors
To make the search process more reliable and user-friendly, Vertex AI Search for commerce can gracefully handle unusual, or edge cases, and errors in a number of ways:
Surfaces closely related alternatives.
Clearly displays stock availability.
Suggests similar alternatives.
Offers back-in-stock notifications.
Provides hand-off to customer support.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-filtering-dev-guide.txt
Conversational filtering developer's guide  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational filtering developer's guide
The following is a developer's guide on how to integrate conversational product filtering in your API.
Administrator experience
Manage the generative questions and conversational product filtering directly in the API, or in the
Search for commerce console
, and set it up in the
Data quality
and
Evaluate
sections of the Search for commerce console.
Cloud console
The console allows retailers to manage generative questions in a conversational product filtering experience. Learn more about
using generative questions in conversational product filtering
.
Steps to use the generative question service
Satisfy
data requirements
.
Configure
manual question overrides
.
Turn the
feature on
.
Preview and test
.
Data requirements
To find out if your search data is ready for conversational product filtering, in the console, under
Conversational product filtering and browse
, or under
Data quality > Conversation
, go to the
Coverage checks
tab.
To enable conversational product filtering, you need to meet certain data requirements.
These are:
1,000 queries per day
: After you reach this first threshold, a conversation plan is generated that evaluates your inputs and outputs:
Inputs
: filter count in events
Outputs
: conversational coverage
25% conversational coverage
: Calculated by Vertex AI Search for commerce models, conversational coverage means the percentage of queries that have one question. A frequency-weighted 25% (by volume) of queries should have at least a first question that matches it.
If you don't have 25% conversational coverage yet, but have the first prerequisite 1000 queries per day, blocking and advisory checks begin to be applied to your outputs and inputs, respectively. Here, Vertex AI Search for commerce begins to calculate by how much of a percentage your user-event-applied filters have to increase in order to reach the 25% conversational coverage threshold. The more filters that are uploaded, the higher the coverage reached.
To view your conversational readiness:
Go to the
Conversation
tab in the
Data quality
page in the
Search for commerce console. This provides you with a critical check of whether a minimum of 25% of search queries have at least one follow-up question, as well as advisory checks as to what percentage of user events with valid filters is needed to reach that conversational coverage goal.
Figure 4
. Conversational readiness check.
If you pass the critical check, with sufficient user events with valid filters, proceed to the next step.
To control how generative questions are served, go to the
Conversational product filtering and browse page
in the Vertex AI Search for commerce console.
Generative question controls
The generative AI writes a question for every indexable attribute in the catalog, using both names and values of attributes for system and custom attributes. These questions are generated by an LLM and aim to enhance the search experience. For example, for furniture type, values can be indoor or outdoor, the AI synthesizes a question about what type of furniture you are looking for.
Each facet has one generated question. Based on historic user events and facet engagement from past search event data, the questions are sorted by expected frequency of the question appearing. The AI first looks at the questions on top, then finds what is relevant by attribute. The list of questions is generated once. If a new attribute is added, it is reflected in the list in two hours.
Go to the
Conversational search and browse
page in the Search for commerce console.
Go to the Conversational search and browse page.
Under the
Manage AI generated questions
tab, view all the questions sorted by how often they are used, in query-weighted frequency, meaning how often they are served with common queries. The ranking uses the frequency field in the
GenerativeQuestionConfig
configuration. This field is responsible for sorting the AI-generated questions by how often they are used.
You can use the filter option to filter the questions.
Check the box to enable question visibility for each attribute.
Click
edit
at the end of each row to open an edit panel for each question.
To make bulk edits, follow these steps:
Select or clear the boxes next to the questions that you want to include or exclude in conversation.
Click either the
add
Allow in conversation
or the
remove
Disallow in conversation
buttons that appear at the top of the list. Alternatively, to edit an individual question, click
edit
and clear or recheck the box next to
Allowed in conversation
in the pane that opens:
Figure 5
. Edit each AI-generated question.
Use generative questions in conversational product filtering
The generative question service API provides controls to mitigate potential inconsistencies in the LLM output. These can be managed from the console. Here, retailers can also configure conversational product filtering by toggling its enabled state and setting the minimum number of products required to trigger it.
You can define the questions, specifying the question itself, potential answers, and whether the question is allowed in the conversation. Individual questions can be generated by an LLM or overridden by the retailer. The console supports reviewing AI-generated questions, allowing retailers to override them or toggle their conversational status. Questions can also be bulk edited.
Edit individual questions
You can also use controls to curate the individual questions. It is recommended to do this before you turn conversational product filtering on.
For each question, there are two options. Click
edit
in in the last column to access the questions visible to the users panel:
Turn off a question for all queries
: The question is enabled by default. Clear (or check again) the box next to
Allowed in conversation.
This option skips the question altogether. A retailer may opt to disable a question entirely if it does not relate to the queried attributes or could be misconstrued as inappropriate in some way (a question such as "What dress size are you looking for?" may be perceived as prying about a shopper's weight.)
Rewrite a question:
In the pane, you can see the AI-generated question, what attribute it is attached to and what values the attribute has. Click the pencil to rewrite it.
Turn on conversational filtering
After you have edited your generative AI questions in the console, you are ready to turn on conversational product filtering.
To enable conversational product filtering, go to the
Conversational product
filtering and browse page
in the Search for commerce console.
Go to the
Conversational search and browse
page in the Search for commerce console.
Go to the Conversational search and browse page.
Consider the minimum amount of products in your catalog you want returned in the search before questions are generated. This number can be higher but never lower than 2. One row to a page is often the right amount for triggering a conversation.
Configure the number and switch the toggle to
On
. If fewer products match the number, they get filtered out.
Figure 6
. Switch toggle on to
Enable conversational search
.
Note:
If generative AI is enabled and the LLM relates an AI-generated question to any related attribute value, an AI question could appear.
This page provides information as to the status of your blocking and advisory checks. If you have enough search queries with
at least one follow-up question
, your site is now conversational search-enabled.
Evaluate and test
Evaluate
lets you preview the serving experience by running a test search and testing your questions against displayed facets. This part of the console provides you with a preview of your serving experience with conversational product filtering.
To evaluate and test, follow these steps. In the
Evaluate
section on the
Search
or
Browse
tabs on the
Evaluate page
of the
Search for commerce console.
Go to the
Evaluate
page in the Search for commerce console.
Go to the Evaluate page
Click
Search
or
Browse
.
In the
Search Evaluation
field, enter a test query that makes sense based on the catalog you have uploaded to search, such as
shoes
if your catalog consists of clothing items.
Click
Search preview
to see search results.
Figure 7
. Preview results.
If you have conversational product filtering enabled, generative questions are enabled.
Generative Question API
This section describes how to use the generative question API to integrate the Conversational API into your UI, manage the generative questions, and serve the feature on your site.
API integration
Objects:
GenerativeQuestionsFeatureConfig
GenerativeQuestionConfig
GenerativeQuestions Service
UpdateGenerativeQuestionsFeatureConfiguration
UpdateGenerativeQuestionConfig
ListGenerativeQuestionConfigs
GetGenerativeQuestionFeatureConfig
BatchUpdateGenerativeQuestionConfigs
The core to integrating this feature is defining the
question
resource. This includes the question itself and whether the question is allowed in the conversation. The question is by default generated by an LLM but can be overridden by the administrator.
Enable conversational product filtering
Object:
GenerativeQuestionsFeatureConfig
This object is a control configuration file for enabling the feature for generative questions to manage the overall serving experience of conversational product filtering.
GenerativeQuestionsFeatureConfig
uses a GET method to obtain attribute information and whether the attributes are indexable or not from the catalog associated with the project.
The
feature_enabled
switch determines whether questions are used at serving time. It manages the top-level toggles in the console.
Note:
You
can't
enable this feature until data requirements are satisfied. If the data requirements aren't met, the API triggers a validation error. The data requirements validation is visible in the Search for commerce console, which, under the hood, calls the converstaional configuration API.
Enable the feature
// Configuration for overall generative question feature state.
message
GenerativeQuestionsFeatureConfig
{
...
// Resource name of the affected catalog.
// Format: projects/{project}/locations/{location}/catalogs/{catalog}
string
catalog
=
1
[(
google
.
api
.
field_behavior
)
=
REQUIRED
];
// Determines whether questions are used at serving time.
// Note: You cannot enable this until initial data requirements are
// satisfied.
bool
feature_enabled
=
2
[(
google
.
api
.
field_behavior
)
=
OPTIONAL
];
// Minimum number of products in the response to trigger follow-up questions.
// Value must be 0 or positive.
int32
minimum_products
=
3
[(
google
.
api
.
field_behavior
)
=
OPTIONAL
];
}
Conversation-relevant fields
catalog
string
The resource name of the affected catalog at the project level. Format:
projects/{project}/locations/{location}/catalogs/{catalog}
.
feature_enabled
boolean
Switches questions on or off.  Optional field. It cannot be enabled until data requirements are met. If attempted, it throws  an error.
minimum_products
Integer32
Minimum number of products in the response to trigger follow-up questions. Must have a value of 0 or greater.
Manage the generative questions
Object
:
GenerativeQuestionConfig
A question can be conversation-enabled with the boolean field
allowed_in_conversation
. It controls the configuration for a single generated question.
Fields (control behaviors for conversation highlighted)
catalog
string
Used to identify which set of attributes (and by extension questions) are available. These values are all defined in the catalog. Required field.
facet
string
Facet to which a question is associated. Required field.
generated_question
string
The LLM generated default question. Output only.
final_question
string
The question that is asked.  It can  have a max length of 300 bytes. Optional field.
example_values
Repeated string
Values that can be used to answer the question. Output only.
frequency
float
The ratio of how often a question was asked. Output only.
allowed_in_conversation
boolean
Whether the question is asked at serving time. This field is optional.
Serving experience
Conversational product filtering is based on engaging your user with an ongoing conversation of multiple turns. Therefore, there's at least a second response required for conversational product filtering to work. Your user is presented with a follow-up question and suggested answers in the response, and your user can respond to this follow-up question either by either entering their answer or by clicking on a suggested answer (multiple choice option).
The multiple choice option functions behind the scenes like a facet (an event type filter), which narrows the query using filtering. In the background, when the user clicks on a multiple choice response, a filter is applied to the query. Applying a filter using conversational multiple choice is identical to applying the same filter using dynamic facets or tiles.
Service enabled by the feature
The generative questions service (
service GenerativeQuestionService{...}
) is used for managing LLM-generated questions. Its parent object is the catalog, where it retrieves information from to return questions for a given catalog. The service is used to manage the overall generative question feature state, make individual or batch changes, and toggle questions on or off.
Data requirements
must be met to interface with the Service API, and the questions must be initialized before the questions can be managed.
The service interacts with the feature level and question level configuration files with two sets of handlers:
GenerativeQuestionsFeatureConfig
handlers (feature-level)
:
Update
Lets you change minimum products and enable fields.
Get
Returns an object.
GenerativeQuestion Config handlers (question-level)
:
List
Returns all questions for a given catalog.
Update
Performs individual question management.
Batch Update
Performs grouped question management.
The service returns a semantically appropriate question based on the initial query.
A follow-up question is generated by the LLM model and
can be overridden
. The questions are displayed based on how likely it is used by customers by calling the search event history. If there is no search event history, the fallback is on the commerce search logs.
Different questions are generated based on the previous query. There are no fixed weights. The AI that drives the LLM-generated questions learns from the queries and changes the weighting for every query, so that "shirt", for example, weighs the category very heavily, but "XL red shirt" weighs category, size and color.
Configure the serving experience
Configure the serving experience by integrating the conversational filtering configuration API with the Search API.
The configuration API
ConversationalFilteringSpec
for the feature sits on top of the
Conversational API
. You can either call both APIs in parallel or in this order:
Conversational API
Search API
ConversationalFilteringSpec
: This optional field has been added to
ConversationalSearchRequest
but is required if you want to use the conversational filtering feature. The field reuses the
SearchRequest
fields, query and filter. It also includes a field to enable a follow-up question served to the user after an initial query and a `conversation_id` to maintain the state of the conversation between the client and server.
ConversationalFilteringResult
: A proto file contains extra information needed to be returned for the conversational CRS flow in
ConversationalSearchResponse
. This includes a
conversation_id
,
refined_query
,
additional_filters
,
follow_up_question
, and
suggested_answers
.
User journey using the conversational flow API
The user initiates a search with an initial query and sets the
mode
flag to
CONVERSATIONAL_FILTER_ONLY
. The user then selects an answer, which is sent back to the API using the
user_answer
field.
The Conversational API provides the
additional_filter
field in the response. The user must apply these filters to the Search API follow-up request. The search results are based on the user's input and provide a new follow-up question, prompting a follow-up query and continuing the conversation in multiple turns until the user finds what they're looking for on the retailer website.
Note:
Conversational product filtering interfaces with two APIs, which include Search and Conversational. The Search API is intended to fetch the search results, and Conversational API is intended to fetch the conversational response. The Conversational API doesn't return search results.
Assuming conversational product filtering is enabled on the website, the user journey and subsequent interaction with Vertex AI Search for commerce follows this path:
Step 1
. First query comes from user to both Search and Conversational API. The Search API only returns search results. The Conversational API returns the suggested answers and follow-up questions. Call the Search API for the same query or
page_category
and fetch the search results.
Step 2
. Follow-up conversation requested is sent to conversational search. Call the Conversational API with the right conversation filtering mode.
Step 3
. Initial search response with search results only. The Conversational API refines the query by returning the suggested answers and follow-up questions.
User selection
: User selects multiple choice.
Selected answer filter is sent to the Conversational API.
Conversation and Search APIs run with the applied filter.
First query comes from user starts conversation
The first query is when your user starts a conversation in Vertex AI Search for commerce and looks for
dress
in the search box.
Note:
There are two different API endpoints. The core Search API must be used to fetch search results, and the new Conversational API must be used to fetch the conversational experience. Conversational API doesn't return search results.
Send a request to the Search API by creating the following search request by setting
dress
as the query (or whatever the actual query is):
Search API request
{
query
:
"dress"
,
Search_params
:
{
"filter"
:
s
tr
i
n
g
,
"canonicalFilter"
:
s
tr
i
n
g
,
"sortBy"
:
s
tr
i
n
g
,
"boostSpec"
:
{
objec
t
(Boos
t
Spec)
}
}
}
There is no change in the search API request as part of the conversational product filtering.
Send a request to the Conversational API by doing the following:
Create a conversational search request by setting
dress
as the query (or whatever the actual query is).
Set
mode
to
CONVERSATIONAL_FILTER_ONLY
in order to get a conversational response. If it's set to
DISABLED
, no follow-up question is supplied.
Populate
SearchParams
in the conversational search request. The search parameters should be the same as the Search API call.
Conversational API request
{
"query"
:
"dress"
,
"conversational_search_spec"
:
{
"mode"
:
"CONVERSATIONAL_FILTER_ONLY"
}
}
Your response from the Conversational API then looks like this:
Conversational API request
{
co
n
versa
t
io
n
_id
:
"c154d073-87f5-4edb-accd-587eabe014ff"
re
f
i
ne
d_query
:
"dress"
co
n
versa
t
io
nal
_
f
il
ter
i
n
g_resul
t
:
{
f
ollowup_ques
t
io
n
{
f
ollowup_ques
t
io
n
:
"What is the color?"
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"yellow"
}
}
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"blue"
}
}
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"red"
}
}
}
}
}
What you should do with the response:
conversation_id
: This ID can be stored in the browser session storage and can be used to continue the conversational search with the server. Because one shopper might have multiple tabs open with more than one conversation, the
conversation_id
is used to track the conversations.
refined_query
: Identifies the current query. You must use this response to call the Search API to fetch the product results.
followup_question
: Identifies the question to show to the user.
suggested_answers
: An ordered list of the multiple-choice answers that should be shown to your users. If you want to show fewer answers, just show the first N results. The list is sorted in the order the results should be shown.
Send initial user query with conversation enabled
Conversational API request
{
"query"
:
"dress"
,
"conversational_search_spec"
:
{
"mode"
:
"CONVERSATIONAL_FILTER_ONLY"
}
}
Search sends back conversation parameters
Conversational API Response
{
co
n
versa
t
io
n
_id
:
"c154d073-87f5-4edb-accd-587eabe014ff"
re
f
i
ne
d_query
:
"dress"
co
n
versa
t
io
nal
_
f
il
ter
i
n
g_resul
t
:
{
f
ollowup_ques
t
io
n
{
f
ollowup_ques
t
io
n
:
"What is the color?"
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"yellow"
}
}
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"blue"
}
}
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"red"
}
}
}
}
}
conversational_filtering_result
is a field that relates to
ConversationalFilteringResult
is a proto that contains extra information returned from the conversational flow. The
conversational_filtering_result
field in
ConversationalSearchResponse
provides supplementary data that is crucial for UI rendering on the client side. The
conversational_filtering_result
field uses nested messages such as
SuggestedAnswer
and
AdditionalFilter
to structure the returned data in a clear and comprehensible manner. This hierarchical structure ensures that the information exchanged between the client and server is well-defined and interpretable.
The suggested answers are sorted by which facet values in the catalog were most often engaged in the user events as filters for all queries. The sorting uses the
engagement_rate
field in the follow-up question generated by the
ConversationalSearch
service. This field captures the historical engagement rate that the filter shows from the retailer's search events sent to the server.
All the other fields are unchanged when conversation is used.
What to do with the initial conversational search return
On the client side, developers should store the
conversation_id
in browser session storage so that this can be used to continue the conversational search with the server.
This is used to keep track of the ongoing  conversation, since one shopper could have multiple tabs open with multiple running conversations.
refined_query
tells the retailer what the current query is.
This should be used if the retailer wants to show the current query to the user.
followup_question
tells the retailer what question to show to the user
suggested_answers
.
This is an ordered list of the multiple choice answers that should be shown to the users.
If you want to show fewer than the full list, just show the first N results
This list is sorted, so it must be shown in the proper order. In other words, the first result to show is the first one listed.
Conversational product filtering serves these options for continued conversational engagement, leading to faster search refinement:
User selection
When your user is served search results, they can select a multiple-choice option.
This code sample demonstrates that the user selected the multiple choice answer
yellow,
and a new conversational request is sent to the Search API by sending the query again along with the correct user filter applied.
Search API request
{
query
:
"dress"
,
"search_params"
:
{
"boost_spec"
:
{},
"canonical_filter"
:
""
,
"filter"
:
"colors: ANY("
yellow
")"
"sort_by"
:
""
}
}
To send a request to the Conversational API:
Restore the
conversation_id
from session storage.
Set
mode
to be
CONVERSATIONAL_FILTER_ONLY
.
Set
user_answer
for what the user selects.
Conversational API request
{
query
:
"dress"
co
n
versa
t
io
n
_id
:
"c154d073-87f5-4edb-accd-587eabe014ff"
co
n
versa
t
io
nal
_search_spec
{
"mode"
:
"CONVERSATIONAL_FILTER_ONLY"
user_a
ns
wer
{
selec
te
d_a
ns
wer
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
value
:
"yellow"
}
}
}
}
}
The response from the Conversational API then looks like this:
Conversational API response
{
co
n
versa
t
io
n
_id
:
"c154d073-87f5-4edb-accd-587eabe014ff"
re
f
i
ne
d_query
:
"dress"
co
n
versa
t
io
nal
_
f
il
ter
i
n
g_resul
t
{
addi
t
io
nal
_
f
il
ter
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"colors"
,
value
:
"yellow"
}
}
f
ollowup_ques
t
io
n
{
f
ollowup_ques
t
io
n
:
"What is the occasion?"
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"attribute.occasion"
,
value
:
"wedding"
}
}
sugges
te
d_a
ns
wers
{
produc
t
_a
ttr
ibu
te
_value
{
na
me
:
"attribute.occasion"
,
value
:
"party"
}
}
}
}
}
What you should do with the response:
The Google response is basically identical to the response to the first query, except the
additional_filter
field can be used to check off the filter box for
color = yellow
and should be added to any other filters that the user has selected.
The
additional_filter
should also be added to the filter field event sent to Google for this follow-up query and the follow-up search request. It should be applied in the search request to fetch search products and should also be applied to the conversational search request to fetch the follow-up conversation.
The
refined_query
should be sent to the Search API to fetch more relevant products.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-filtering-ux-guide.txt
Conversational filtering user experience guide  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational filtering user experience guide
Successful implementation of conversational product filtering relies on well-thought-out user experience design.
Visual display elements
The placement and appearance of the conversational filter significantly impact its effectiveness.
Vertical versus horizontal layout
These are some considerations as to whether to design a vertical or horizontal layout:
Recommendation
: Prioritize a horizontally-oriented, vertically compact design. This minimizes the risk of pushing product results below the fold.
Reasoning
: If the filter is displayed horizontally across the top, it can push product results down the page, which increases the cost of the feature by reducing immediate product visibility. Additionally, minimizing blank space between elements can add prime space on the web page for showing additional product tiles.
Handle long attributes
If multiple-choice options are long (such as brand names), don't wrap them to new lines as this adds height to the elements. Instead, allow them to extend horizontally off the page and enable side-scrolling.
Here is an example of a horizontal scroll implementation:
Optimal placement
Consider placing the conversational filter after 3-5 rows of products. This approach prevents the conversational element from displacing the initial list of products.
A key takeaway for this placement is that the conversation filtering bar should be as vertically compact as possible. When the conversational product filtering feature is positioned prominently, it can shift product displays further down the page, out of immediate view. This can be a drawback, as shoppers see fewer products. Therefore, the products that
are visible
must be as relevant as possible.
Side (vertical) versus top (horizontal)
: Consider placing the conversational filter after 3-5 rows of products. This approach prevents the conversational element from displacing the initial list of products.
Strong consideration
: If conversational product filtering becomes your main method for narrowing product selections, consider fully minimizing or replacing your manual filter bar. This can let you add another column of product items.
Desktop and mobile
While desktop implementations have proven successful, results on mobile have been less consistent and have shown lower overall performance gains. The limited screen size on mobile requires a more creative and deliberate approach to placement.
Recommendation
: Prioritize desktop implementations over mobile, at first. The larger screen size on desktop allows for greater flexibility in creative designs. The smaller screen on mobile forces developers to prioritize certain elements.
Avoid
: Chat window interfaces. Don't implement the conversational filter as a chat window. This takes users away from the main web interface and can disrupt the intended web checkout flow design that developers typically spend considerable time optimizing.
Additional mobile considerations
Mobile web and apps should also be treated independently when it comes to testing. Mobile app testing is inherently difficult to conduct, but offers greater flexibility. Mobile web is often quicker to test, but comes with different tradeoffs for various mobile web browsers.
User interaction with filters
This section describes how to configure conversational product filtering.
Replacing static, hard-coded filter elements
with dynamic conversational filtering to liberate screen space for more targeted products is recommended. All applied filters, regardless of their origin, can globally update the product grid.
Subsequent conversational questions adapt to the complete set of applied filters, which offers both multiple-choice options.
Unified global filters
Shoppers can interact with both conversational filters and any remaining filter elements applied. Your frontend implementation must be able to handle this scenario.
Unified global filters have these characteristics:
Global application
: When a user makes a selection from any filter element on the page, whether it is a conversational product filter or static filter element, the product grid must update to show results with
all
global filters applied.
Intelligent follow-up
: The next conversational question the user sees should be relevant based on the complete set of applied filters applies, regardless of which element the user selects. For example, if a shopper selects a
color
filter from the conversational element and a
size
filter from the classic filter element, the subsequent conversational question should not ask the shopper what
size
they want.
Filter types
Conversational product filtering enables the option to use both multiple choice selections on the site.
Multiple choice
Vertex AI Search for commerce can present up to 20 multiple-choice options, based on the value names in the product catalog. Options appear in a sorted list of the most relevant choices. Long options, such as long brand names, help ensure that users can side scroll rather than wrap to new lines, which maintains vertical compactness.
Replace hard-coded elements
Many commerce search site developers have prebuilt, manual category filter components in their web interface that are intended for top revenue-generating queries. These filter components are typically expensive, time-consuming to produce, and not very interactive with the user.
Figure 2
. Example of hard-coded element display.
Recommendation
: The core idea behind conversational filtering lets you quickly deploy dynamic experiences like these across
all
your products, not just for the few top queries that the visual elements were designed for. Therefore, identify and remove elements that conversational filtering is designed to replace. Avoid having two competing sets of filter elements that perform similar functions. This liberates space on the screen to show more targeted products.
Ideas for experimentation
Some ideas for experimentation are:
Placement between product rows
: Insert the component partway down the page, after three to five rows of products. This approach prevents the conversational element from significantly displacing the initial product displays.
Fly-out or pop-up
: Use a button that triggers a dialog or fly-out menu containing the filter questions. This can be integrated with existing filter pop-ups, or a fly-out can be a separate element.
Sticky bar
: A persistent bar on the screen presents the questions and options. This sits in front of the products rather than pushing them down.
Testing considerations
: When testing mobile and desktop, ensure that these experiments are conducted independently. The shopping behaviors for each device vary greatly, and the visual components that work on one device might not translate to the other.
Data ingestion and quality
The Vertex AI model's intelligence is built on user interaction data. The onboarding process uses a two-phased approach to data ingestion.
Phase 1: Initial start with historical events
The model can be trained on historical event data. Historical event data is initially ingested into the Google environment, which allows the model to recognize even new projects with no live interaction data.
Phase 2: Transition to live query data
After the capability is live and starts to collect historically captured data, Vertex AI uses the live query data stream to refine the serving model. The live query data is generally of higher quality than historically captured event data as historical events can sometimes miss key information. This makes live query data more effective for ongoing optimization.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-filtering.txt
Conversational product filtering overview  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational product filtering overview
This page serves as a guide to implement conversational product filtering for Vertex AI Search for commerce. This document provides data-backed best practices to ensure a successful implementation of conversational product filtering for mid-to-large retail businesses.
Vertex AI Search for commerce conversational product filtering is an AI-powered tool that transforms search into a guided experience to accompany shoppers when they interact with large product catalogs. When a site user performs a broad search (like
coffee table
or
red dress)
that returns thousands of results, conversational product filtering intelligently prompts them with follow-up questions to quickly narrow down their options.
Business use case
The conversational product filtering capability in guided search is specifically designed to address broad, ambiguous or very nuanced search queries. Applying filters to narrow the results significantly increases both revenue and user engagement.
The primary goal of conversational product filtering is to help shoppers find the right items quickly and intuitively.
Businesses use conversational filtering to:
Accelerate product discovery
: Help shoppers quickly narrow down vast product selections (such as going from 5,000
area rugs
to a few hundred targeted results) by asking relevant questions.
Refine personalization
: The questions and multiple-choice options are custom for every query, based on historical filter usage data for that specific query (
coffee table
is historically filtered by color more often than size, so color can be asked first).
Simplify implementation
: Questions are predesignated for product attributes such as color and width, with one question per attribute.
One-way conversation
Conversational product filtering operates as a one-way conversation that accompanies the shopper throughout their search journey on an ecommerce site. The AI model asks the shopper a question, and the shopper answers.
The shopper initiates a search query. Example:
area rugs
The retail site returns 80+ pages of product results.
Vertex AI Search for commerce asks the shopper on the site a question to help narrow their search. Example:
Which color are you looking for?
The shopper selects an answer from a list of multiple-choice options. Example:
blue
The product results on the page are immediately filtered based on the shopper's selection.
Search then presents the next most relevant follow-up question. Example:
What shape are you looking for?
Note:
Browse only has the multiple-choice option, while Vertex AI Search has full conversational search capabilities.
Figure 1
. Conversational filtering user journey.
Iterative improvement with testing
Conversational product filtering is optimization that requires continuous refinement and data-driven decisions. The goal is to maximize the feature capability of gathering user insights by understanding shopper behavior and adapting the design to foster user traction.
Influenced by various factors such as market trends, competitor offerings, and changes in personal preferences, shopper behaviors are dynamic and evolve over time. It's important to continue to experiment and iterate on your design, and test new approaches as you gather more data and observe how shoppers interact with the AI features. This ongoing cycle of experimentation, data analysis, and refinement helps to ensure that the AI features remain relevant, effective, and optimized for your evolving user base.
Regularly review performance metrics, conduct user surveys, and analyze feedback to identify areas for improvement and new opportunities for innovation. This commitment to continuous iteration is key to long-term success in AI feature deployment.
Lessons learned
The following lessons learned occur after successive testing:
Experiment continuously
: The optimal result is often not the first design you try.
Iterate and adapt
: User behaviors evolve. Continue to iterate on your designs and test new approaches as you gather more data and observe how shoppers interact with the feature.
Beyond A/B
: Don't limit yourself to just A/B testing, which compares two versions. Instead, conduct many A/B/C/D/E/F tests to explore a wider range of UI designs and placement options.
Key metrics for optimization
To effectively optimize Vertex AI Search for commerce, it's crucial to define and track relevant metrics that provide insights into user engagement, satisfaction, and the overall impact of the features. Key metrics to consider include the following:
Conversion rate
: The percentage of users who complete the targeted action, such as making a purchase.
User satisfaction scores (such as NPS, CSAT)
: Direct feedback from users on their experiences with the AI feature that provides qualitative insights into usability and perceived value.
Adoption rate
: The percentage of shoppers that actively use conversational product filtering that indicates its visibility and perceived utility.
Follow-up questions in search
Note:
The model doesn't answer questions from the shopper. For this functionality, it is recommended to implement
ćonversational commerce
, which is distinct from product filtering capability.
If conversational product filtering is enabled, follow-up questions on the site drive a conversation that ensues until one of the three following scenarios occur:
A preconfigured minimum product count is reached (a conversation is not useful when only two products show up).
The user clicks on a product and adds it to their cart (the objective).
Conversational product filtering runs out of AI-generated questions.
Use as an alternative to dynamic facets
Dynamic facets are associated with broad queries and resulting high search return counts, which leads to low revenue per query. End users can become overwhelmed when they see tens of thousands of results and abandon the search. Conversational search is able to refine queries and can be used with dynamic facets. Conversational product filtering offers some advantages over dynamic facets, being more human, more interactive, and using less on-page real estate.
For more information, refer to the
Facets
page.
Edit generative questions
Conversational product filtering encourages a human-in-the-loop interaction with the generative AI questions by allowing retailers to preliminarily edit, overwrite, or deselect AI-generated questions according to their preferences, based on the uploaded catalog. Questions can be edited or disabled individually or in bulk in the Search for commerce console or the API in order to tailor the questions they want to appear in the search.
Conclusion
The integration of conversational product filtering within your commerce platform provides a way to significantly enhance the user experience and drive a substantial increase in user conversion rates. This is true for broad category queries, where your users often face an overwhelming array of choices and struggle to quickly narrow down their preferences.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/conversational-search.txt
Conversational Commerce agent overview  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Conversational Commerce agent overview
This page describes Vertex AI Search for commerce Conversational Commerce agent, which is a guided search capability. Conversational Commerce agent capability functions as part of the guided search package, providing users with a real-time, ongoing conversational experience that's more interactive.
What is Conversational Commerce agent?
Conversational Commerce agentis an AI-driven guided search and product discovery tool. Instead of
searching with keywords, users utilize natural language to ask for what they need, which includes follow up questions, multimodal interactions, improved intent understanding, and grounding with data beyond the product catalog. This approach enables more intuitive and efficient results filtering, helping users find more precisely and more quickly what they are looking for.
Note:
You can't trigger Conversational Commerce agent from
browse searches
.
Conversational Commerce agent capabilities
Conversational Commerce agent adds to the Vertex AI Search for commerce experience in the following ways:
Narrows user queries effectively
: Conversational Commerce agent filters 10,000 products down to less than 100 products, increasing the likelihood that the user decides to make a purchase.
Hyper-personalization
: Search agents analyze shoppers' preferences, purchase history, and social media activity to provide more personalized product recommendations, promotions, and shopping experiences.
Integrated end-to-end journeys
: From product discovery to checkout, the search agents accompany the end user along their entire shopping journey with immersive, dynamic, and continuous conversation.
Adapted to commerce use case
: Conversational Commerce agent covers ecommerce, product discovery, and support.
Immersive user experiences
: With the help of search agents threading user conversations, augmented and virtual reality can be additionally implemented on the merchant site to create virtual try-ons, store tours, and spatial product visualization.
Impact of Conversational Commerce agent
As a central part of the guided search package, Conversational Commerce agent improves search result relevance and reduces user friction.
Customary commerce search is the most common way to find products. Customary approaches rely on rigid keyword matching, which requires your users to use specific words and manually adjust filters to refine results. However, only
1 in 10 consumers
say that they find exactly what they're looking for when using legacy keyword-based search.
Conversational Commerce agent solves the most frustrating problems for users when searching, such as inexact matches, irrelevant results, or zero-return queries.
Natural language understanding
AI-powered search recognizes full-phrase queries, interprets intent and accounts for variation in language.
Predictive assistance
Helps users formulate queries more effectively by suggesting completions as they type.
Multimodal inputs
Conversational Commerce agent enables users to search using multimodal input methods such as voice and image, in addition to text. It understandings user intent, context and natural language variations in phrasing without losing context.
Voice search
: Spoken queries are often structured differently than typed ones. Vertex AI Search for commerce processes these variations while accounting for variables like accents, background noise and "um's," "uh's" and "like's." For mobile, voice search is not only easier to input, but it can also take up less screen space, allowing more real estate product visuals.
Image search
: Image recognition makes it faster to find a similar or unique item on a social media post or by snapping a picture in real life. Shoppers can then use image search to quickly search and locate a similar item on your site.
Mobile-first experience
Nearly 80% of all ecommerce visits worldwide occurred on a mobile phone in 2024. Smaller screens, shorter user sessions and clustered menus create unique challenges for legacy search experiences. Conversational Commerce agent is designed to enable users to access the full power of AI-driven search from their mobile devices.
The role of external search and AI assistants
When a user has a preferred retailer, they tend to go directly to it. However, when
  exploring new or broader options, the customer user journey is more likely to first start at a
  marketplace orientation, such as Google Search or an AI assistant.
As AI-driven search evolves, the Vertex AI Search for commerce guided search package bridges the gap between external and on-site product discovery. By treating the
  transition to the commerce site as a single, fluid conversation, Conversational Commerce agent ensures users find relevant results quickly.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/create-configs.txt
Create serving configs  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Create serving configs
This page describes how to create serving configs. A serving
configuration is a serving entity that associates a model or a set of controls
that are used to generate your search or recommendation results. For more information about serving configs, see
About serving configs
.
Before you begin
Recommendations and search serving configs
have different requirements and options:
Recommendations serving configs require a model. If you
plan to attach an existing model to a new serving config, get the ID of
the model you plan to use (required when using the
ServingConfig.create
method).
If creating the serving config using the console, you can create a new
model during the creation process instead of attaching an existing model.
You can switch models later, as long as it is of the same model type.
Search can use serving controls, but they are not required. If
you plan to attach existing controls to a new serving config, get the
IDs of the controls you plan to use.
If creating the serving config using the console, you can also create
new controls during the creation process.
You can switch or add serving controls to your serving config after
you create it.
Create a serving config
You can create a serving config using:
The
Search for commerce console
.
The
ServingConfig.create
API
.
Up to 100 serving configs are allowed per catalog.
Search works with non-configured serving configs. Any
serving_config_id
can be
placed as part of the search request, and this
default_search
will search the
catalog with Vertex AI Search for commerce default search capability.
If you have existing placements, or create new placements,
a serving config associated with each placement is automatically created.
Creating a serving config does not create a corresponding placement. Deleting a
serving config deletes its corresponding placement, and deleting a placement
deletes its corresponding serving config.
Create a serving config in the console
Add a new serving config on the
Serving Configs page
in the
Search for commerce console.
To create a new serving config:
Go to the
Serving Configs
page in the Search for commerce console.
Go to the Serving configs page
Click
add_box
Create serving config
.
Recommendations
Select
Recommendation
as the product the serving config
will be used for.
Provide a name for your serving config.
The name must be 1024 characters or less, and can contain only
alphanumeric characters, underscores, hyphens, and spaces.
Optional: If needed, update the ID.
The ID is generated from the name you provide, and must be unique
across your project. It must be 50 characters or less, and cannot
contain spaces.
Choose or create a model you want this serving config to
provide recommendations for.
Learn more
about creating new models.
Select how much price reranking should affect recommendation results,
if available for the model you selected.
Price reranking causes recommended products with a similar
recommendation probability to be ordered by price, with the
highest-priced items first. Relevance is still also used to order
items, so enabling price reranking is not the same as sorting by
price.
Select whether to use rule-based or data-driven result diversification:
Ruled-based:
Ruled-based result diversification affects whether
results returned from a single prediction request are from
different categories of your product catalog.
Data-driven:
Data-driven result diversification uses machine learning
to balance category diversity and relevance in your prediction
results.
For more information, see
Result diversification
.
Select how much to diversify recommendation results.
If you selected a Similar Items model for this serving config, select
whether to enable category matching.
When category matching is enabled, the only product results returned
are ones that share at least one category with the context product.
Category matching can be used in combination with other filtering
options, such as price, availability, and filter tags.
Search
On the
Create Serving Config
page, choose
Search
as the product the serving configuration
will be used for.
Provide a name for your serving configuration.
The name must be
1024 characters or less, and can contain only alphanumeric characters,
underscores, hyphens, and spaces.
Optional: If needed, update the ID.
The ID is generated from the
name you provide, and must be unique across your project. It must be 50
characters or less, and cannot contain spaces.
Click
Continue
.
Choose whether to enable dynamic faceting for this serving configuration.
Choose or create serving controls to optimize your searches with.
For more
information on controls, see
Creating and managing controls.
Click
Create
to create the new configuration.
The new configuration appears in your
Serving Configs page
.
It might take a few minutes for the configuration to become available for use
in search requests. It is immediately available for recommendations.
Optional: On the Serving Configs page, click a serving config name
and go to its
Evaluate
tab to preview the products that would be returned
for this configuration.
Evaluation preview can help you to confirm that your configuration is
performing as you expect.
Create a serving config with
ServingConfig.create
You can create a serving config with the
ServingConfig.create
API
method. For API reference documentation for this method, see
ServingConfig.create
.
Which fields you use depend on if you're creating a serving config for
recommendations or search.
For more details about the
ServingConfig
fields, see the
ServingConfigs
API reference
.
Recommendations
Make a
ServingConfig.create
request with a serving config ID and an
instance of
ServingConfig
contained in the request body.
servingConfigId
: Required. Creates an ID for your
ServingConfig
. This
value should be 4-63 characters. Valid characters are
/[a-z][0-9]-_/
.
displayName
: Required. The human readable
ServingConfig
name displayed
in the Search for commerce console.
modelID
: Required. The ID of the model to use at serving time.
priceRerankingLevel
: Optional. Sets how much price reranking should
affect recommendation results. Allowed values are
no-price-reranking
(default value if unset),
low-price-raranking
,
medium-price-reranking
,
and
high-price-reranking
.
diversityLevel
: Optional. Sets how much to diversify recommendations
results. Allowed values are
no-diversity
(default),
low-diversity
,
medium-diversity
,
high-diversity
, and
auto-diversity
. If
diversityLevel
is not set, then diversity is disabled.
diversityType
: Optional. Set to
RULE_BASED_DIVERSITY
to diversify
recommendation results based on product category. Set to
DATA_DRIVEN_DIVERSITY
to diversify recommendations based on learning
from product metadata to balances relevance and category diversity.
If
diversityLevel
is set but
diversityType
is not set, then
diversityType
defaults to rule-based. For more information, see
result diversification
.
enableCategoryFilterLevel
: Optional. Sets whether to add additional
category filters on the Similar Items model. Allowed values are
relaxed-category-match
(default value if unset) and
no-category-match
.
solutionTypes
: Required. Set to
SOLUTION_TYPE_RECOMMENDATION
for
recommendations serving configs.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"modelId": "
MODEL_ID
",
"priceRerankingLevel": "
PRICE_RERANKING_LEVEL
",
"diversityType": "
DIVERSITY_TYPE
",
"diversityLevel": "
DIVERSITY_LEVEL
",
"enableCategoryFilterLevel": "
CATEGORY_FILTER_LEVEL
",
"solutionTypes": [ "SOLUTION_TYPE_RECOMMENDATION" ]
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs?servingConfigId=
SERVING_CONFIG_ID
"
Search
Make a
ServingConfig.create
request with a serving config ID and an
instance of
ServingConfig
contained in the request body.
servingConfigId
: Required. Creates an ID for your
ServingConfig
. This
value should be 4-63 characters. Valid characters are
/[a-z][0-9]-_/
.
displayName
: Required. The human readable
ServingConfig
name displayed
in the Search for commerce console.
facetControlIds
: Optional. IDs of controls that have only
FacetSpec
set.
dynamicFacetSpec.mode
: Optional. Mode of the
DynamicFacet
feature.
Allowed values are
DISABLED
(default if unset) and
ENABLED
.
boostControlIds
: Optional. IDs of boost serving controls.
filterControlIds
: Optional. IDs of filter serving controls.
redirectControlIds
: Optional. IDs of redirect serving controls.
twowaySynonymsControlIds
: Optional. IDs of two-way synonym serving
controls.
onewaySynonymsControlIds
: Optional. IDs of one-way synonym serving
controls.
doNotAssociateControlIds
: Optional. IDs of do-not-associate serving
controls.
replacementControlIds
: Optional. IDs of replacement serving controls.
ignoreControlIds
: Optional. IDs of ignore serving controls.
solutionTypes
: Required. Set to
SOLUTION_TYPE_SEARCH
for
search serving configs.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName":
DISPLAY_NAME
,
"facetControlIds": [
"
FACET_CONTROL_ID_1
",
"
FACET_CONTROL_ID_2
"
],
"dynamicFacetSpec": {
"mode": "
DYNAMIC_FACET_MODE
"
},
"boostControlIds": [
"
BOOST_CONTROL_ID_1
",
"
BOOST_CONTROL_ID_2
"
],
"filterControlIds": [
"
FILTER_CONTROL_ID_1
",
"
FILTER_CONTROL_ID_2
"
],
"redirectControlIds": [
"
REDIRECT_CONTROL_ID_1
",
"
REDIRECT_CONTROL_ID_2
"
],
"twowaySynonymsControlIds": [
"
TWO_WAY_SYNONYM_CONTROL_ID_1
",
"
TWO_WAY_SYNONYM_CONTROL_ID_2
"
],
"onewaySynonymsControlIds": [
"
ONE_WAY_SYNONYM_CONTROL_ID_1
",
"
ONE_WAY_SYNONYM_CONTROL_ID_2
"
],
"doNotAssociateControlIds": [
"
DO_NOT_ASSOCIATE_CONTROL_ID_1
",
"
DO_NOT_ASSOCIATE_CONTROL_ID_2
"
],
"replacementControlIds": [
"
REPLACEMENT_CONTROL_ID_1
",
"
REPLACEMENT_CONTROL_ID_2
"
],
"ignoreControlIds": [
"
IGNORE_CONTROL_ID_1
",
"
IGNORE_CONTROL_ID_2
"
],
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ]
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs?servingConfigId=
SERVING_CONFIG_ID
"
Next steps
Request predictions
from your new placement.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/create-controls.txt
Create serving controls  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Create serving controls
This page describes how to create serving controls.
Serving controls are rules that you define and apply to individual
serving configs.
You can create a serving control in the Search for commerce console
consisting of a condition, which triggers the control, and an action that takes
place when the condition triggers. You can then attach the new serving control
to a serving configuration.
Relationship between serving controls and configs
Serving configs have a multi-to-multi relationship with controls. You can
add multiple controls to a serving config, and a single control can be
associated with multiple serving configs.
When you create serving controls and serving configs, you select a
product (recommendations or search) that the control can be used for.
Serving controls can be associated only with serving configs
of the same product type. For example, a serving control created for
recommendations can't be associated with a serving config
that was created for search.
Serving configs manage which controls are applied during a search or
prediction request. Only the controls on the active serving config for a
request are considered at serving time. For example, suppose you have created
two controls: a control called
gShoe Sale
that boosts results for the brand
gShoe when
shoes
is searched for and a control called
More shoes
that
expands queries using the term
running shoes
to include
sport shoes.
If you
attach only the
gShoe Sale
control to a serving config, then search requests
using that serving config boosts gShoe results for queries using the term
shoes,
but the
More shoes
control has no effect because it is not
attached to the serving config you are using.
For more information, refer to
About serving configs
.
Quickstart videos and guides
Introduction to serving controls
: Serving controls enable you to create rules that customize how your serving configurations return search results.
Boost/bury
: Affects result ranking and order in the returned result list.
Available for search and recommendations.
Filter
: Removes results that do not pass the filter from the returned
result list. Available for search only.
Redirect
: Redirects your users to a specific page depending on
the search query. Available for search only.
This tutorial shows you to how to use the redirect control.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Linguistic
: Customizes search query linguistics. Available for
search only.
Several types of linguistic controls are
available:
Synonym
: Expands considered synonyms for a search query.
One-way synonym
: Expands considered synonyms unidirectionally for
specific terms.
Do not associate
: Prevent a group of terms from being used in search
when specific terms appear.
Ignore
: Prevent a term from being used in searches.
Replacement
: Replaces terms in the search query.
Pinning
: Affects result ordering, placing a result at a specific position — for example, at position 4. Available for search and browse.
For examples of these controls, see
About serving controls
.
Note:
Creating chaining or conflicting controls is not recommended.
Vertex AI Search for commerce doesn't support running controls in a predetermined
order.
Serving control configuration options
You can create controls and then add or swap them into a live serving
configuration.
You can create up to 100 serving controls. If you need more serving controls,
request additional quota. For how to request additional quota, see
Increase your quotas
. A serving config can have up to
100 serving controls of any type besides redirect controls, whose limit is 1000
per serving config.
Note:
There is a five-minute delay from when a control is attached to ready for use in serving. The preview page and search requests will reflect this delay.
You can create a serving control in these ways:
On the
Controls page
in the
Google Cloud console: Here, you can optionally create controls
during the
serving config creation
process.
You can use the
Merchandising console
.
You can create a serving control inline, using the
Controls.create
method.
Use the Google Cloud console
To use the Google Cloud console to create serving controls:
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
Follow the Google Cloud console steps under
each serving control section
.
Use the Merchandising console
The Merchandising console is a tool designed for merchandisers to create and administer controls. It provides an approval flow so that every control can be proposed by all merchandisers and reviewed by merchandisers approvers.
The Merchandising console helps
create serving controls
such as pinning, boost/bury, synonyms and facets. The Merchandising console features a user-friendly interface that enables merchandisers to efficiently create and manage controls. This tool also facilitates an approval process, allowing any merchandiser to propose controls and merchandiser approvers to review them.
In Google Cloud, to access the Merchandising console tab, you must have at a minimum the following permissions:
Project Viewer (Viewer)
: To access the project.
Retail Editor
: To edit and save Merchandising console settings.
Use the console as an administrator
Before you start, you must be a Google Cloud administrator to onboard users to the Merchandising console.
Then, initialize the Merchandising console by accessing the Merchandising console tab within the Google Cloud console:
Merchandising console tab
You need these IAM roles to access, edit, and assign
Creator
or
Approver
roles to a Merchandising console user:
To edit the Merchandising console, at least the
Retail Editor
role is required.
To assign
Creator
or
Approver
roles to a user, a
project-level IAM admin
role is required.
Note:
A
Retail Editor
with such
IAM Admin
role won't be able to self-promote to a higher access privilege.
For a complete layout of IAM project-level and Vertex AI Search for commerce permissions, refer to the [Predefined administrator roles](/retail/docs/iam#roles) section in this [Vertex AI Search for commerce product](/retail/docs/iam) documentation.
Onboard Merchandising console users
If you're a Google Cloud console administrator, to give site merchandisers access to the Merchandising console and assign either a
Creator
or an
Approver
role to them:
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
Navigate to the
Merchandising console
tab.
ou can see the unique URL to the Merchandising console associated with the current Google Cloud project. Copy the link or directly open it in the Google Cloud console.
Select the default serving config merchandisers will use to
Preview
and
Attach
approved controls.
Give users either
Approver
or
Creator
roles.
You can see the unique URL to the Merchandising console associated with the
      current Google Cloud project. Copy the link or directly open it in the
      Google Cloud console.
Select the default serving config for
Preview
in the
Merchandising
console.
(Optional) Edit access to the Merchandising console using these functions:
Add users
: Give users
Approver
or
Creator
access to the
Merchandising console
.
Delete users
: Revoke access to the Merchandising console by
      deleting
Approvers
or
Creators
.
Add approver emails. For each control submitted by merchandisers, the approver emails list will receive an email to review and approve this control.
Access the console as a user
If you have been given access with the URL, you have the option of using the Merchandising console instead of the standard Google Cloud console.
      To create controls using the Merchandising console:
Sign in using the credentials that your administrator provides you.
Follow the Merchandising console documentation steps under
each serving control section
.
After submission, you receive a notification email with the subject
[Merchant Console] Proposed control awaiting review
.
As an
Approver,
you can
accept,
deny,
or
change
the control request.
Use the console as a site merchandiser
Follow these steps to get started in the Merchandising console as a site merchandiser.
Set approval flow for questions.
Navigate to the
settings
Settings
part of the main menu.
By default, a predefined list of questions are set in
Define the goal
screen.
Merchandising console questions
Add a question by clicking
add_box
Add question
to help
Approvers
understand the purpose of the new controls.
Click
Save
to save the questions.
Create a control
.
Go to the
Controls
section.
Click
add_box
Create control
.
Define the goal
: All questions previously defined are required to be answered. If you haven't defined any questions yet, this screen won't appear.
Select a control
. Specify the
control type
and assign a name to the control.
Set rules
: For each rule, you can define triggers and actions.
Define
Triggers
: The goal is to establish when to apply this control.
Query terms
: This rule can be triggered when your search query contains or exactly matches specific terms. You can define these query terms.
Applicable time ranges
: Time restrictions can be applied to confine the activation of this rule to specific time periods.
Define triggers
Define actions
: Depending on the type of control, you can define actions, such as Item ID and position for a pinning control.
Preview a rule
: A dynamic preview of the rule can be seen on the screen.
Submit a rule
: After you click
Submit
to submit the rule set by the merchandiser, you can view the control as
Pending
in the controls list.
Approve a control
To grant approval for a control, click the
more_vert
More
icon next to the control in the control list. Select
Review
.
A screen is provided for the given control where you can
Approve,
Deny,
or
Approve with edits
.
After approval, you are redirected to the controls list page that shows the control as
Approved
.
Merchandising console stages
Control types
Controls have different requirements depending on their type. Go to the creation
procedure for the control type you plan to create:
Create a boost/bury control
Create a filter control
Create a redirect control
Create a pinning control
Create a two-way synonym control
Create a one-way synonym control
Create a do-not-associate control
Create an ignore control
Create a replacement control
Create a boost/bury control
This control type is available for search and
recommendations.
Create a search boost/bury control
Create a recommendations boost/bury control
See
Boost/bury controls
for more about this control type.
Create a search boost/bury control
To create a search boost/bury control:
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Boost/Bury
.
Configure your
Boost/Bury
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Boost/Bury actions
you want to trigger with this control.
These actions are defined by a
Catalog attribute
such as
colors
, a
Criteria
such as
contains,
and
Value
such as
red.
Click
add_box
Add attribute
to add more
attributes.
Use the slider to set your
Boost/bury value
. Negative numbers are
bury, and positive numbers are boost.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Boost/bury
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
Under the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a
name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
In the
Product selection
section, select
Search
.
Choose
Boost/bury controls
as the control type. Click
Continue
In the
Triggers
section, select what type of user behavior triggers
this control.
Browse categories
: The rule is triggered when a user browses
categories on your site (
search.request.query
is
empty).
Search
: The rule is triggered when a user searches on your site
(
search.request.query
isn't empty). To set this
control to trigger when any category
is browsed, or any query is searched for, skip the following step.
Optional: Set specific categories or queries that can trigger this
control depending on whether a specific category is browsed or a specific
query is searched for.
If you chose
Browse categories
: In the
Categories
field, enter
which categories will trigger this control when browsed.
If you chose
Search
: Click the
Add query
button to add query
terms (for example,
running shoes
) to be filtered. For each term, choose either
Partial match
or
Full match
.
Note:
If you specify a category or query term condition in addition to a time
range conditions, the control is applied only when both conditions are
met.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Note:
If you specify time range conditions in addition to this type of
condition, the control is applied only if both conditions are met.
Click
Continue
to proceed to the
Actions
section.
Add filters for product attributes in the
Boost/bury product
field.
Use the filter expression syntax documented in
Filtering and
ordering
. For example, to specify red and blue versions of
"product1" and "product2":
(id: ANY("product1","product2")) AND
(colorFamily: ANY("Red","Blue"))
For
Boost/bury value
, use the slider to set the strength of the
boost. Positive values boost the results, and negative values bury
them. Click
Continue
.
In the
Serving configs
section, select which serving configs to apply
the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can now find the new control listed on the
Serving controls
tab of
the
Controls
page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
A boost/bury control can be triggered when a user browses categories on your
site (
search.request.query
is empty), or when a user
searches on your site (
search.request.query
isn't empty).
The following example shows fields for a browse-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_BROWSE
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_BROWSE"
],
"rule": {
"condition": {
"pageCategories": [
"
CATEGORY_ABC
",
"
CATEGORY_XYZ
"
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"boostAction": {
"boost":
BOOST_NUMBER
,
"productsFilter": "
FILTER_EXPRESSION
"
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
The following example shows fields for a search-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_SEARCH
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_SEARCH"
],
"rule": {
"condition": {
"queryTerms": [
{
"value": "
VALUE_1
",
"fullMatch": "
FULLMATCH_BOOLEAN_1
"
},
{
"value": "
VALUE_2
",
"fullMatch": "
FULLMATCH_BOOLEAN_2
"
}
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"boostAction": {
"boost":
BOOST_NUMBER
,
"productsFilter": "
FILTER_EXPRESSION
"
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a recommendations boost/bury control
Preview
This feature is
        
        subject to the "Pre-GA Offerings Terms" in the General Service Terms section of the
Service Specific
        Terms
.
        
        Pre-GA features are available "as is" and might have limited support.
      
      For more information, see the
launch stage descriptions
.
To create a recommendations boost/bury control:
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
(Optional) To change the automatically created control ID, click
Edit
and enter a new control ID.
In the
Product selection
section, select
Recommendation
.
Choose
Boost/bury controls
as the control type.
Click
Continue
to proceed to the
Actions
section.
Add filters for product attributes in the
Boost/bury product
field.
Use the filter expression syntax documented in
Filter recommendations
.
For example, to specify red and blue versions of "product1" and
"product2":
(id: ANY("product1","product2")) AND (colorFamily: ANY("Red","Blue"))
For
Boost/bury value
, use the slider to set the strength of the
boost. Positive values boost the results, and negative values bury
them.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls
page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
To create a filter expression, use the filter expression syntax documented
in
Filter recommendations
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_RECOMMENDATION" ],
"boostAction": {
"boost":
BOOST_NUMBER
,
"productsFilter": "
FILTER_EXPRESSION
"
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a filter control
See
Filter controls
for more about this control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
or
Browse
product, then choose the control type
Filter
.
Configure your
Filter
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query or page category, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Filter actions
you want to trigger with this control.
These actions are defined by a
Catalog attribute
such as
colors
, a
Criteria
such as
contains,
and
Value
such as
red.
Click
add_box
Add attribute
to add more
attributes.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Filter
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Filter controls
as the control type.
Click continue to proceed to the
Triggers
section.
Select what type of user behavior triggers this control:
Browse categories
: The rule is triggered when a user browses
categories on your site (
search.request.query
is
empty).
Search
: The rule is triggered when a user searches on your site
(
search.request.query
isn't empty).
Optional: Set a control condition that triggers the rule based on what
category is browsed, or what query is searched for. The available option
depends on if you chose
Browse categories
or
Search
:
If you chose
Browse categories
: In the
Categories
field, enter
which categories will trigger this control when browsed.
If you chose
Search
: Click the
Add query
button to add query
terms (for example,
running shoes
) to be filtered, and
select one of the following for each term:
Partial match
: This control applies when a query contains a
partial match to this query term.
Full match
: This control applies only when a query contains a
full match to this query term.
When one of these terms is included in a query, the control is applied.
Note:
If you specify a time range condition in addition to this condition, the
control is applied only if both conditions are met.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Note:
If you specify a category or query term condition in addition to this
time range condition, the control is applied only when both conditions
are met.
Click
Continue
to proceed to the
Actions
section.
Add filters for product attributes in the
Filter action
field.
Use the filter expression syntax documented in
Filtering and ordering
.
For example, to specify red and blue versions of "product1" and
"product2":
(id: ANY("product1","product2")) AND (colorFamily: ANY("Red","Blue"))
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls
page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
A filter control can be triggered when a user browses categories on your
site (
search.request.query
is empty), or when a user
searches on your site (
search.request.query
isn't empty).
The following example shows fields for a browse-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_BROWSE
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_BROWSE"
],
"rule": {
"condition": {
"pageCategories": [
"
CATEGORY_ABC
",
"
CATEGORY_XYZ
"
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"filterAction": {
"filter": "
FILTER_EXPRESSION
"
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
The following example shows fields for a search-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_SEARCH
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_SEARCH"
],
"rule": {
"condition": {
"pageCategories": [
"
CATEGORY_ABC
",
"
CATEGORY_XYZ
"
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"filterAction": {
"filter": "
FILTER_EXPRESSION
"
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a redirect control
See
Redirect controls
for more about this control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Redirect
.
Configure your
Redirect
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Redirect actions
you want to trigger with this control by entering the redirect URL.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Redirect
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Redirect controls
as the control type.
Click continue to proceed to the
Triggers
section.
Create at least one query term or time range
trigger. Redirect controls require at least one trigger:
Select what type of user behavior triggers this control:
Browse categories
: The rule is triggered when a user browses
categories on your site (
search.request.query
is
empty).
Search
: The rule is triggered when a user searches on your site
(
search.request.query
isn't empty).
Set a control condition that triggers the rule based on what
category is browsed, or what query is searched for. The available option
depends on if you chose
Browse categories
or
Search
:
If you chose
Browse categories
: In the
Categories
field, enter
which categories will trigger this control when browsed.
If you chose
Search
: Click the
Add query
button to add query
terms (for example,
running shoes
) to be filtered, and
select one of the following for each term:
Partial match
: This control applies when a query contains a
partial match to this query term.
Full match
: This control applies only when a query contains a
full match to this query term.
When one of these terms is included in a query, the control is applied.
Note:
If you specify a time range condition in addition to this condition, the
control is applied only if both conditions are met.
Click the
Add Time Range
button to add one or more time ranges during
which this control can be applied.
Note:
If you specify a category or query term condition in addition to this
time range condition, the control is applied only when both conditions
are met.
Click
Continue
to proceed to the
Actions
section.
Enter the URI to redirect to when this control is triggered.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
A redirect control can be triggered when a user browses categories on your
site (
search.request.query
is empty), or when a user
searches on your site (
search.request.query
isn't empty).
The following example shows fields for a browse-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_BROWSE
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_BROWSE"
],
"rule": {
"condition": {
"queryTerms": [
{
"value": "
VALUE_1
",
"fullMatch": "
FULLMATCH_BOOLEAN_1
"
},
{
"value": "
VALUE_2
",
"fullMatch": "
FULLMATCH_BOOLEAN_2
"
}
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"redirectAction": {
"redirectUri": "
REDIRECT_URI
",
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
The following example shows fields for a search-triggered control, where
searchSolutionUseCase
is set to
SEARCH_SOLUTION_USE_CASE_SEARCH
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"searchSolutionUseCase": [
"SEARCH_SOLUTION_USE_CASE_SEARCH"
],
"rule": {
"condition": {
"queryTerms": [
{
"value": "
VALUE_1
",
"fullMatch": "
FULLMATCH_BOOLEAN_1
"
},
{
"value": "
VALUE_2
",
"fullMatch": "
FULLMATCH_BOOLEAN_2
"
}
],
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"redirectAction": {
"redirectUri": "
REDIRECT_URI
",
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a two-way synonym control
See
Two-way synonym controls
for more about this
control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Synonyms
.
Configure your
Two-way synonym
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Synonym type
you want to trigger with this control. Select
Two-way
. See the section on
Synonyms
for more information on synonym types.
Click
Submit
. This takes you to a detailed
Two-way synonym
configuration screen.
Enter the synonyms in the field under
Two-way synonym actions
. This action links terms together bidirectionally to be treated the same in search results, so that a red sofa query results in red maroon sofa but maroon sofa queries are expanded to include all types of red sofas, such as crimson or pink.
Submit
again to send your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Two-way synonym
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
In the
Control name
field, enter a name for your new control.
The
Create control
pane opens.
You will be in the
Preferences
section.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Two-way synonym control
as the control type.
Click continue to proceed to the
Triggers
section.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Click
Continue
to proceed to the
Actions
section.
In the
Synonyms
field, enter 2 to 100 query terms (for example,
shirt
and
top
) that should be synonyms of each other.
When any one of these terms is included in a query, search
considers the other query terms as synonyms of the included term.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"rule": {
"condition": {
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"twoWaySynonymAction": {
"synonyms": [
"
SYNONYM_1
",
"
SYNONYM_2
"
]
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method. See
Add controls to serving configs inline
.
Create a one-way synonym control
See
One-way synonym controls
for more about this control
type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Synonyms
.
Configure your
One-way synonym
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Synonym type
you want to trigger with this control. Select
One-way
. See the section on
Synonyms
for more information on synonym types.
Click
Submit
. This takes you to a detailed
One-way synonym
configuration screen.
Enter your synonyms in the field under
One-way synonym actions
. This action links terms together unidirectionally to be treated the same in search results, so that a red sofa query includes maroon sofas, but a maroon sofa query does not return other types of red sofas, restricting the results to only maroon sofas.
Click
Submit
again to send your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
One-way synonym
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
One-way synonym control
as the control type.
Click continue to proceed to the
Triggers
section.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Click
Continue
to proceed to the
Actions
section.
In the
Query terms
field, enter terms (for example,
shoes
) that
should have synonyms associated with them when any of them is included in
a query.
In the
Synonyms
field, enter terms that should be used as synonyms
for the query terms you specified (for example,
sneakers
and
sandals
as one-way synonyms for the query term
shoes
).
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"rule": {
"condition": {
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"oneWaySynonymAction": {
"synonyms": [
"queryTerms": [
"
QUERY_TERM_1
",
"
QUERY_TERM_2
"
],
"synonyms": [
"
SYNONYM_1
",
"
SYNONYM_2
"
]
]
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a do-not-associate control
See
Do-not-associate controls
for more about this
control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Do not associate
.
Configure your
Do-not-associate
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Under
Do not associate actions,
specify the terms that should not be associated with the query terms you entered in the previous
Triggers
section. Enter them into the query terms and disassociated terms fields, respectively.
Click
Submit
to send your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Do-not-associate
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Do not associate control
as the control type.
Click continue to proceed to the
Triggers
section.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Click
Continue
to proceed to the
Actions
section.
In the
Query terms
field, enter terms (for example,
gShoe
)
that you want to explicitly disambiguate from others.
In the
Dissociated terms
field, enter terms that to be disassociated from search results with the query terms you have specified.
For example, you can dissociate the query term
gShoe
from the term
cheap
.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"rule": {
"condition": {
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"doNotAssociateAction": {
"queryTerms": [
"
QUERY_TERM_1
",
"
QUERY_TERM_2
"
],
"doNotAssociateTerms": [
"
DISSOCIATED_TERM_1
",
"
DISSOCIATED_TERM_2
"
]
]
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create an ignore control
See
Ignore controls
for more about this control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Ignore
.
Configure your
Ignore
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Enter the terms you want to have ignored under
Ignore actions
.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for an
Ignore
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Do not associate control
as the control type.
Click continue to proceed to the
Triggers
section.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Click
Continue
to proceed to the
Actions
section.
In the
Ignore terms
field, enter terms (for example,
shoddy
) that
you want a search to ignore when they are entered as query terms.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"rule": {
"condition": {
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"ignoreAction": {
"ignoreTerms": [
"
IGNORE_TERM_1
",
"
IGNORE_TERM_2
"
]
]
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a replacement control
See
Replacement controls
for more about this control type.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Replacement
.
Configure your
Replacement
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Under
Replacement actions,
define the query terms you want replaced in the first field, and their substitutes in the second field.
Click
Submit
to send your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Replacement
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Preferences
section, in the
Control name
field, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
Choose
Replacement control
as the control type.
Click continue to proceed to the
Triggers
section.
Optional: Click the
Add Time Range
button to add one or more
time ranges during which this control can be applied.
Click
Continue
to proceed to the
Actions
section.
In the
Query terms
field, enter query terms (for example,
gShoe
) that you want to have replaced by the replacement term.
In the
Replacement term
field, enter the term that should replace the
query terms you specified.
For example, you can replace the query term
gShoe
with the replacement
term
Google Shoe
.
Click
Continue
to proceed to the
Serving configs
section.
Select which serving configs to apply the control to.
Submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"displayName": "
DISPLAY_NAME
",
"solutionTypes": [ "SOLUTION_TYPE_SEARCH" ],
"rule": {
"condition": {
"activeTimeRange": [
{
"startTime": "
START_TIMESTAMP_1
",
"endTime": "
END_TIMESTAMP_1
"
},
{
"startTime": "
START_TIMESTAMP_2
",
"endTime": "
END_TIMESTAMP_2
"
}
]
},
"replacementAction": {
"queryTerms": [
"
QUERY_TERM_1
",
"
QUERY_TERM_2
"
],
"replacementTerm": "
REPLACEMENT_TERM
"
}
}
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Create a pinning control
To create a pinning control:
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Pinning
.
Configure your
Pinning
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Pinning actions
you want to trigger with this control.
These actions are defined by
Product ID
and the pin position, preferably a number less than 120 (the typical page size). You can click
add_box
Add product
and add up to 10.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request for a
Pinning
control.
Cloud console
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
In the
Control name
field of the
Preferences
section, enter a name for your new control.
Optional: To change the automatically created control ID, click
Edit
and enter a new control ID.
In the
Product selection
section, select
Search or Browse
.
Choose
Pinning control
as the control type. Click
Continue
.
In the
Triggers
section, choose the user behavior that triggers this control:
Browse categories
: Browse requests are required to have the
page_categories
field populated in addition to the
search.request.query
being empty.
Search
: Search requests require only the
search.request.query
to be populated.
By default, all categories browsed and queries searched trigger this control.
Optional: Set a condition that triggers the rule based on a particular
category browsed or query searched for:
Browse categories
: In the
Categories
field, enter which
categories trigger the control.
Search
: To add query terms to be filtered (for example,
running shoes
),
click
Add query
. For each term, choose
Partial match
or
Full match
.
Optional: Click
Add Time Range
or
Add Date Range
to add one or more time ranges during which this control can be applied.
Note:
If you specify a category or query term plus time- or date-range conditions, the control is applied only if both types of conditions are met.
Click
Continue
to proceed to the
Actions
section. For
Pin location
, use the slider to specify which position the products are to be pinned to. The pin value slider won't  accept values of 0, negative numbers, or non-integers.
Vertex AI Search for commerce allows 10 pins in the pin map of any single control. The position can be any value between 1 and 120 (the maximum request page size).
Note:
Pins to the second page are not honored if the position is greater than the request page size. For example, if a search query requests a page size of 50 but you have set a pin to page 75, the search item will be ignored in the results.
Click
Continue
to proceed to the
Serving configs
section. Select which serving configs to apply the control to, and submit your control settings.
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page.
You can find the new control listed on the
Serving controls
tab of the
Controls
page.
curl
Make a
Control.create
request with a control ID and an
instance of
Control
contained in the request body.
For field details, see the
Controls
API reference
and the
Controls.create
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
--data
'{
"displayName": "
DisplayName
",
"solutionTypes": "SOLUTION_TYPE_SEARCH",
"searchSolutionUseCase": ["
SEARCH_SOLUTION_USE_CASE_SEARCH
"],
"rule": {
"condition": {
"queryTerms": [
{
"value": "
Term1
",
"fullMatch": "
boolean: true / false
"
},
{
"value": "
Term2
",
"fullMatch": "
boolean: true / false
"
},
],
"activeTimeRange": [
{
"startTime":
timestamp1
,
"endTime":
timestamp2
},
{
"startTime":
timestamp3
,
"endTime":
timestamp4
}
]
},
"pinAction": {
"pinMap" :  {
"
pin_position1
": "
product_id
",
"
pin_position2
": "
product_id
>"
}
}
}
}'
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_NUMBER
/locations/
LOCATION
/catalogs/default_catalog/controls?controlId=
CONTROL_ID
"
The
pin_position
should be an integer between [1,10]  inclusive and
product_id
must exist in your catalog. The maximum number of allowed elements in the pin map is 10 for each control.
Next, attach the pinning control to your serving config:
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
-d
'{
"controlId": "
CONTROL_ID
"
}'
\
'https://retail.googleapis.com/v2alpha/projects/
PROJECT_NUMBER
/locations/
LOCATION
/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
:addControl'
In this case,
CONTROL_ID
should be the pinning control
id
you created previously.
To add a control to a serving config, use the
ServingConfig.addControl
method:
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Finally, to test your setup, make a search request. To make sure that a request will have the pinning control applied successfully, use query terms (in search) or page categories (in browse) that match the terms/categories provided in the control you created in the preceding steps.
Cloud console
Go to the
Evaluate
page in the Search for commerce console.
Go to the Evaluate page
Go to the
Search
tab.
Enter a test query in the search query field.
Click
Search preview
.
View the results to ensure that your chosen products are pinned.
curl
curl
-s
-X
POST
-H
"Authorization: Bearer
"
-H
"Content-Type: application/json"
--data
"{'query': '
','visitorId': '
'}"
\
"https://retail.googleapis.com/v2/projects/PROJECT/locations/global/catalogs/CATALOG/placements/default_search:search"
Constraints for error checking
For error checking, keep these constraints in mind:
Two products cannot be pinned to the same position, that is, products "a" and "b" cannot both occupy position #2.
Conversely, one product cannot be pinned to more than one location, that is, product "a" cannot be pinned to positions #2 and #3 at the same time for the same query.
The
product_id
must exist as a product in the catalog, assuming that no filters or sorting are applied.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/create-models.txt
Create recommendation models  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Create recommendation models
This page describes how to create a new recommendations model.
Note:
You don't need to manually configure or create models for
search.
If you already have a recommendation model of the correct
type
and you want to get predictions from it from a different location in your site,
you can create a new serving config for it rather than creating a
new model.
Learn more
.
Introduction
When you want to use a new recommendation type for getting predictions, you
must create a new recommendation model and provide sufficient user event data
for it to be trained. You create serving configs for your new model, and
when the model has finished training, request predictions from those serving
configurations.
For an overview of the process of working with Vertex AI Search for commerce, see
Implement Vertex AI Search for commerce
.
Create a recommendation model
Add a new recommendation model by using the
Search for commerce
console
or the
models.Create
API method
.
You can have up to 20 models per project, and up to 10 of them can be active
(not paused) at any time. Learn more about
pausing a model
.
You can start up to five model operations per minute. Limited model operations
include creation, deletion, pause, and resume.
Before you create a new model:
Review and choose from the available
recommendation model types
and
model business objectives
. These determine what
kind of recommendations this model should be trained to provide.
Decide how often to
tune the model
. For tuning and training cost
details, see
Pricing
.
Make sure you have enough data uploaded to meet
requirements for creating a new model
. Some requirements depend
on the model type you choose.
If you plan to create a Page-Level Optimization model:
Check that you already have recommendation serving configs that have trained
models attached to them. You must provide a selection of recommendation
serving configs that Page-Level Optimization can choose from when optimizing a page's
recommendations.
Set up event recording for
detail-page-view
events and events that match
the page type you will deploy the Page-Level Optimization model on (for example, if you
deploy the model on a home page, make sure you set up recording for
home-page-view
events). To improve personalized recommendations, event
recording for
purchase
and
add-to-cart
events is also recommended.
If you choose the conversion rate (CVR) business objective, event
recording for
add-to-cart
events is required.
Make sure that after creating the Page-Level Optimization model, you continue to query the
model to create recommendations impressions. These impressions are used to
train the Page-Level Optimization model and improve the recommendations it serves.
To create a new model:
Google Cloud console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
Click
Create model
.
Enter a name for your model.
The name must be 1024 characters or less, and can contain only
alphanumeric characters, underscores, hyphens, and spaces.
Choose the recommendation type.
If you selected the
Page-Level Optimization model type
:
Choose the type of page the "Page-Level Optimization" model will optimize for you.
Choose how much to restrict the serving of similar serving configs
across panels:
Unique model type:
Do not allow multiple serving configs with
the same model type to be shown on different panels.
Unique model:
Do not allow multiple serving configs with the same
model to be shown on different panels.
Unique serving config:
Do not allow the same serving config to be
shown on multiple panels.
No restriction:
Allow any serving configs to be shown on any
number of panels.
For each recommendation panel you plan to show with this model:
Enter a panel ID.
Select which serving configs the Page-Level Optimization model can consider as
options for that panel.
For example, an add-to-cart page might have a recommendation panel
where you want to display either Frequently Bought Together or Others You May Like
recommendations. In this case, select a serving config that uses
the Frequently Bought Together model and another that uses the Others You May Like model for
consideration on this panel. When you make a prediction call to the
Page-Level Optimization model, it chooses which type of recommendations you should
display in that panel based on the end user's event history.
Select a default serving config.
If a Google server outage occurs, the Page-Level Optimization model can still serve
results from the default serving config.
If you need to create additional panels, for each new panel click
Add a panel
and enter the new panel details.
Choose the business objective, if available for the model type you
selected.
If you chose the Frequently Bought Together model type, select the
Context products type
:
Multiple context products
: Use one or multiple items as context for
recommendations from this model.
Single context product
: Use one item as context for recommendations
from this model.
Review the
Data requirements met?
list to confirm that you have
uploaded sufficient data for the model type you selected.
If an unmet data requirement prevents you from creating the model, an
X
cancel
icon appears next to the
requirement and the
Create
button at the bottom of the
Create
recommendation model
pane is disabled.
If you need to upload more data, carefully review the data requirements
listed to make sure whether some or all of them need to be fulfilled for
that model, then import the user events or products required to create the
model
For how to import, see
Import historical user events
and
Import catalog information
.
Choose how often to tune the model. For tuning cost details, see
Pricing
.
Every three months
: The model automatically tunes every three
months.
Manual tune only
: The model is tuned only when you tune it
manually.
(
Public Preview feature
) Choose whether to automatically generate
tags for filtering.
Auto generate tags
: Turning on this option lets you filter
recommendations results from this model. Having this option turned on
can increase training time. For training cost details, see
Pricing
.
Do not generate tags
: If this option is turned off, you cannot get
filtered recommendations from this model.
Click
Create
to create the new recommendation model.
If you have uploaded sufficient user event data of the required type, the
initial model training and tuning begins. 
Initial model training and tuning takes 2-5 days to complete, but can take
longer for large datasets.
You can
create serving configurations
for your new model
before training completes, but they will serve only
"dry run" predictions
until the initial training and tuning
completes and the model becomes active.
curl
Make a
Models.create
request to the v2 API with an instance of
Model
in the request body. See the
Models.create
API
reference.
For details about all
Models
fields, see the
Models
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"name": "
FULL_MODEL_NAME
",
"displayName": "
DISPLAY_NAME
",
"trainingState": "
TRAINING_STATE
",
"type": "
MODEL_TYPE
",
"optimizationObjective": "
OPTIMIZATION_OBJECTIVE
",
"periodicTuningState": "
TUNING_STATE
",
"filteringOption": "
FILTERING_STATE
",
"modelTypeConfig" {
"contextProductsType": "
CONTEXT_PRODUCTS_TYPE
"
}
}'
\
"https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models"
If you have uploaded sufficient user event data of the required type, the
initial model training and tuning begins.

Initial model training and tuning takes 2-5 days to complete, but can take
longer for large datasets.
You can
create serving configs
for your new model
before training completes, but they will serve only
"dry run" predictions
until the initial training and tuning
completes and the model becomes active.
Requirements for creating a new recommendation model
The first time you use a specific recommendation type for your site, you are
training a new machine learning model, which requires sufficient training data,
as well as time to train and tune the model. The following steps are required to
start using a new recommendation type:
Import your catalog
to Vertex AI Search for commerce, if you
haven't already, and implement processes to keep the uploaded catalog
up to date.
Start
recording user events
to Vertex AI Search for commerce,
if you haven't already, making sure to follow the
best practices for recording user event data
.
Identify the
recommendation type
and
optimization objective
you want to use.
Determine the
user event data requirement
for your selected
recommendation type and objective.
Import historical user event data
to meet the minimum
event data requirements, or wait until the user event data collection meets
the minimum requirements.
Create your model
and your
serving configs
.
At this point, Vertex AI Search for commerce initiates model training and
tuning. 
Initial model training and tuning takes 2-5 days to complete, but can take
longer for large datasets.
Confirm that your model is working correctly using
prediction preview
.
Create your
A/B experiment
.
Model type minimum data requirements
The type of user events you import, and the amount of data you need, depends on
your
recommendation (model) type
and your
optimization objective
. When you reach the minimum data requirement,
you can begin model training.
The data collection window represents the period for user events; importing more
historical data has no effect on model quality.
Make sure to use real user events and real catalog data. Good quality models
can't be built on synthetic data.
Model type
Optimization objective
Supported user event types
Minimum data requirement
Data collection window
Recommended for You
Click-through rate
detail-page-view
home-page-view
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
AND
7 days of
home-page-view
events in the last 90 days
10,000
home-page-view
events in the last 90 days
3 months
Recommended for You
Conversion rate
add-to-cart
detail-page-view
home-page-view
7 days of
add-to-cart
events in the last 90 days AND
        10 occurrences per catalog item on average (with a 90 days window) of
add-to-cart
events OR
        60 days of
add-to-cart
events in the last 90 days
100 unique catalog items for the
add-to-cart
event in the last 90 days
10,000
add-to-cart
events in the last 90 days
AND
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
AND
7 days of
home-page-view
events in the last 90 days
10,000
home-page-view
events in the last 90 days
3 months
Recommended for You
Revenue per session
add-to-cart
detail-page-view
home-page-view
7 days of
add-to-cart
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
add-to-cart
events OR 60 days of
add-to-cart
events in the last 90 days
100 unique catalog items for the
add-to-cart
event in the last 90 days
10,000
add-to-cart
events in the last 90 days
AND
7 days of
home-page-view
events in the last 90 days
10,000
home-page-view
events in the last 90 days
3 months
Others You May Like
Click-through rate
detail-page-view
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
3 months
Others You May Like
Conversion rate
add-to-cart
detail-page-view
7 days of
add-to-cart
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
add-to-cart
events OR 60 days of
add-to-cart
events in the last 90 days
100 unique catalog items for the
add-to-cart
event in the last 90 days
10,000
add-to-cart
events in the last 90 days
AND
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
3 months
Others You May Like
Revenue per session
add-to-cart
detail-page-view
7 days of
add-to-cart
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
add-to-cart
events OR 60 days of
add-to-cart
events in the last 90 days
100 unique catalog items for the
add-to-cart
event in the last 90 days
10,000
add-to-cart
events in the last 90 days
AND
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
3 months
Frequently Bought Together
Revenue per session
purchase-complete
10 occurrences per catalog item on average (with a 1 year window of
purchase-complete
events) OR 90 days of
purchase-complete
events in the last 1 year
100 unique catalog items for the
purchase-complete
event in the last 1 year
1,000
purchase-complete
events in the last 1 year
3 months
We recommend uploading events at least daily to maintain good data
        quality. During historical event imports, make sure that data
        distribution skews toward the most recent timestamp. The number of
        events on the last timestamp day should be equal to or more than the
        average daily event count.
On-sale
Click-through rate
detail-page-view
home-page-view
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
AND
7 days of
home-page-view
events in the last 90 days
10,000
home-page-view
events in the last 90 days
3 months
On-sale
Conversion rate
add-to-cart
detail-page-view
home-page-view
7 days of
add-to-cart
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
add-to-cart
events OR 60 days of
add-to-cart
events in the last 90 days
100 unique catalog items for the
add-to-cart
event in the last 90 days
10,000
add-to-cart
events in the last 90 days
AND
7 days of
detail-page-view
events in the last 90 days AND 10 occurrences per catalog item on average (with a 90 days window) of
detail-page-view
events OR 60 days of
detail-page-view
events in the last 90 days
100 unique catalog items for the
detail-page-view
event in the last 90 days
10,000
detail-page-view
events in the last 90 days
AND
7 days of
home-page-view
events in the last 90 days
10,000
home-page-view
events in the last 90 days
3 months
Similar Items
N/A
None required.
100 product SKUs must be in some branch
N/A
Page-Level Optimization
Any
detail-page-view
add-to-cart
purchase-complete
home-page-view
Page-Level Optimization optimizes recommendation panels by choosing between several
        possible models. Refer to the data requirements for the models you
        select as options for Page-Level Optimization.
N/A
Buy it Again
N/A
purchase-complete
10 occurrences per catalog item on average (with a 90 days window of
purchase-complete
events) OR 60 days of
purchase-complete
events in the last 90 days
100 unique catalog items for the
purchase-complete
event in the last 90 days
1,000
purchase-complete
events in the last 90 days
100 product SKUs must be in some branch
N/A
We recommend uploading events at least daily to maintain good data
        quality. During historical event imports, make sure that data
        distribution skews toward the most recent timestamp. The number of
        events on the last timestamp day should be equal to or more than the
        average daily event count.
What's next
Create a serving config
for your model.
Learn how to
pause and resume training
for your model.
When the model finishes training,
start requesting recommendations
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/data-governance-retail.txt
Data governance for commerce  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Data governance for commerce
Google was one of the first in the industry to publish an
AI/ML Privacy Commitment
,
which outlines our belief that customers should have the highest level of
security and control over their data that is stored in the cloud. That
commitment extends to Google Cloud generative AI products. Google helps verify
that its teams are following these commitments through robust data governance
practices, which includes reviews of the data that Google Cloud uses in
the development of its products. More details about how Google processes data
can also be found in
Google's Customer Data Processing Addendum (CDPA)
.
Responsible AI
As a developer using Vertex AI Search for commerce, you can access Google's foundation
models, search expertise, and conversational AI technologies to create
enterprise-grade generative AI applications through Vertex AI Search.
However, as an early-stage technology, its changing capabilities and uses create
potential for misapplication and unintended consequences. For example,
Vertex AI Search for commerce can generate unexpected output, including text that's
offensive or incorrect.
Given these risks and complexities, Vertex AI Search for commerce is designed with
Google's
AI Principles
in mind, but you must
understand and test the models to deploy them safely and responsibly. To aid
developers, Vertex AI Search for commerce has built-in safety filters to help
customers block potentially harmful outputs within their use case. For more
information, see Google's
Privacy Resource Center
.
When Vertex AI Search for commerce is integrated into a customer's unique context, you 
might need to consider additional responsible AI considerations and model
limitations. We encourage you to follow
recommended best practices
.
Use of generative AI
Vertex AI Search for commerce uses generative AI services for building search, personalized,
and conversational experiences. As part of the Google Cloud AI/ML Privacy Commitment, customer data used
in Vertex AI Search for commerce is not used to train foundation models. Foundation models are frozen and only process input to provide output for the
services provided by Vertex AI Search for commerce.
Customer-specific models
When applicable, customer-specific models are built automatically and used only
in the context of the Vertex AI Search for commerce service customer-specific project.
Customer data used to create these retailer-specific models isn't used to
train foundation models. Models specific to Vertex AI Search for commerce, like all
customer data, continue to be protected by
Google's security controls and best practices
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/data-quality.txt
Data quality  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Data quality
This page describes search use cases, their respective
performance tiers, and how to check the Search for commerce console for an
assessment of your data quality and which performance tiers you have unlocked.
Each performance tier is automatically activated when you satisfy all of its
upgrade-blocking data requirements. You must also meet the requirements for all
previous tiers to upgrade to the next tier.
Search use cases
Search provides search results for two use cases:
Text query search
, used when your shoppers look for items on your
application by entering text queries and getting a set of relevant results.
Browse search
, used when your shoppers land on a particular category
page, such as the "Appliances" category web page of a home improvement
store's retail site and browse the sorted items in that category.
For more about the differences between these use cases, see
About text search and browse search
.
Unlock search performance tiers
Text query search and browse search have different performance tiers that
increasingly improve your search results. Unlocking performance tiers relies on
the user event and catalog data that you upload to Vertex AI Search for commerce.
The following performance tiers are available for both use cases, text query search and browse:
Text query search
TIER 1
Relevance
:
Results are returned based on degree of relevance to the query, such as
how
black a dress is when a black dress is queried.
Minimum data requirements
:
Catalog
Query
TIER 2
Relevance and popularity
:
Refines TIER 1 for the most popular items in the queried search.
Equally relevant products are ranked by the popularity of the product on your site.
Minimum data requirements
: Click data
TIER 3
Revenue-optimized ranking
: Relevant results are ranked by the product's likelihood of being purchased based on specific site-wide activity.
Minimum data requirements
: A large volume of user events.
TIER 4
Personalized revenue-optimized ranking
:
Relevant results are ranked by the individual user's preferences and the product's likelihood of being purchased based on this user's site-wide activity.
Products ranked based on "quality of match" to the unique user searching or browsing the site.
Minimum data requirements
:
A large volume of user events.
Matching
visitorID
and or
userId
, formatted consistently across user events.
Note:
Attribution tokens
are needed for better performance and measurement for search events served by Vertex AI Search for commerce. They are required for Tier 4 model training.
Browse
BRONZE
Random results
Any search result that fits your filters, in random order.
SILVER
Popularity
Results are returned based only on relevance to the category.
GOLD
Revenue-optimized ranking
Relevant results are ranked by the product's likelihood of being purchased based on site-wide activity.
PLATINUM
Personalized revenue-optimized ranking
Relevant results are ranked by the individual user's preferences and the product's likelihood of being purchased based on site-wide activity.
The Search for commerce console provides a
Data quality
page where you
can check if you have met each tier's data requirements.
The next sections show how to sign up for data quality alerts that notify you which of the tiers your data falls into, given your current parameters. These alerts also serve as a guide for your specific use case data requirements for best optimizing your search results.
Check your data quality
After uploading your data, go to the Search for commerce console to see data
check metrics for each performance tier for your use case.
Go to the
Data quality
page in the Search for commerce console.
Go to the Data quality page
View the data check metrics for your search use case:
For text search metrics, click the
Search
tab.
For browse search metrics, click the
Browse
tab.
Check each performance tier's score card of issues at the top of the page.
If it is labeled "In use":
You have satisfied all blocking
issues for that tier and have unlocked it.
If there are 0 blocking issues:
You have satisfied the data
checks for that tier. If there are 0 blocking issues for this tier and
all previous tiers, it takes about 24 hours to train and prepare the
model and activate the newly unlocked tier.
If there are any blocking issues:
Check that tier's metrics
to see which data issues to address to unlock that tier.
View each performance tier's data check metric table to see a list of
issues that can block tier upgrades or impact search performance.
Check the
Status
column for the priority level of each data check
metric:
Upgrade blocking
: Identifies data issues that prevent
search from upgrading your use case to the next
performance tier. To unlock a tier, satisfy all upgrade blocking data
checks for that performance tier (and those of its previous tiers).
Performance critical
: Identifies data issues that don't
block an upgrade, but can have a significant impact on text search or
browse search performance.
Compliant
: Indicates that this data check has passed.
Unavailable
: Indicates that a non-upgrade blocking data
check is not yet completed. Values for these metrics are displayed as
N/A
. It can take up to 24 hours after importing data to compute
some data checks.
For more information about any metric, click
Details
to see a detail
panel that displays that metric's description, data check timestamp, and
threshold values.
Check the thresholds in a metric's
Details
panel for the values
needed to satisfy that metric's data check and improve results. Not all
thresholds apply to all metrics:
Blocking threshold
: A required threshold to meet for satisfying
this metric's data check.
Critical threshold
: A highly recommended threshold to meet.
Not meeting this threshold can have a significant negative impact on
performance.
Warning threshold
: A recommended threshold to meet. Not
meeting this threshold can have a minor impact on performance.
To import more data to satisfy any data issues, see
Import historical user events
or
Import catalog information
in the public documentation.
Best practices
In search requests and in user events, provide user IDs in addition to visitor
IDs for signed-in users. This allows search to personalize
results for the user based on users' signed-in events across devices.
Send user events in real time instead of in batch uploads with a delay. This
helps search personalize using a user's most recent activity
on your site.
Upload all user events. For example, don't submit only events that are
attributable to searches.
Feature selection for upper revenue-optimized tiers
Vertex AI Search for commerce has been upgraded for retailers whose data has reached the upper performance tiers that unlock revenue-optimized search capabilities. These retailers in these upper tiers can now make use of feature selection:
For Browse: SILVER and GOLD
For Search: Tiers 3 and 4
Why the ranking upgrade?
Large Vertex AI Search for commerce customers have up to 10,000 custom attributes in their product catalog, while the ranking model previously had only 20 static product features (such as price and average rating) shared across all customers. This resulted in the ranking model having very incomplete product data, and no ability to customize the product features to different retail domains and use cases like fashion, hardware or home goods.
The inability to model custom attributes led some users to put the attributes they considered important into the static (fixed) product features. However, this required manual effort and clearly only worked for a small number of attributes.
Dynamic custom feature selection
Vertex AI Search for commerce has upgraded its revenue-optimized tiers to auto select custom attributes. The upgrade involves incorporating relevant custom attributes into the ranking process:
Goes through all custom attributes for each retailer and chooses the most useful ones to be added to the set of static product features.
Displays selected attributes for each retailer.
Repeats the feature selection process on a regular basis (once every 30 days).
In sum, Vertex AI Search for commerce not only gives the ranking model access up to 100 times or more potential new features to select from for the model, but each customer's attributes are also refreshed regularly to adapt to seasonal sales and other dynamic data changes.
The upgraded ranking solution provides more powerful search insights, utilizing regularly refreshed custom attributes to drive data quality.
Full product knowledge
Feature selection
: The Vertex AI Search for commerce algorithm selects up to 20 most important custom attributes for each retailer.
Benefits:
Improved ranking accuracy by leveraging additional information about products, such as sale codes and product or style specifications.
Visibility
: Retailers can view the selected custom attributes and ensure they are maintained and up-to-date.
Customization and learning
: Customers can identify patterns in selected custom attributes and add other relevant ones to further increase ranking performance.
How to see which attributes are being used
If a customer has the higher tiers enabled with sufficient user event data points, the new custom attributes information is now visible in the Console, listed under the
Text search
and/or
Browse search
tab in the
Data quality
page of the Search for commerce. Here, it tells you which custom attributes were chosen by the Vertex AI Search for commerce system.
Note:
Attributes don't have to be searchable, but they must be in your product catalog.
Note: The number of attributes is not limited. You can add as many attributes according to your preferences. All are eligible for feature selection.
What to do with the custom attributes
Maintain and don't delete or deprecate attributes that were chosen because it may affect the model.
Improve coverage for auto selected attributes, filling in these fields for more products
Examine trends in which custom attributes are autoselected. If you have other similar attributes, add them to your catalog. They will become candidates for selection by the feature search algorithm.
Correctly annotate numeric attributes by assigning them numeric values rather than string values. For example, provide a numeric value of
10.5
, instead of text ("10.5").
Turn off personalization
To turn off personalization, set
ServingConfig.personalizationSpec
to
mode.DISABLED
.
Data quality alerts
The data quality alerts are triggered if a metric value on the dashboard changes from satisfying to non satisfying. Alerts are sent by emails.
If you want to see Cloud Monitoring related alerts, go to
Set up alerts
.
View data quality
Go to the
Data quality
page in the Search for commerce console.
Go to the Data quality page
Review rows, metrics, and alerts: One row corresponds to one metric, and one metric corresponds to one alert.
Set up data quality alerts
REST
Call the
UpdateAlertConfig
API.
curl -X PATCH -H "Authorization: Bearer $(gcloud auth print-access-token)" \
    -H "Content-Type: application/json" -H "X-GFE-SSL: yes" -H "X-Goog-User-Project:
PROJECT_ID
" \
 "https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/alertConfig" \
--data '
{
  "alertPolicies": [
    {
      "alertGroup": "search-data-quality",
      "enrollStatus": "ENROLLED",
      "recipients": [
        {
          "emailAddress": "
EMAIL_ADDRESS_1
"
        },
        {
          "emailAddress": "
EMAIL_ADDRESS_2
"
        }
      ]
    }
  ]
}'
Replace the following:
PROJECT_ID
: The ID of your Google Cloud project.
EMAIL_ADDRESS_1
,
EMAIL_ADDRESS_2
: The email addresses that you want to enroll in for the alerts. They should be SMTP compliant. At most 20 email addresses can be added to one alert policy.
Console
Go to the
Data quality
page in the Search for commerce console.
Go to the Data quality page
At the top, click
settings
Configure alerts
.
Add at least one email address. The email addresses should be compliant to SMTP (Simple Mail Transfer Protocol). At most, you can add up to 20 email addresses to one alert policy.
Click
Submit
.
Disable data quality alerts
REST
Call the UpdateAlertConfig API.
curl -X PATCH -H "Authorization: Bearer $(gcloud auth print-access-token)" \
    -H "Content-Type: application/json" -H "X-GFE-SSL: yes" -H "X-Goog-User-Project:
PROJECT_ID
" \
 "https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/alertConfig" \
--data '
{
  "alertPolicies": [
    {
      "alertGroup": "search-data-quality",
      "enrollStatus": "DECLINED",
      "recipients": [
      ]
    }
  ]
}'
Replace the following:
PROJECT_ID
: The ID of your Google Cloud project.
Console
Go to the
Data quality
page in the Search for commerce console.
Go to the Data quality page
Click
settings
Configure alerts
.
Delete all existing emails.
Click
Submit
.
Troubleshoot
Here is how to solve the following common issues.
Data check isn't passing
If a data check isn't passing, click
Details
for that metric on the
Data
quality
page to see a more detailed description of that metric and the
thresholds to meet that satisfy that data check.
If you have already met the data requirements, check the
Timestamp
section
for when that metric was last computed. If you recently reformatted or ingested
a significant amount of data, it might take several hours to re-compute that
metric.
If you haven't met the data requirements, you might need to reformat data or
collect more data to meet the data check requirements. After you have ensured
your data will meet the metric threshold, re-import your reformatted data or
import your additional data, then wait for the metric to re-compute.
A metric value labeled as N/A
Metrics values are displayed as N/A if no data has been uploaded or if the
metrics are not yet computed. It can take up to 24 hours after importing data to
compute some data checks.
Performance tier has no blocking issues but isn't in use
To troubleshoot, follow these steps:
Check if there are any blocking data issues for previous tiers. You need to
meet the requirements for all previous tiers to upgrade to the next tier.
Wait 24 hours. After all upgrade-blocking data checks have passed, it takes
about 24 hours to train and prepare the model and activate the newly unlocked
tier.
If the performance tier isn't marked as in-use within two days of passing all of
its upgrade-blocking data checks, contact Vertex AI Search for commerce
support
with
your project number and project ID for assistance.
Additional data requirement information
For more about Vertex AI Search for commerce data requirements, see the documentation:
General Vertex AI Search for commerce requirements when uploading user event data:
Requirements for user events
Minimum user event requirements to get results for search:
Search requirements
Catalog data requirements:
Catalog data quality metrics
What's next
Import historical user events
Import catalog information
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/email.txt
Use recommendations in emails  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Use recommendations in emails
While prediction results from Vertex AI Search for commerce are most commonly used
in retail websites, you can also use recommendations in email
messages. Recommendations in email are usually included as part of marketing
campaign email blasts, after-order emails, or abandoned cart emails.
Choose a model type
The Recommended for You model can be a useful model for emails because it is designed to
deliver recommendations in use cases where a user hasn't indicated interest in a
specific item. It works best with logged-in users that have some browsing or
shopping history.
The Others You May Like model is typically used on product details pages rather
than for email campaigns. However, you can use it for emails to recommend
similar or complementary items to what a customer has recently viewed.
The Frequently Bought Together model is usually used on the add-to-cart page or the shopping cart
page, but can also be used for email.
The Buy it Again model is designed for use on most types of pages and can also be
used for email.
Request requirements
In order to get relevant recommendations back, the
userId
field
must match the user ID that is associated with a logged-in user on your website
or app.
Ideally, the
visitorId
field should match the user's last session ID from the
site. Because the last session ID isn't always recorded, a random unique
identifier can also be sent as the
visitorId
field.
Frequently Bought Together and Others You May Like models also require product IDs in the
productDetails
section of the predict call. For Frequently Bought Together
models, the IDs can be items from a user's most recent purchase.
Include static predictions in email
You can send static predictions by inserting data into an email template.
The
predict
method can be called in real time as emails go out, or the
recommendations can be retrieved individually and saved either as part of an
email template or in a database to be referenced later. To have the most up to
date recommendations, call the
predict
method as close in time as possible to
when the email is sent.
Call the
predict
method for email
The Vertex AI Search for commerce
predict
method
takes some fields as
input and returns a list of product recommendations.
visitorId
,
userId
, and
id
are used as input for most recommendations models.
Each prediction request for a user must be made individually, using code or
shell scripts.
The following is pseudocode for a predict request:
for user in userlist:
  emailTemplate.recommendations = predict(user.visitorid,user.userid,user.lastorder.id,...)
...
format email template as required
Include dynamic predictions in email
Although static predictions can be quickly implemented, they can become outdated
more quickly than dynamic predictions. A user might not open the email for some
time, and better recommendations could be available by that time. More
sophisticated bulk email systems can add dynamic content by including a
reference to an image in an HTML email.
The following is example HTML for an image that includes a serving config
reference:
<img src="https://example.com/recs/email?userid=47832&campaign=2020FALL&servingconfig=fbt>
Getting the recommendations back can be done with a Cloud Run function, or
any server-side app that can make the prediction request. The predict results
then need to be turned into an image. This can be done with a library, such
as
ImageMagick
.
Predictions are only made for opened, viewed emails. You can also cache the
results rather than creating a new image if the user opens the email again.
This reduces the cost of using recommendations for emails.
Because the link destination is typically hard-coded into the email, you don't
necessarily know which products will be shown. Redirecting clicks to individual
product pages requires additional configuration. You'll usually use a single
image for all recommendations, so using an image map can help you determine
which product was clicked.
Quotas
If you plan to run a large batch of predict requests over a short period of
time, you should check your quotas. On your project's
Quotas
page, check
Recommendation prediction
requests per project per minute
. You can request an increase by clicking
Edit Quotas
on the quota's details page.
We recommend implementing
exponential backoff
to retry
requests after a delay. The service returns
HTTP 429
responses if quota is
exceeded.
Evaluate results
URL tagging lets you track and evaluate the effectiveness of campaigns.
You can use
Google Analytics
or another analytics
platform to add tracking parameters to links in emails and include that data in
reports. Tag recommendation clicks from emails to filter them so that you can
evaluate metrics.
If you A/B test multiple recommendations, we recommend doing so within a single
campaign. All standard
A/B testing guidelines
for websites still
apply.
What's next
Create a serving config
for your model.
Learn how to
pause and resume training
for your model.
When the model finishes training,
start requesting recommendations
.
Use
A/B experiments
to understand how Vertex AI Search for commerce
impacts your business.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/entities.txt
Entities  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Entities
This page introduces
entities
, ways of capturing varied user behavior depending on multiple brands or products on a single enterprise site, as well as how and why they can be used.
For most use cases, entities are not needed for Vertex AI Search for commerce. However,
retailers who serve multiple brands or regions from a single product
catalog can get better results if they use entities.
Overview
Setting up multiple entities in your project is a way to take into consideration
different behavior and preferences of shoppers who are in different regions or
countries or who shop at differently branded sites that belong to your
enterprise.
Example use case: two countries
A retailer, Example Organization, has a web presence in both the US and Canada.
Example Organization wants to serve browse and search results and autocomplete
suggestions that take into account differences between the shoppers in the two
countries. And so, Example Organization designates two entities:
org_us
and
org_ca
.
User events are tagged with an entity value, depending on which website the
shopper visited (
.com
or
ca
). When a shopper makes a search request, the
entity value is included in the request.
The two countries have important but different holidays in July. With entities
set up, when shoppers search the Example Organization site for
July
,
American shoppers are served Fourth of July themed items first and Canadian
shoppers receive items themed for Canada Day.
Similarly, recommendations for Canadian shoppers are more likely to show Canada
Day items than Fourth of July items.
Example use case: an acquisition
Enterprise Example Organization recently acquired Startup Example Organization.
The catalogs have been combined but the Startup brand and website is being
kept because it has a loyal following.
The enterprise creates an entity,
startup
, to tag user events originating from
the Startup site. This allows the search, browse, autocomplete, and
recommendation suggestions that are served to the Startup site to take into
account the preferences of the Startup site's shoppers.
Multiple projects or multiple entities?
When you set up Vertex AI Search for commerce, you can use different projects or different
entities in the same project to get different suggestions for your different
shopper populations.
For some applications, separate projects are required. For other applications,
setting up entities is the better solution.
Use
entities
when you have:
A fully or partially shared catalog between the entities
One or more of the following:
Multiple brands in the same country or language area—for example, you have
your original brand and an acquired brand,
google_home
and
nest
.
Multiple regions in the same country—for example,
enterprise_east
and
enterprise_west
.
One brand but in multiple countries with the same language—for example,
brand_us
and
brand_ca
.
Use
separate projects
instead of entities when you have:
Catalogs that cannot be combined or catalogs that, if combined, have little or no overlap.
Entities that require different languages.
Only one language is allowed per project.
User events and entities
To take advantage of the entities feature, add the entity field to your
user events.
For search and autocomplete:
include the
entity
field
 in user events of type
search
.
Including the entity field in other user event types can be helpful
for troubleshooting but does not affect the quality of the search or
autocomplete responses.
For recommendations:
include the entity field in as many types of user
event as you can.
Typically, it takes 30 to 90 days of user event data before the entity feature 
returns optimal suggestions.
If an entity is missing from a request, the request makes no assumption about the
entity in the result. You'll get an average result that is based on user events
with and without the entity specified.
Search and entities
To get search or browse results that take into account the entity:
Include the
entity
field in your search user events
(
eventType="search"
).
For an example, see the complete object example for the
Search
user event.
Add the
entity
field to your search request. For information about how to
make search requests, see
Get search results
.
Autocomplete and entities
To get autocomplete results that take into account the entity:
Follow the instructions in
Auto-learning dataset
and
Suggestion filtered by entity
.
Recommendations and entities
After you have added the
entity
field to your user events, no
further action is required to take advantage of entities for recommendations.
This is because the entity value is part of the user event, which, in turn, is
included in the call to the
predict
method.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/error-reporting.txt
Monitor and troubleshoot  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Monitor and troubleshoot
This page describes how to get information about errors that have occurred in
catalog and user event imports and in other API operations in
Vertex AI Search for commerce.
For help with setting up alerts, see
Set up Cloud Monitoring alerts
.
Introduction
Providing accurate catalog information and user events to the
API is important for getting the highest quality results. Monitoring and
understanding the source of errors helps you find and fix any errors in your
site.
See aggregated integration errors
To see the aggregated errors generated by your data upload processes and
prediction or search requests, use the
Monitoring
page
.
This page displays all errors for the Vertex AI Search for commerce API. You can view
errors related to the product catalog, user events,
recommendations predictions, search results, and
models. The system also logs errors from imports, such as a malformed line in
your Cloud Storage file. The system logs up to 100 errors per import
file. You can define the time period for which errors are displayed and filter
based on the
error type
.
You can click an individual error to see the logs for that error in
Cloud Logging.
You can open individual error logs by expanding that log. Error logs provide
more detail about the request, including the request and response payloads
and error details. This information can help you determine where the
erroneous method call is located in your site.
For invalid JSON errors, you can get more information about the issue by
expanding the
status
field.
See status for a specific integration operation
You can see the status of a specific integration operation in the
Activity status
window:
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Activity status
.
The
Activity status
window shows the status of long-running operations on
your product catalog, user events, and controls.
You can inspect errors for specific integration operations in this window.
Click
View logs
in the Detail column of any operation with an error to
inspect its log files in Cloud Logging.
View logs in Cloud Logging
To open your log files directly in Cloud Logging, use the following
procedure. You must have the Logs Viewer (
roles/logging.viewer
) role to view logs.
Go to Logs Explorer in the Google Cloud console.
Go to Logs Explorer
Select your Vertex AI Search for commerce project from the project selector.
Click the
Resource
drop-down menu and select
Consumed API
>
Cloud Retail
.
For more information about the Logs Explorer, see
View logs by using the Logs Explorer
.
For example, this link opens logs for all Vertex AI Search for commerce errors in the
past hour:
Open Vertex AI Search for commerce logs
To configure which API logs are written, see
Configure Logging
.
Configure Logging
You can configure which service logs are written to Logging.
Logging configuration provides a way to set the severity levels at which to
write logs, turn logging on or off, and override default logging settings for
specific services.
Each API request an end user makes can generate one logging entry. An entry
contains information such as the API method, when it was invoked, the response
code, and the request and response bodies. A project's logging configuration
specifies which types of logs generated by the API get written to
Logging, with the option to granularly specify logging
configurations for specific API services.
To update logging configurations, you need the Vertex AI Search for commerce editor
role.
You can use the console or the
LoggingConfig
API to
configure Logging.
Console
To update logging configurations in the console, follow these steps:
Go to the
Monitoring
page in the Search for commerce console.
Go to the Monitoring page
Click
Logging configuration
.
To set a global logging configuration, select a
logging level
. If you select
LOG_ALL
, also enter a
sampling rate for successful logs
.
To set a
service-level configuration
, select a service to
update and select its logging level. This setting overrides the global
logging configuration.
curl
To update logging configurations using the API, use the
LoggingConfig
resource. See the
LoggingConfig
API reference
.
To view the current logging configuration, use
loggingConfig.Get
.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
print-access-token
)
"
\
-H
"Content-Type: application/json"
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/loggingConfig"
PROJECT_ID
: The ID of your project.
To update the logging configuration, use the
loggingConfig.Patch
method. For more information, see the
LoggingConfig
API reference
.
This example uses
loggingConfig.Patch
to set the global logging
configuration to
LOG_WARNINGS_AND_ABOVE
. It also sets two service-level
configurations:
CatalogService
is set to
LOG_WARNINGS_AND_ABOVE
and
ControlService
is set to
LOG_ALL
.
curl -X PATCH \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" \
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/loggingConfig" \
--data '{
"name": "projects/
PROJECT_ID
/loggingConfig",
"default_log_generation_rule": {"logging_level": "LOG_ERRORS_AND_ABOVE"},
"service_log_generation_rules": [
{
"service_name": "CatalogService",
"log_generation_rule": {
"logging_level": "LOG_WARNINGS_AND_ABOVE"
}
},
{
"service_name": "ControlService",
"log_generation_rule": {
"logging_level": "LOG_ALL", "info_log_sample_rate": "0.1"
}
}
]
}'
Logging levels
Only logs of some severity levels are written to Logging. The
logging level settings determine which logs generated by an API method get
written to Logging.
When no service-level logging config is set for an API method, the global
logging level setting is used.
The default logging level setting is
LOG_WARNINGS_AND_ABOVE
.
The
logging_level
field accepts the following values:
LOGGING_DISABLED
: No log written.
LOG_ERRORS_AND_ABOVE
: Logs errors only.
LOG_WARNINGS_AND_ABOVE
: Logs errors and warnings only.
LOG_ALL
: Logs everything, including successful logs such as
INFO
logs.
Sampling rate for successful logs
If you set the logging level setting to
LOG_ALL
but don't want to log every
successful log, you can specify a sampling rate. For example, you might decide
to periodically monitor logs for successful status confirmation, or want see a
percentage of successful logs. Specifying a sampling rate can help you do this
without writing a high volume of
INFO
log entries to
Logging, which can incur higher Logging costs.
To specify a sampling rate, set
info_log_sample_rate
to a valid float value
greater than 0 and less than or equal to 1. The sampling rate determines the
likelihood of an
INFO
log being written to Logging. The default
value is 1 (all
INFO
logs are written).
Caution:
If the logging level is not set to
LOG_ALL
, the
info_log_sample_rate
field must remain unspecified.
Service-level configurations
You can set logging configurations for specific services. This overwrites the
global logging setting for that service. For example, you might have the global
logging level set to
LOG_WARNINGS_AND_ABOVE
, but set the
UserEventService
service logging level to
LOG_ALL
so you can check for
successful user event integrations.
Use the
ServiceLoggingLevel
object to set granular logging levels.
The
service_name
field accepts the following values:
CompletionService
ControlService
MerchantCenterStreaming
ModelService
PredictionService
ProductService
ServingConfigService
UserEventService
Error types
This section provides definitions for error types that can appear in your
logs:
MISSING_FIELD
:  A required field value is not set; for example, a catalog item
is missing its title.
INVALID_TIMESTAMP
: The timestamp is invalid, such as being too far in the
future, or formatted incorrectly.
FIELD_VALUE_TOO_SMALL
: The value in the field is lower than the required
minimum; for example, a negative price.
INCORRECT_JSON_FORMAT
: The JSON in the request is incorrectly formatted,
such as a missing { bracket.
INVALID_LANGUAGE_CODE
: The language code is incorrectly formatted.
FIELD_VALUE_EXCEEDED
: The value in the field is higher than the allowed
maximum.
INVALID_RESOURCE_ID
: The resource ID is invalid; for example, a non-existent
catalog_id
in the resource name.
FIELD_SIZE_EXCEEDED
: The number of entries in the field exceeds the maximum
limit.
UNEXPECTED_FIELD
: A field that was expected to be empty has a value; for
example, a transaction for a detail page view event.
INVALID_FORMAT
: The field is not formatted correctly, such as a malformed
string
RESOURCE_ALREADY_EXISTS
: You tried to create a resource that already exists,
such as a previously created catalog item.
INVALID_API_KEY
: The API key does not match the project in your request.
INSUFFICIENT_PERMISSIONS
: You do not have permission to execute the request;
this error is usually related to the lack of a required IAM permission.
UNJOINED_WITH_CATALOG
: The request includes a catalog item ID that does not
exist in the catalog. Make sure your catalog is up to date.
BATCH_ERROR
: The request has multiple errors; for example, an inline import
with 10 items that fail validation for different reasons.
INACTIVE_RECOMMENDATION_MODEL
: You queried a model that is not active for
serving.
ABUSIVE_ENTITY
: The visitor ID or user ID associated with the request has
sent an abnormal number of events in a short period of time.
FILTER_TOO_STRICT
: The prediction request filter blocked all prediction
results. Generic (not personalized) popular items are returned, unless the
call specified
strictFiltering
as false, in which case no items are
returned. Some common reasons why this issue occurs:
You are specifying a filter tag that doesn't exist in your catalog.
It can take up to a day for a filter tag update to take effect.
Your filter is too narrow.
View data load metrics
To monitor your catalog and user event data ingestion in the Google Cloud console,
follow these steps:
View error metrics for your catalog and user event data ingestion on the
Monitoring
page.
Go to the Monitoring page
After your data upload system is running successfully, use the
Catalog
and
Event
tabs on the
Data
page to see aggregated
information about your catalog, preview your uploaded products, and view
visualizations of your user event integration metrics.
Go to the Data page
To create alerts that let you know if something goes wrong with your data
uploads, follow the procedures in
Set up Cloud Monitoring alerts
.
Catalog data summary
Use the
Catalog
tab on the
Data
page to view high-level data statistics
for each catalog branch. This page displays how many products you have imported,
how many are in stock, and when you last imported products for each product
catalog branch.
You can also see a preview of the catalog items you have uploaded, and filter
based on product fields.
You can import data to different branches as a way to stage and preview
recommendations or search results. For example,
to prepare for a holiday season, you might upload new catalog data to a non-
default branch and make sure Vertex AI Search for commerce results are generated correctly
before making it live on your website.
User event recording statistics
For each type of user event, you can see in the
Event
tab how many you have
recorded, how many of those were not able to be associated with a product
(unjoined events), and how the numbers differed from previous periods. You can
select a preset time period or enter custom time range.
The metric graph displays user events ingested over time, which you can filter
by user event type.
Note:
The time periods for statistics are in the Pacific time zone. For example,
daily statistics represent the data from yesterday at midnight Pacific time to
today at midnight Pacific time.
Data quality metrics
On the
Data quality
page, you can see metrics that show the percentages of products and user events
that fulfill recommended standards of data quality for search.
Use this page to assess what data you need to import or update in order to
improve the quality of search results and unlock search performance tiers.
For more information about search performance tiers and checking the quality of
your data, see
Unlock search performance tiers
.
For a list of all catalog data quality metrics, see
Catalog data quality metrics
.
For all user event requirements and recommendations for
recommendations and search, see
User event requirements and best practices
.
Unjoined events
When a user event or API request refers to a product that has not been
uploaded to Vertex AI Search for commerce, it is an
unjoined
event. Unjoined user
events are still logged, and unjoined requests are handled, but neither can be
used to further enhance the model for future predictions. For this reason, you
should make sure that your unlogged event percentage is very low for both user
events and prediction requests.
You can see your unjoined user event percentage in the
Event
tab on the
Data
page.
API errors
You can see a graph of API errors over time, displayed by method name, by
clicking
View API metrics
on the button bar of the
Monitoring
page
.
Monitor API method activity
For visualizations of traffic, errors, and latency by API method, go to the
Monitoring
page
.
You can select a preset time period or enter custom time range.
To see more details about each graph:
Underneath a graph, click a method name to isolate it in the graph.
Hover your cursor over a graph to see a callout with each method and its
values at that point in time.
Click and drag over any section of the graph to zoom in on that period of
time.
What's next
Learn how to
set error alerts for your data feeds
.
Learn more about
Error Reporting
.
Learn more about
viewing logs in Logging
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/export-analytics-metrics.txt
Export your analytics metrics into BigQuery  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Export your analytics metrics into BigQuery
This page describes how to export Vertex AI Search for commerce analytics metrics into
BigQuery. Exporting analytics metrics lets you retain the
metrics and write SQL for your own analysis.
Vertex AI Search for commerce analytics metrics are generated automatically for you.
For more information about measuring the business impact of
Vertex AI Search for commerce with analytics metrics, see
View analytics
.
Exporting metrics data to BigQuery has the following limitations:
The data that is exported to BigQuery tables in your
Vertex AI Search for commerce project are
authorized views
, not
materialized views
.
You cannot change or update the data in these tables. If you need to change
or update your data, export or copy the view to another destination.
You can't export metrics for user events that are older than 180 days or
metrics that were generated more than 180 days ago. Any metrics generated
before the 180-day window are not retrievable.
Before you begin
Before you can export your metrics into BigQuery, you must
have completed the procedures in
Before you begin
. This
includes importing your user events and, optionally, your catalog
information.
For more information about importing, see:
Import catalog information
Record real-time user events
Import historical user events
Create a dataset in BigQuery
You need to create a dataset in BigQuery to hold your analytics
metrics data.
You must create the datasets in the same project where you implemented
Vertex AI Search for commerce.
If you haven't used BigQuery in your
project before, enable the BigQuery API and make sure that
you have the IAM role that lets you create datasets and tables.
See
Before you begin
and
Access control with IAM
in the BigQuery documentation.
Create a dataset in BigQuery in the
US (multiple regions in
the United States)
multi-region. For example, name it
retail_data
. If
you create your dataset in a different region, exporting your data into
BigQuery fails.
CMEK
for the dataset is not
supported; enabling it causes the export to fail.
For information about creating a dataset, see
Creating datasets
in the
BigQuery documentation.
This dataset will be used to hold the data table(s) that you export. The
following procedures describe how to export.
Export your analytics metrics to a BigQuery table
Use the
exportAnalyticsMetrics
method to export your retail catalog into a
BigQuery table.
Before using any of the request data,
  make the following replacements:
PROJECT_ID
: The ID of the
    Vertex AI Search for commerce API project where you created the BigQuery
    dataset.
DATASET_ID
: The name of the
    dataset that you created in
Create a dataset in BigQuery
. For example, use
retail_data
or
retail_metrics_data
.
TABLE_ID_PREFIX
: A prefix
    for the table ID. This prefix can't be an empty string. A suffix of
retail_analytics_metrics
is added to complete the table name. For
    example, if the prefix is
test
, the table is named
test_retail_analytics_metrics
.
Request JSON body:
{
  "catalog": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog",
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
To send your request, expand one of these options:
curl (Linux, macOS, or Cloud Shell)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
, or by using
Cloud Shell
,
            which automatically logs you into the
gcloud
CLI
            .
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
cat > request.json << 'EOF'
{
  "catalog": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog",
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
EOF
Then execute the following command to send your REST request:
curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" \
-d @request.json \
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog:exportAnalyticsMetrics"
PowerShell (Windows)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
.
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
@'
{
  "catalog": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog",
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
'@  | Out-File -FilePath request.json -Encoding utf8
Then execute the following command to send your REST request:
$cred = gcloud auth print-access-token
$headers = @{ "Authorization" = "Bearer $cred" }
Invoke-WebRequest `
-Method POST `
-Headers $headers `
-ContentType: "application/json; charset=utf-8" `
-InFile request.json `
-Uri "https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog:exportAnalyticsMetrics" | Select-Object -Expand Content
You should receive a JSON response similar to the following:
{
  "name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/operations/12310973052792775280",
  "done": true,
  "response": {
    "@type": "type.googleapis.com/google.cloud.retail.v2.ExportAnalyticsMetricsResponse",
    "outputResult": {
      "bigqueryResult": [
        {
          "datasetId": "
DATASET_ID
",
          "tableId": "
TABLE_ID_PREFIX
_retail_analytics_metrics"
        }
      ]
    }
  }
}
Metrics definitions
The exported metrics are the
count metrics
. There can be slight drift for some
count metrics because bot filtering might exclude some events from metrics
computation. Bot filtering can help deliver more accurate performance
measurements. This does not affect A/B testing, which depends on the dimension
external_experiment_ids
, whereas bot filtering is applied to all traffic.
Metrics dimensions
Count metrics are the raw counts directly aggregated from relevant user events
with the same dimensions. To interpret metrics, you need to know which
dimensions the metrics are based upon. For the purpose of analytics metrics,
search and browse events are referred to as
impression events
, and
detail_page_view
,
add_to_cart
and
purchase
events are referred to as
conversion events
. The following table defines metric dimensions.
Metric Dimension
Description
date
The date of the relevant event(s) that generated the metrics.
For impression metrics, this is the date of the impression events.
For session and visitor metrics, this is the date of the first impression event of the session/visitor.
external_experiment_ids
The experiment IDs of the relevant event(s) that generated the metrics.
For impression metrics, this the experiment ID of the impression event.
For session and visitor metrics, this is the concatenation of the unique external experiment ids of all impression events that appears within the session/visitor. For example, if there are two search events within a session/visitor, the first search event has external_experiment_ids 'test_arm_1,test_arm_2', and the second search event has external_experiment_ids 'test_arm_1,test_arm_3', then external_experiment_ids of the session/visitor is 'test_arm_1,test_arm_2,test_arm_3'
device_type
The device type of the relevant event(s) that generated the metrics, for example, if the event is generated from a mobile or desktop device.
For impression metrics, this is the device type of the impression event.
For session and visitor metrics, this is empty if the session/visitor has more than one distinct device type, or the one if there is only one device type for the whole session/visitor.
serving_config
The serving configuration of the relevant event(s) that generated the metrics.
For impression metrics, this is the serving config of the impression event.
For session and visitor metrics, this is empty if the session/visitor has more than one distinct serving configs, or the one if there is only one serving config for the whole session/visitor.
traffic_destination
The source of the relevant event(s) that generated the metrics.
For impression metrics, this is either "Google" if the impression is served by Google or "Non-Google" if the impression is served by your own solution.
For session and visitor metrics, this is "Mixed" if the session/visitor has both impression events served both by Google and your own solution. This is "Google" if the impression events are purely served by Google or "Non-Google" if the impression events are purely served by your solution for the whole session/visitor.
entity
This is used by retailers that serve multiple brand sites or regions with one product catalog. Entity usually represents the brands or locations.
For impression metrics, this is the entity of the impression event.
For session and visitor metrics, this is the top five counted entities of the impression events for the session/visitor.
Impression metrics
Impression metrics are computed according to prerequisites. Conversion events
(
detail_page_view
,
add_to_cart
, and
purchase
events), can be attributed
back to an impression event only if they match the following criteria.
Impression event and conversion event have the same visitor.
The product ID of the conversion event must appear in the impression event's
results.
Conversion event is within the required time window after the occurrence of
the impression event. Different conversion time windows apply for different
types of conversion events.
Conversion path
Conversion time window
Impression -> Detail Page View
60 seconds
Impression -> Add To Cart
24 hours
Impression -> Purchase
48 hours
Search impression metrics
Metric Name
Description
search_event
Search event count
detail_page_view_from_search
Detail page view event count from search
add_to_cart_unit_from_search
Add to cart unit count from search
purchase_unit_from_search
Purchase unit count from search
revenue_from_search
Revenue from search
search_event_without_result
Search event count which yields no results
search_request_personalization_enabled
Count of search requests with personalization enabled
search_request_personalization_result_served
Count of search requests that are served with personalized results
Browse impression metrics
Metric Name
Description
browse_event
Browse event count
detail_page_view_from_browse
Detail page view event count from browse
add_to_cart_unit_from_browse
Add to cart unit count from browse
purchase_unit_from_browse
Purchase unit count from browse
revenue_from_browse
Revenue from browse
browse_event_without_result
Browse event count which yields no results
browse_request_personalization_enabled
Count of browse requests with personalization enabled
browse_request_personalization_result_served
Count of browse requests that are served with personalized results
Session metrics
A session is defined as a continuous period of interaction between a user and
the system. Any user event marks the start of a session, and the end of a
session is marked when no other event occurs for the next 30 minutes. The
session is extended another 30 minutes whenever a user event occurs within a
started session. After a session ends, a new session begins when the user
engages with the system again.
The dimensions that characterize the session metrics are jointly defined by all
user events within the session. Refer to
metrics
dimensions
as how dimensions values are set for the
session.
Metric Name
Description
session
Session count
Search session metrics
A search session is a session contains at least one search event. Note that a
search session can also be a browse session as defined by
browse session
metrics
.
Metric Name
Description
search_session
Session count involving a search
search_event_in_search_session
Search event count within search sessions
browse_event_in_search_session
Browse event count within search sessions
detail_page_view_in_search_session
Detail page view count within search sessions
add_to_cart_in_search_session
Add to cart event count within search sessions
add_to_cart_unit_in_search_session
Add to cart unit count within search sessions
purchase_order_in_search_session
Purchase order count within search sessions
purchase_unit_in_search_session
Purchase unit count within search sessions
revenue_in_search_session
Revenue within search sessions
bounce_count_in_search_session
Session count of the visitor who navigate away from the site after viewing only one page within search sessions
Browse session metrics
A browse session is a session contains at least one browse event. Note that a
browse session can also be a search session as defined by
search session
metrics
.
Metric Name
Description
browse_session
Session count involving browse
search_event_in_browse_session
Search event count within browse sessions
browse_event_in_browse_session
Browse event count within browse sessions
detail_page_view_in_browse_session
Detail page view count within browse sessions
add_to_cart_in_browse_session
Add to cart event count within browse sessions
add_to_cart_unit_in_browse_session
Add to cart unit count within browse sessions
purchase_order_in_browse_session
Purchase order count within browse sessions
purchase_unit_in_browse_session
Purchase unit count within browse sessions
revenue_in_browse_session
Revenue within browse sessions
bounce_count_in_browse_session
Session count of the visitor who navigate away from the site after viewing only one page within browse sessions
Visitor metrics
A visitor is uniquely identified by the visitor ID. Visitor metrics aggregate
all the user event information for the visitor.
The dimensions that characterize the visitor metrics are jointly defined by all
user events for the visitor. Refer to
metrics dimensions
as how dimensions values are set for the visitor.
Metric Name
Description
visitor
Visitor count
Search visitor metrics
A search visitor is a visitor performing at least one search event. Note that a
search visitor can also be a browse visitor as defined by
browse visitor
metrics
.
Metric Name
Description
search_visitor
Visitor count who performs at least one search
search_event_from_search_visitor
Search event count from search visitors
browse_event_from_search_visitor
Browse event count from search visitors
detail_page_view_from_search_visitor
Detail page view count from search visitors
add_to_cart_from_search_visitor
Add to cart event count from search visitors
add_to_cart_unit_from_search_visitor
Add to cart unit count from search visitors
purchase_order_from_search_visitor
Purchase order count from search visitors
purchase_unit_from_search_visitor
Purchase count unit from search visitors
revenue_from_search_visitor
Revenue from search visitors
Browse visitor metrics
A browse visitor is a visitor performing at least one browse event. Note that a
browse visitor can also be a search visitor as defined by
search visitor
metrics
.
Metric Name
Description
browse_visitor
Visitor count who performs at least one browse
search_event_from_browse_visitor
Search event count from browse visitors
browse_event_from_browse_visitor
Browse event count from browse visitors
detail_page_view_from_browse_visitor
Detail page view count from browse visitors
add_to_cart_from_browse_visitor
Add to cart event count from browse visitors
add_to_cart_unit_from_browse_visitor
Add to cart unit count from browse visitors
purchase_order_from_browse_visitor
Purchase order count from browse visitors
purchase_unit_from_browse_visitor
Purchase unit count from browse visitors
revenue_from_browse_visitor
Revenue from browse visitors
Example usage
If you copy or export your metrics data to another destination, you can use SQL
to get high-level or specific information about the exported metrics. Some
common ways to explore your exported metrics using SQL are provided in the
following sections.
Compute click-through rate (CTR)
Compute CTR for search per date per device type per traffic destination.
SELECT
`
date
`
,
device_type
,
traffic_destination
,
SUM
(
detail_page_view_from_search
)
/
SUM
(
search_event
)
as
search_CTR
FROM
copied_table
GROUP
BY
`
date
`
,
device_type
,
traffic_destination
Get browse-driven detail page view count
Get detail page view events that come from browse events for Google traffic with
external_experiment_ids
containing
test_arm
, and display all dimension
information.
external_experiment_ids
is repeated
string
.
SELECT
`
date
`
,
external_experiment_ids
,
device_type
,
serving_config
,
traffic_destination
,
entity
,
detail_page_view_from_browse
FROM
copied_table
WHERE
traffic_destination
=
'Google'
AND
'test_arm'
in
UNNEST
(
external_experiment_ids
)
Get most-used serving configs
Get the most-used serving configs between '2023-10-01' and '2023-11-01' for
Google traffic. Each search event should have an associated serving config.
SELECT
serving_config
,
SUM
(
search_event
)
as
total_search_count
FROM
copied_table
WHERE
`
date
`
between
'2023-10-01'
and
'2023-11-01'
AND
traffic_destination
=
'Google'
GROUP
BY
serving_config
ORDER
BY
total_search_count
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/export-data-into-bq.txt
Export your data into BigQuery  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Export your data into BigQuery
This page describes how to upload retail product and user event data into
BigQuery. After your data is in BigQuery, you'll
be able to use it to perform sales forecasting with Vertex AI and
to view the data in prebuilt Looker dashboards.
If your commerce data is already in product and user event tables in
BigQuery, in Vertex AI Search for commerce format, you can skip this
page and go directly to
Get dashboards that show key performance
indicators
and
Generate sales forecasts from retail
data
. For more information about the
format, see
Product
schema
and
About user events
.
Before you begin
Before you can export your commerce data into BigQuery, you must
have completed the procedures in
Initial setup
.
This includes:
Importing catalog information
.
Recording real-time user events
.
Importing historical user events
.
Create a dataset in BigQuery
You need to create one or two datasets in BigQuery to hold your
product and user event data.
You can use one dataset to hold both types of data
or you can create two datasets, one for each type of data.
You must create the datasets in the same project where you implemented
Vertex AI Search for commerce.
If you haven't used BigQuery in your
project before, enable the BigQuery API and make sure that you
have the IAM role that lets you create datasets and tables.
See
Before you begin
and
Access control with IAM
in the BigQuery documentation.
Create a dataset in BigQuery in the
US multi-region
. For example, name it
retail_data
.
Note:
Vertex AI Search for commerce user event data cannot be exported to non-US regions. Keep in mind that Vertex AI Search for commerce does not use PII. If you choose an EU-based region for the dataset location, your Core BigQuery Customer Data resides in the EU. Core BigQuery Customer Data is defined in the BigQuery
Service Specific Terms
.
Optional: To place your user event data in a separate dataset from your
product data, create a second dataset. For example, name it
retail_user_event_data
.
For more information about creating BigQuery datasets see the
BigQuery documentation
.
This dataset will be used to hold the data tables that you export. The
following procedures describe how to export.
Export your Vertex AI Search for commerce catalog to a BigQuery table
Use the
export
method to export your retail catalog into a
BigQuery table.
Before using any of the request data,
  make the following replacements:
PROJECT_ID
: The ID of the
    Vertex AI Search for commerce API project where you created the BigQuery
    dataset.
BRANCH_ID
: The ID of the catalog
    branch. Use
default_branch
to get data from the default branch.
    For more information, see
Catalog branches
.
DATASET_ID
: The name of the
    dataset that you created in
Create a dataset in BigQuery
. For example, use
retail_data
or
retail_product_data
. The dataset must be in the same project.
    Do not add the project ID to the
datasetId
field here.
TABLE_ID_PREFIX
: A prefix
    for the table ID. This prefix can't be an empty string. A suffix of
_retail_products_BRANCH_ID
is added to complete the table name. For
    example, if the prefix is
test
, the table is named
_test_retail_products_BRANCH_ID
.
Request JSON body:
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
To send your request, expand one of these options:
curl (Linux, macOS, or Cloud Shell)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
, or by using
Cloud Shell
,
            which automatically logs you into the
gcloud
CLI
            .
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
cat > request.json << 'EOF'
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
EOF
Then execute the following command to send your REST request:
curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" \
-d @request.json \
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/branches/
BRANCH_ID
/products:export"
PowerShell (Windows)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
.
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
@'
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
'@  | Out-File -FilePath request.json -Encoding utf8
Then execute the following command to send your REST request:
$cred = gcloud auth print-access-token
$headers = @{ "Authorization" = "Bearer $cred" }
Invoke-WebRequest `
-Method POST `
-Headers $headers `
-ContentType: "application/json; charset=utf-8" `
-InFile request.json `
-Uri "https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/branches/
BRANCH_ID
/products:export" | Select-Object -Expand Content
You should receive a JSON response similar to the following:
{
  "name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/
BRANCH_ID
/operations/17986570020347019923",
  "done": true,
  "response": {
    "@type": "type.googleapis.com/google.cloud.retail.v2alpha.ExportProductsResponse",
    "outputResult": {
      "bigqueryResult": [
        {
          "datasetId": "
DATASET_ID
",
          "tableId": "
TABLE_ID_PREFIX
_retail_products_
BRANCH_ID
"
        }
      ]
    }
  }
}
Export your user events to a BigQuery table
Use the
userEvents.export
method to export your retail user events into a
BigQuery table:
Before using any of the request data,
  make the following replacements:
PROJECT_ID
: The ID of the
    Vertex AI Search for commerce API project where you created the BigQuery
    dataset.
DATASET_ID
: The name of the
    dataset that you created in
Create a dataset
    in BigQuery
. For example, use
retail_data
or
retail_product_data
.
TABLE_ID_PREFIX
: A prefix
    for the table ID. This prefix can't be an empty string. A suffix of
retail_products
is added to complete the table name. For
    example, if the prefix is
test
, the table is
    named
test_retail_products
.
Request JSON body:
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
To send your request, expand one of these options:
curl (Linux, macOS, or Cloud Shell)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
, or by using
Cloud Shell
,
            which automatically logs you into the
gcloud
CLI
            .
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
cat > request.json << 'EOF'
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
EOF
Then execute the following command to send your REST request:
curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" \
-d @request.json \
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:export"
PowerShell (Windows)
Note:
The following command assumes that you have logged in to
          the
gcloud
CLI with your user account by running
gcloud init
or
gcloud auth login
.
          You can check the currently active account by running
gcloud auth list
.
Save the request body in a file named
request.json
.
      Run the following command in the terminal to create or overwrite
      this file in the current directory:
@'
{
  "outputConfig":
  {
    "bigqueryDestination":
    {
      "datasetId": "
DATASET_ID
",
        "tableIdPrefix": "
TABLE_ID_PREFIX
",
        "tableType": "view"
    }
  }
}
'@  | Out-File -FilePath request.json -Encoding utf8
Then execute the following command to send your REST request:
$cred = gcloud auth print-access-token
$headers = @{ "Authorization" = "Bearer $cred" }
Invoke-WebRequest `
-Method POST `
-Headers $headers `
-ContentType: "application/json; charset=utf-8" `
-InFile request.json `
-Uri "https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:export" | Select-Object -Expand Content
You should receive a JSON response similar to the following:
{
  "name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/operations/17203443067109586170",
  "done": true,
  "response": {
    "@type": "type.googleapis.com/google.cloud.retail.v2alpha.ExportUserEventsResponse",
    "outputResult": {
      "bigqueryResult": [
        {
          "datasetId": "
DATASET_ID
",
          "tableId": "
TABLE_ID_PREFIX
_retail_user_events"
        }
      ]
    }
  }
}
About the exported data
Here are things to know about the commerce data that you export to
BigQuery tables:
The data that is exported to BigQuery tables in your
project are
authorized views
, not
materialized views
.
You cannot change or update the data in these tables.
Products are refreshed hourly.
User events are refreshed near-real time.
About the exported user event data
Here are things to know about the product information that is included with the
exported user event data.
Product price information
The way product price information is returned by the
userEvents.export
method
depends on the following:
You included price information in your user event data at the time of
ingestion.
When you call the
userEvents.export
method, the price returned with a user event is the price of the product at
the time of the event.
You did not include price information with your user event data, but
you included price information in your product data at the time of
ingestion.
When you call the
userEvents.export
method, the price returned with a user event is not necessarily the price
of the product at the time of the event. It is the price found in your
product data at the time of ingestion.
You did not include price information with your user event data and
there is no price information available in your product data.
When you
call the
userEvents.export
method, no price is returned with user events.
Other product information
All product information (except price) is joined to user event information at
the time you call the
userEvents.export
method. Product values can change from
the time of the user event to the time you call
userEvents.export
. For this
reason, the non-price product values returned in the user event table could be
different from the product values at the time of the user event.
Optional: Confirm that the new tables are in BigQuery
After you have exported your product data and user-event data to
BigQuery, make
sure that new tables are present.
In BigQuery, navigate to the dataset or datasets that you
created in
Create dataset in BigQuery
.
Open the dataset(s) and make sure you see the two tables that you exported.
For example, look for tables with names ending in
_retail_products_BRANCH_ID
and
retail_user_events
.
For more information about working with BigQuery tables, see
Query and view data
.
Review the
Data governance
page for more information about how Vertex AI Search for commerce handles customer data.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/facets-overview.txt
Facets for search  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Facets for search
This page introduces some of the facet features and how to use them.
Definitions related to facets
This section provides some basic definitions and explanations for some terms
related to facets:
Facets
: The facet specifications to perform faceted search.
They help users find what they want by filtering the results. For example, if a
user searches for
shoes
, some facets that could be returned are:
price
,
attributes.department
,
attributes.colors
, and
attributes.size
.
System attributes
: Predefined
system attributes
are existing product fields that
provide more information about the product. These include a few predefined product attributes
like
brand
,
availability
,
color
, and
size
.
Custom attributes
:
Custom attributes
are
extra attributes that you define using the Product.attributes field. For
example, this could include
style
,
color
or
department
.
Facet key
: This is the name of a facet. For example, it could be
attributes.department
or
sizes
. The facet keys correspond to the
attribute names. For example, the (product) system attribute name
sizes
corresponds to the facet key
sizes
. Similarly, the (product) custom attribute
name
department
corresponds to the facet key
attributes.department
(for
custom attributes, the prefix
attributes.
is added to the custom attribute
name to obtain the facet key). The terms attribute name, facet key, and
facet name are interchangeable.
Facet value
: For textual keys, this is one of the textual values of a
facet. By example, the textual facet key
brands
could have such textual values
as
Asics
and
Nike
. For numerical keys, a facet value is an interval. By
example, the numerical facet key price could have an interval of the form
[20, 30).
Type of an attribute or facet
: They can be either textual or numerical.
Pinned facets
: This is a facet that you pass in the request using the
FacetSpec
with the option
enableDynamicPosition
=false
. The facets should
appear in their original order before all the dynamic facets in the response.
Dynamic facets
: These are facets that search ranks on its
side. They are either passed in the request with the option
enableDynamicPosition
=true
or fetched according to the search models. They are then ranked
by the same trained models with the most relevant ones at the top.
Facetable, dynamic faceting, or tilable
:
When an attribute is enabled for
dynamic faceting
,
search can automatically use this attribute as a dynamic facet
based on past user behavior such as facet clicks and views. To enable dynamic
faceting for an attribute, you must also enable
indexing
for
that attribute.
Filter
: The
filter
syntax consists of an expression
language for constructing a predicate from one or more fields of the products
being filtered. For example, if a user engages the facet values
Asics
of the
facet key
attributes.brands
, then part of the filter could be
(attributes.brands:ANY(\"Asics",\"Nike\"))
.
Filter expression is case-sensitive. See more details about the filter in this
user guide
.
About dynamic facets and tiles
When dynamic faceting is enabled for a
serving config
, search
can automatically use attributes as dynamic facets and tiles in search results for this
configuration, based on past user behavior such as facet clicks and views.
Dynamic facets are either passed in the request with the option
enableDynamicPosition
=true
or fetched according to the search models. They are then ranked
by the same models with the most relevant ones at the top.
By default, most facet keys are facetable. Dynamic faceting settings in the API
can be overwritten for some specific facet keys of your choice by site-wide
attribute controls in the Search for commerce console. In other words, if
you want some facet keys to be non-facetable, you need to disable
dynamic
faceting
for each of these keys in the
Attribute
controls
tab. For more information, see
Managing site-wide attribute
controls
.
Note that dynamic facets and tiles can be created based just on accurate product catalog data. However, for the feature to work
optimally for your site, the facet models need to learn from activity on your
site. For this, you need to set query, category, and filter fields in your
search event uploads accurately.
If none of your serving configs has dynamic facets and tiles enabled and you just enabled
dynamic facets and tiles in a serving config, expect to wait three to four days before they work.
Facet controls
This section provides instructions for creating different types of facet
controls, many of which govern
tile
behavior also:
Ignore facet and tile values controls
Replace facets and tile values controls
Merge facets controls
Set numerical intervals controls
Remove facets and tile controls
Force return facets controls
Rerank dynamic facets controls
Vertex AI Search for commerce performs case-sensitive matching for all these facet
controls unless stated otherwise.
Note:
The last three dynamic facet control types, remove, force return, and rerank, do
not
impact tiles.
To control specific facet values and tile behavior, navigate to the
Facet controls
tab in the Search for commerce console.
Go to the Controls page
Click
Create control
to modify facets returned from search. A
Create control
pane opens. Click the
Control type
field to open a drop-down menu, from which you can select the control type. Each one opens a dialog with options for controlling your facets. All facet control types require at least the attribute information, but each form requires slightly different information.
Create an ignore facet and tile values control
Create an ignore facet and tile values control when you want to remove some unwanted
facet and tile values for some specific facet and tile keys.
Note:
You can only ignore textual attributes. This control does not apply to
numerical attributes.
This control is useful to erase unwanted facet and tile values like
NA
and
Not_applicable
. But, it can also be used to erase seasonal trends like
Easter
if you are in October.
To create a control that ignores facet and tile values:
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Ignore facet and tile values
.
Specify the attribute name.
For example,
brands
for a system
attribute. For a custom attribute, the name starts with
attributes.
—for
example,
attributes.department
and
attributes.colors
.
Optional: Specify
Start Time
and/or
End Time
.
Specify one or more attribute values as
Ignore values
.
For example,
NA
,
Not_applicable
and
Easter
.
Click
Submit
.
Create a replace facet and tile values control
Create a replace facet and tile values control when you want to consolidate a number of
similar facet and tile values into one single term.
Replacing facet and tile values is sometimes referred to as
merging facet and tile values
.
To avoid conflicts and useless mappings, if an attribute value
facet_value_1
is replaced by another attribute value
facet_value_2
, then the latter can't be
replaced by another attribute value. For example, if you replace
ruby
with
dark red
, you can't subsequently replace
dark red
with
red
.
For each attribute name, an attribute value shouldn't appear more than once in
the
Replace values
field.
Note:
This feature works only for custom textual attributes. Numeric attribute
values cannot be replaced. During indexing for each product, both the replaced
values and the replacement values will be included as attribute values unless
you exceed the maximum number of values allowed per custom attribute in a per
product, in which case search will truncate the replacement
values arbitrarily.
To create a control that replaces facet and values:
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Replace facet and tile values
.
Specify the attribute name.
This feature works only for custom attributes, which start with the prefix
with
attributes
—for example,
attributes.department
and
attributes.colors
.
Specify one or more attribute values as
Replace values
- for example,
RED
,
Red
,
dark red
,
bright red
,
ruby
, and
crimson
.
An attribute value can only appear once in the
Replace values
field.
Specify a single attribute value as
Replacement term
- for example,
red
.
Click
Submit
.
Although the replaced values might disappear quickly, the replacement
terms can take up to four days to appear.
When the replace facet values control takes effect, if the facet key (in this
example
attributes.colors
) is returned in the response, the replaced facet
values (such as
dark red
and
crimson
) won't be present as facet values. They
are replaced by their replacement terms (for example,
red
).
Create a merge facets control
It is better to set correctly the product custom attribute names and values on
your side before the products are ingested into search's
database. However, if you can't change custom attribute names, you can create
merge facets controls. You create a merge facets control if you want to
merge (replace) a facet with another facet. For example, you might have
several custom facet keys for colors like
attributes.colors_jeans
,
attributes.colors_clothes
and
attributes.colors_hue
and you want to replace
them with an existing custom facet key called
attributes.colors
.
Note:
You can only merge a textual facet into another single textual facet. Similarly, you can
only merge a numerical facet into another single numerical facet. You
can merge a facet into at most one merged facet. You can merge several
facets into the same merged facet. Both a key and its
merged key should be valid custom attribute names (with the added prefix
attributes.
). In other words, these two keys should be the custom attribute
names of some ingested products.
Preferably, merged keys should be:
Custom attribute names that are permanent and won't change type.
Attribute names of many ingested products.
If you delete a merged key, you lose its engagement data, which is
used to train dynamic facet models.
During indexing for each product, both the keys and the merged keys are
included as attribute names, unless you exceed the maximum number of attributes
allowed per product. If the maximum number of attributes exceed the quota allowed per product, search arbitrarily truncates
the merged keys that become attribute names.
For example, if you already have the maximum number of custom attribute names for a specific product
and one of its custom attribute names is
colors_jeans
, suppose you
use a merge facets control to merge
attributes.colors_jeans
into
attributes.colors
. In this case, the attribute name
colors
won't be added to this
specific product as it already contains the maximum number of custom keys per
product. The merged keys won't be deleted from the (custom) attribute names of
products, but they won't be returned as dynamic facet keys either. Similarly, if you
merge several keys with the same key and this results in the number of
attribute values for the merged key exceeding the limit of attribute values
allowed, search arbitrarily truncates the attribute values.
To create a control that merged a facet into another:
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Merge facets
.
Specify a valid custom facet key that merges into another one.
This feature works only for custom attributes, which start with the prefix
with
attributes
—for example,
attributes.colors_clothes
and
attributes.colors_jeans
.
Specify a valid custom facet key as the merged key.
Click
Submit
.
This control typically takes effect in 2-4 days.
Create a set numerical intervals control
The set numerical intervals control lets you determine the intervals for
a numeric facet or tile instead of having to accept calculated intervals.
For example, search might calculate the intervals [10,15),
[15,20) [20,25), [25,30), [30,40) and [40,50) and [50,infinity) for the custom
numerical facet key
attributes.monitor_size
. But, you might prefer the
intervals [0,14), [14,17), [17,21), [21,24), [24,27), [27,32) and [32,infinity)
instead.
About calculated intervals and set intervals
Note:
Search calculates intervals only if you have at least one
serving config
with
DynamicFacetSpec
set to
Enabled
.
For all numerical custom attributes and the numerical system attributes
price
,
rating
and
ratingCount
, search calculates some intervals
with round bounds based on the distribution of all the (numerical) attribute
values for each of these attributes. You can also specify some intervals in the
request. As a last option, you can set your own intervals for each numerical
facet key using the following
set numerical intervals
controls.
Here is the priority order that determines which intervals are used:
First, if some intervals are specified in the request for a numerical facet
key, these intervals are kept.
Otherwise, if a numerical facet key is dynamic or passed in the request
without intervals, then the intervals that you include using the
set numerical intervals
controls are added to that
numerical facet key if these intervals are non-empty.
Otherwise, the previously mentioned calculated intervals with round bounds
are be added.
Create the control
If you want to specify your own intervals for numeric facet and tile keys instead of
using the ones that Vertex AI Search for commerce calculates for you, then create a
set numerical intervals controls.
Note:
You can only set intervals to numerical attributes.
To create a control for adding intervals:
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Set numerical facet and tile intervals
.
Specify the name of a numerical attribute.
For example,
price
for a system
attribute. For a custom attribute, the name starts with
attributes.
—for
example,
attributes.number_of_pieces
.
Specify at least one of
Minimum
or
Maximum
. If both are specified,
the minimum can't be greater than the maximum. You can choose each bound to
be
Inclusive
or
Exclusive
.
To add more intervals, click
add_box
Add intervals
. The maximum number of
intervals is 40.
Click
Submit
.
Create a control for removing facets and tiles
The remove facets control lets you to remove a specific facet and tile key from the
dynamic facets. Facet and tile keys are removed based on some given query terms or
page categories.
This facet control type controls the attribute itself. No facets or tiles associated with this facet as members will be returned in the search if this facet control type is applied.
This control is useful if you want to remove some facet and tile keys for some query
terms or browse. For example, you can use this control to remove the facet key
attributes.shoe_size
for the query
shoes
.
You can use the Merchandising console or the Google Cloud console to remove a facet or tile:
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
product, then choose the control type
Remove facets
.
Configure your
Remove facets
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Attribute to ignore
under the
Remove facets actions
section for attirbutes you don't want to appear in dynamic facets for the query terms specified under the previous
Triggers
section.
Click
class="material-icons">add_box
Add attribute
to add more
attributes.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request
for a
Remove facets
control.
Cloud console
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
. The
Create control
pane opens.
Select
Remove facets and tiles
.
Each control is for search or browse, but it can't apply to both. Do one
of the following:
For search queries, click
Search
and specify some partial
query terms or some exact query terms to match. See detailed
information in
query terms
and
conditions
. The query terms need to be lowercase for
both cases. For example, you can specify the partial query terms
shirts
,
polo
,
jackets
,
t-shirt
and
fall coats
and the
facet keys specified next won't appear as a dynamic facet if the
lowercase query is one of these query terms or contains any of these
query terms as a unigram.
For browse, click
Browse categories
and specify some page
categories. You can specify a list (up to 10 entries) of categories or
departments. The format should be the same as the user event
page categories
. For
example, it could be
page_categories
:
Sales > 2023 Black Friday Deals
. If there is an
exact match (case sensitive) between the latter and one of the page
categories passed in the event (for browse), then the facet keys
specified next won't appear as a dynamic facet.
Specify at least one valid facet key in
Attributes to ignore
.
Click
Submit
.
Create a force return facets control
The force return facets control can affect the list position of a dynamic facet
key for a specific query or browse event.
This control is useful if you want to force a specific facet key among the
dynamic facets for some query terms or browse. For example, you can use this
control to force the facet key
brands
to appear to position 10 or a smaller
position for the query
handbags
. If the facet
brands
is already in the top
10 for the dynamic facets for this query, then it shouldn't move much. If it is
not in the top 10 or not in the list of dynamic facets, then it should move to
position 10 approximately.
You can create a control for force return facets in the Merchandising console or the Google Cloud console.
Merchandising console
Click the URL provided by the administrator. Sign in.
This takes you to the
Controls
page in the
Merchandising console
.
Click
add_box
Create control
.
Define the goals for your end users and timing required. All questions
are required to be answered. Click
Next
.
Select a control
. Enter the name for your control, select the
Search
or
Browse
product, then choose the control type
Force return facets
.
Configure your
Force return facets
control:
Under
Triggers
, define what catalog attribute triggers this
control by giving criteria to a related search query, such as
contains
or
not in range
. If no catalog attribute has been configured, this
control will always apply.
Define an
Applicable time range
by entering a
Date range
. If
any of the specified time ranges are met, the catalog attribute will be
matched with the query during any of the specified time ranges. Add a time range with
add_box
Add time range
.
Define the
Attribute position adjustment
under the
Force return facets actions
section. Here you can choose an attribute that you want included in the dynamic facets or tiles for the query or page category you set in the previous
Triggers
section. Choosing a position of 5, for example, sets the facet to appear at the fifth position from the bottom of the page or higher.
Click
add_box
Add adjustment
to add more
attributes to be governed by this control.
Click
Submit
to submit your control request to an Approver. You will
be able to see the status of submitted requests in the Merchandising
Console. If you change your mind, you can delete your control request.
Approver steps
Under
Serving configs,
assign your control to existing serving
   config.
Approve the request
for a
Force return facets
control.
Cloud console
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Force return facets
.
Each control is for search or browse, but it can't apply to both. Do one
of the following:
For search queries, click
Search
and specify some partial
query terms or some exact query terms to match. See detailed
information in
query terms
and
conditions
. The query terms need to be lowercase for
both cases. For example, you can specify the partial query terms
shirts
,
polo
,
jackets
,
t-shirt
and
fall coats
and the
facet keys specified next should appear around their respective
position or higher among the dynamic facets if the lowercase query is
one of these query terms or contains any of these query terms as a
unigram.
For browse, click
Browse categories
and specify some page
categories. You can specify a list (up to 10 entries) of categories or
departments. The format should be the same as the user event
page categories
. For
example, it could be
page_categories
:
Sales > 2023 Black Friday Deals
. If there is an
exact match (case sensitive) between the latter and one of the page
categories passed in the event (for browse), then the facet keys
specified next should appear around their respective position or
higher among the dynamic facets.
Specify a valid facet key and an integer position between 1 and 100
(inclusive).
If you want to specify more than one facet key, click
add_box
Add adjustment
and redo the previous step.
Click
Submit
.
Create a rerank dynamic facets control
The dynamic facet ranking depends on the query (search) or page categories
(browse). The rerank dynamic facets control also allows the ranking to depend on
some facet values engaged by the user.
For example, using this control, if the
user engages the facet value
watches
of the facet key
attributes.department
following a search or browse, then the ranking will also depend on the facet
value
watches
. You can specify the facet values that you want to rerank on by
facet key, or specify only the facet key and rerank on all its facet values.
Note:
You can use this control only for custom facetable textual keys. To use
this control, you also need to pass all the facet keys engaged by the user in
the request using the field
FacetSpec
. In particular, if you
don't pass the facet keys engaged that you want to rerank on, this control won't
be effective. Moreover, to obtain better results, the facet values that you want
to rerank on should be close to English (ideally made of words, underscores, and
spaces).
To create a control for rerank dynamic facets:
Go to the Controls page in the Search for commerce console.
Go to the Controls page
On the
Facet controls
tab, click
add_box
Create control
.
The
Create control
pane opens.
Select
Rerank dynamic facets
.
Specify a valid custom textual facet key (all custom keys have the prefix
attributes.
).
You can either specify some specific facet values or apply to all.
If you want to rerank on all its facet values, click
add_box
Any value changes
.
If you want to rerank on specific facet values, click
add_box
Selected values changes
.
 Then insert all the facet values that you would like to rerank on
 (case sensitive). For example, it could be
watches
,
luggages
,
bed
.
Click
Submit
.
You need to pass all the facet keys engaged by the user in the request
for the following reasons:
Suppose that a user browses for sales and gets a
first list of facet keys presented.
Then, the user engages first the facet key
attributes.age_group
.
Next, they engage the facet key
attributes.department
with the facet values
watches
, for which you set up a control to rerank on.
At that point, search reranks the keys.
So, it is possible that the previously engaged facet key
attributes.age_group
won't be returned in the
response. If you pass this key in the request (using a
Facetspec
with
enableDynamicPosition
set to
true
),
it will automatically be returned in the response.
However, search could return that key at position 27 and you might show
only the first 20 keys to the user. Because of this, make sure that these keys previously engaged by the user will be
shown to the user. If you don't want to show too many keys to the user, you might have to filter out some intermediate non-engaged
keys in the response.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/faq.txt
Frequently asked questions  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All resources
Pricing
Quotas and limits
FAQ
Overview
Conversational features
Search for commerce console
Release notes
Data use terms & conditions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Resources
Send feedback
Frequently asked questions
Have other challenges or don't see your issue outlined here?
Report a bug or request a feature
and join the
cloud-recommendations-users
Google group or
Stack Overflow
discussions.
General
These are general frequently asked questions.
1. Do you have client libraries for Vertex AI Search for commerce or more sample code?
Yes. You can see the
client libraries guide
for setup and reference information for each library.
The
Google API Discovery Service
can also be used instead of raw REST calls.
2. Are all the recommendation models personalized?
The Recommended for You, Others You May Like, and Buy it Again models make personalized recommendations when
provided with user history. The Frequently Bought Together and Similar Items models are not
personalized.
See
About recommendation models
.
3. Will I receive personalized recommendations immediately, or will I need to wait for these to improve over time?
Recommendations improve as you collect more user history. The Recommended for You model
shows popular products and the Others You May Like model shows similar products based
mostly on other's views. Both of these models start taking user behavior into
account immediately, so it's important to send real-time events. See
About recommendation models
.
User events need to be sent in real-time, or very close to real-time, for
personalization to be effective. If user events are only submitted daily, or in
batches throughout the day, the personalized models may not perform as well as
they could if real-time events were sent.
4. Are you using Google user demographic data in your models?
The models only use the catalog and user event data that you provide. If you
want to include demographic data, you can include other textual or numerical
information that might be useful as
custom attributes
. This
data will begin to be used by the model after it has been retuned.
Don't include personally identifiable information (PII) such as email addresses
or usernames. We suggest you anonymize demographic data, such as by hashing the
values or using group IDs.
5. Can I make recommendations based on the event history of a group of users rather than a single user's history?
Recommendations are based on a single visitor ID or user ID. You
would need to make individual requests and then combine the results to base
recommendations on a group's history. If the users have common metadata
attributes, you could use group IDs as user IDs to provide group-level
recommendations.
6. I noticed that you can submit image URLs for products. Do the models take into consideration the product images?
Yes, product images can be submitted as part of your product catalog data. Vertex AI Search for commerce uses product URLs and the identifiers behind them (URIs) to
enrich product descriptions
.
The
Product
object contains an images field, which is a list of image objects. Each image object can include a URI, height, and width. Up to 300 images are allowed per product.
While optional, providing product images is highly recommended. (
Prediction preview
) also uses image
URLs to display the images when you preview a model's prediction results in the
Search for commerce console.
7. My company isn't a retail ecommerce website. Can I still use recommendations for predicting x,y,z?
We've had customers use recommendations for content
recommendations, video streaming and gaming, and other use cases. However, our
content and experience is designed with the retail ecommerce use case
in mind and may not be suited for other use cases yet.
8. Can I place recommendations on any page of my site?
Yes, but the models are each designed for specific use cases and may work best
on certain pages. See
About recommendation models
.
Frequently Bought Together and Others You May Like require item IDs, so they should be used for
recommendations using, for example, a product ID or items in a cart. Frequently Bought Together
typically works best on add-to-cart or checkout pages, while Others You May Like and
Similar Items work best on product detail pages. Recommended for You could be placed on any
page, since it only requires a visitor ID as input, but it is designed as a home
page serving config. Buy it Again is designed to be placed on any page.
9. Can I use recommendations for recommendations in email newsletters?
Yes. This can be done by making a call to the API with a visitor ID or user ID,
then incorporating the results into an email template. If you want the items to
be loaded dynamically at email-read time, you would need to use an intermediary
endpoint, such as a
Google Cloud Function
, to send the predict
request. The API only provides a list of ordered product IDs and metadata, so
you will also need to write your own code to render the image results.
10. Can I use Vertex AI Search for commerce for other non-web use cases (mobile apps, kiosks)?
Yes. You can set up an endpoint (for example,
Google Cloud Function
) to get results for the app. You also
need a similar mechanism to send real-time events.
11. I don't have 3+ months of event data. Can I still use Vertex AI Search for commerce? Can I add more data at a later point?
The Similar Items model does not use user event data or model tuning. If you don't
have any event data, you can still create and train a Similar Items model as long as
you have catalog data.
If you can record sufficient traffic for real-time events, recent data can be
used for training other models. If you have additional data available at a later
date, you can upload it after the initial model training. The newly backfilled
data gets incorporated into the models during daily retraining. However, if the
data is significantly different than the events that were used for the initial
training, the models may need to be
retuned
.
Most models work best with at least three months of product page views, home
page views, and add-to-cart events for all models, and ideally one to two years
of purchase history for the Frequently Bought Together model.
One to two weeks of detail page views can be enough to start training Others You May Like
and Recommended for You models, while Frequently Bought Together and Buy it Again usually require more because there
are typically fewer purchases per day than there are page views. Model quality
can be significantly improved with more data; the minimum amount might not produce
optimal results. A year's worth of purchases, for example, allows the models to
better take advantage of seasonality and trends.
12. Can I recommend categories along with products?
Recommendations returns product recommendations only,
but you can get the categories for each product returned as part of the results.
13. Do you have integrations for uploading data from SQL databases or other systems, such as BigQuery?
Yes. For events, there is
sample code
that reads from
BigQuery. See a
Google Analytics sample dataset for BigQuery
.
14. Does Vertex AI Search for commerce use cookies?
No, it doesn't use cookies. However, all events sent to
the Vertex AI Search for commerce must have a visitor ID specified, which is often a
session identifier from a cookie.
15. Do I need a dedicated Google Cloud project?
You can create a new, dedicated project, or
enable Vertex AI Search for commerce in an existing project.
16. Why aren't my credentials working when using Cloud Shell?
Check that you've completed the
authentication setup steps
for
Vertex AI Search for commerce. You should be using a service account that you've made
available in your environment. Otherwise, you might get an error like this:
Your application has authenticated using end user credentials from the Google Cloud SDK or Google Cloud Shell which are not supported.
For more about service accounts, see the
Authentication section
of the Google Cloud
documentation.
17. How can I compare Vertex AI Search for commerce to similar solutions?
You can conduct
A/B tests
to compare results from
Vertex AI Search for commerce to those of other products.
18. I think feature x,y,z would be great. Can you add this?
We'd love to hear from you. Feature requests can be submitted through your
account team, Google Support, or the
issue-tracker
.
19. Can I still use the old API for recommendations?
Recommendations has migrated from the Recommendations Engine API
to Vertex AI Search for commerce. If you were using the Recommendations Engine API while
it was in beta, we recommend migrating your recommendations to
Vertex AI Search for commerce (service endpoint
https://retail.googleapis.com
),
which is GA.
The previous API (service endpoint
https://recommendationengine.googleapis.com
) and its
documentation
remain available, but they are no longer updated.
Catalogs and products
These are frequently asked questions about catalogs and products.
1. How does recommendations handle cold starts for new products?
For products that don't have any purchase history, we make recommendations
based on similar products. In these cases, it is especially important to have
good product titles, categories, and descriptions defined in the catalog.
For cold-start users (visitors with no history) the models start with the most
popular general products, and become more personalized in real time as more user
events are received.
See
About catalogs and products
and the
product reference page
.
2. Can I use my Merchant Center catalog for recommendations?
Yes, you can export a Merchant Center catalog to
BigQuery using the Merchant Center Data Transfer
Service. Then we can read the catalog directly from BigQuery. See
Import catalog data from Merchant Center
.
3. How else can I import my catalog?
Merchant Center
: Import with
Merchant Center. If you use search, you can
use the console to link Merchant Center so that its catalog
syncs automatically.
BigQuery
: Import directly from a table or view.
Cloud Storage
: Import using text files with one JSON catalog
item per line.
Inline import
: Import with an API call, using text files with
one JSON catalog item per line.
Create product items
: Use the
Products
create method.
4. How can I keep my catalog updated? How often does the catalog need to be updated?
See
Keep your catalog up to date
.
We recommend updating your catalog daily. You can do a full update from
Cloud Storage or BigQuery, or an incremental update
(i.e., new and changed items only).
If possible, update price and availability in real time. This affects how
quickly new items can be made searchable with search.
If you have a way to be notified of catalog changes (such as using
Pub/Sub, message queue, events, etc.) then you can update the
catalog in real-time using the
import
or
create
API
methods.
For example,
Cloud Scheduler
can be used to make a daily
BigQuery import call.
5. Are there minimum and maximum catalog sizes?
There is no minimum, but very small catalog sizes (< 100 items) may not see much
benefit from recommendations due to there being very few different products to
recommend.
The catalog maximum is 40 million items.
See the documentation for default
quotas and limits
and for how to
request a change to your quota.
6. My company operates websites in multiple countries. Should I use one catalog for all of my data?
It is usually best to have just one catalog with all items. Events must be
submitted all using a single currency. There is no way to have
multiple catalogs within the same project, but, if you use
entities
,
you can specify search, recommendations, and autocomplete behavior for a
particular country.
If the catalogs are considerably different between websites, we recommend having
a separate project for each website. Also, if the countries have different
languages, we recommend having separate projects, one for each language.
If there are similar websites with low traffic compared to the main website, it
may be best to use a single catalog if there are not enough events to produce
high quality models for all individual websites.
To use a single catalog, the catalog item IDs should be consistent, i.e., the
same product should have a single item ID on all websites so that there is no
duplication of products within the catalog.
For recommendations only, an alternative to using entities is to filter to a
specific website using
filters
. However, filters may take up
to 8 hours to update, so if there are country-specific availability (out of
stock) requirements, they normally need to be handled by a business rule that
filters out the results after the predict response. This applies to v1
filter_tag
filtering and v2 attribute-based filtering.
7. Does Vertex AI Search for commerce support multiple currencies per catalog?
No, only one one currency type per catalog is supported. Events
must be uploaded using a single currency.
If you plan to use the
Search for commerce
console to get your revenue
metrics, make sure your events all use a single currency or convert them all to
the same currency before uploading them.
8. I have multiple websites with a shared catalog or similar items. Can recommendations provide cross-site recommendations?
We typically recommend using a single catalog like this only if there is
significant overlap between the sites; they should share many or all of the same
products. Then, as with multi-region sites, you can use
entities
or
filter tags
to return only site-specific items for a particular
predict call.
If the sites don't share many, or any, catalog items,
then multiple catalogs should be used. Using multiple catalogs
requires a separate Google Cloud project for each catalog.
9. Does including more metadata improve the model? Does the model consider fields x,y,z?
See
Required catalog item information
for required fields.
Other metadata fields are optional (for example, images and itemAttributes). They may be
used for prediction preview, results analysis, training, and tuning. We
recommend including useful attributes such as color, size, material, etc. These
fields can be returned as part of
predict
results by specifying
returnProduct:true
, so they can be useful for rendering
results. Images and item attributes are used for
prediction preview
in the Search for commerce console.
10. Which attributes of a catalog item are used as inputs of model training?
A combination of both user behavior and product attributes is used. The primary
fields used are ID, title, category hierarchy, price, and URL. You can include
other custom key-value attributes that might be useful in
Product.attributes[]
.
Image URLs are more of a convenience feature; you can return this metadata as
part of the
prediction
results by specifying
returnProduct:true
, which can save an extra call to retrieve
this information. Having image URLs also allows
prediction preview
to display the images when you preview a model's prediction results in the
Search for commerce console.
11. What languages are supported for my products?
The
recommendations feature
: Supports most languages. The model
automatically detects the text language. For a list of all languages that can
be automatically detected, see the Compact Language Detector
GitHub
README
.
The
search feature
: Supports
these world languages
.
You set the language when you upload the catalog. The
catalog should be in one language only and the queries should be sent in the
same language. Having multiple languages in the catalog degrades model
performance. For example, if the catalog is in Spanish but the search query is
in English, the query is not translated the query to Spanish.
Note:
If you already have a mixed language catalog for
search, you can improve results by adding synonyms for
search query terms. For example, add both Spanish and English synonyms. For
information about synonyms, see
OnewaySynonymsAction
and
TwowaySynonymsAction
.
12. My catalog has primary/variant or parent/child SKUs. Are these supported?
Yes. This would be similar to the
item_group_id
in
Merchant Center. You need to determine how you want to get
recommendations back (at the parent or child level) and if the events are at the
parent or child level.
See
Product levels
for more about product levels.
Determine and set your correct product level before sending any items or events.
The product level
can be changed
, but requires rejoining the
items and retuning the models.
13. Can I delete products from the catalog when they are no longer available?
If an item is no longer current, we recommend that you set its status to
OUT_OF_STOCK
rather than deleting it, so that previous user events that
reference it are not invalidated.
User events
These are frequently asked questions about user events.
1. What user events do I need to collect?
See
About user events
for a list of user event types
as well as user event requirements and best practices.
2. How do I troubleshoot data quality issues in model creation?
In the Search for commerce console, go to the
Data Quality
page for data
quality metrics about your ingested catalog and user events.
3. Can I integrate with Google Analytics 360?
You can use historical data from Google Analytics 360 (GA360). Similar to
Merchant Center data, GA360 data can be exported to
BigQuery, and then Vertex AI Search for commerce can read the events
directly from BigQuery.
For real-time events, we recommend integrating tracking pixels with
Google Tag Manager, because events are delayed from GA360.
4. I want to import user events from Google Analytics 360. Does it provide all the user events needed?
Google Analytics 360 natively supports all user events used by
Vertex AI Search for commerce except for search events. You can still import search
user events from Analytics 360, but note that
Vertex AI Search for commerce constructs the search user event from search queries and,
if present, product impressions.
5. How do I feed events into Recommendations AI?
Cloud Storage
API inline import
JavaScript Pixel
Google Tag Manager
API write method
Users typically import historical events using Cloud Storage or API import,
then stream real-time events using the JavaScript Pixel or Tag Manager
tag on the live site, or using the write method on the backend.
6. What if I can't send all of the user event types listed as required for a model? What are the minimum event types needed for each model?
Each model and optimization objective has slightly different requirements. See
the
User event data requirements
.
Model performance is typically better when there are more events per catalog
item. For sites with large amounts of traffic and smaller catalogs, you may be
able to start with a smaller volume of historical events, but still typically
need at least a few weeks of historical data as well as real-time events going
forward.
7. I have add-to-cart and purchase-complete events that don't have a value for revenue or quantity. What should I submit?
If you don't have a value for quantity, you can pass a default value of 1
without affecting model results. Items should always have displayPrice set (this
can be whatever is shown to the user, such as a discount price). The
originalPrice and cost are optional.
8. My data only covered limited types of events. Can I still use Vertex AI Search for commerce?
See
User event data requirements
for the minimum data requirements
of each model type.
Search results
These are frequently asked questions about search results.
1. Are search results personalized?
Yes. Search can provide personalized results.
Search results are personalized based on visitor IDs.
For more information, see
Personalization
.
2. How do I include context, like the store a user is shopping from, as part of the search request?
Store ID-based availability and fulfilment options are attributes of the product
catalog. Fulfilment options are attributes such as "delivered online", "buy
online", and "pick up in store".
Attributes can be sent as a parameter in the search request. So, for this
example, the search request can specify the user's store ID. The results can be
filtered or ranked higher based on the store ID in the request.
3. Can I hide products from search results?
Yes. The
filter
parameter can filter results out based on
their tags.
4. Is it possible to rank on multiple criteria, such as both availability and price?
Yes, the
boostSpec
allows complex ranking rules.
5. Is it possible to group some attributes in order to deliver results with multiple facets? For example, grouping cities in the same country for origin of production.
Product attributes are not hierarchical. However, you could use multiple custom
attributes to accomplish this. In this example, you could use custom attributes
for both country of production and city of production.
6. How do suggestions work?
Suggestions are a combination of user queries, rewritten queries, product names
etc. To generate high quality autocomplete suggestions, a sufficient
number of search events should be ingested along with the catalog.
Prediction results
These are frequently asked questions about prediction results.
1. Is there a limit to the number of predictions I can return?
By default, a prediction request returns 20 items in the response. This can be
increased or decreased by submitting a value for
pageSize
.
If you need to return more than 100 items, contact Google Support to increase
the limit. Note, however, that returning more than 100 items can increase
response latency.
2. Am I able to view the reasons why a model made a specific product recommendation?
No.
3. Can I download and cache prediction results?
Since prediction results improve in real-time in response to user activity on
your site, we don't recommend using cached predictions. The models retrain
daily to incorporate changes to your catalog and react to new trends in user
events, which also changes results.
4. I need to re-rank the returned recommendations based on a business rule. Is this supported?
Yes. But while you can re-rank the returned recommendations based on your
business rules, be aware that re-ordering or filtering recommended results can
reduce the overall effectiveness of the model at achieving the optimization goal
that you chose.
Price reranking orders relevant high-priced items first in the set of
recommendations returned and is available as a built-in customization for the
Others You May Like and Recommended for You models.
See
Price reranking
.
5. Are there restrictions on the number of filter tags that I can create and use?
There are no hard limits on the number of unique tags that you can create or
use. However, the system is not designed to handle many filter tags per item. We
recommend keeping filter tags limited to a maximum of 10 per catalog item if
possible. More than 10 values can be used across the entire catalog; this is a
per-item limit. The limit for total tags (the total sum of all per-item tag
counts) is 100,000,000.
See the documentation for Vertex AI Search for commerce
quotas and limits
.
6. Can I diversify recommendations?
Yes.
Recommendation diversification
can be specified as part of the serving
configuration or in the predict request
parameters
.With low
diversification, predictions may contain similar items in the same category.
With higher diversification, the results will contain items from other
categories.
7. Can I prioritize recommendations by price?
Yes.
Price reranking
causes recommended products with a similar
recommendation probability to be ordered by price, with the highest-priced items
first. Relevance is still also used to order items, so enabling price reranking
is not the same as sorting by price. Price reranking can be specified as part of
the serving config or in the predict request parameters.
Conversational features
These are frequently asked questions about Vertex AI Search for commerce's conversational features, product filtering, and commerce.
1. How is a conversational session maintained, and how do I refresh the context?
A conversational session is maintained using the conversation ID returned in the Conversational Commerce agent response. You must pass this conversation ID in all subsequent requests within the same conversation. The system retains all context associated with this ID. To refresh or start a new conversation with a clean slate, initiate a new API request
without
a conversation ID, and a new conversation ID is issued in the response.
2. How does the streaming API affect my implementation and user experience?
The streaming nature means that you can immediately receive query types. This lets you differentiate between queries that have a conversational text response, which may have higher latency, and those that won't like
SIMPLE_PRODUCT_SEARCH
. For
SIMPLE_PRODUCT_SEARCH
, you can immediately trigger a call to the core Search API for quick product display. For LLM-driven responses, you can show loading indicators or fetch search results in parallel while the conversational text streams in, optimizing the perceived responsiveness for the user.
3. Why is it important for
searchParams
in the
ConversationalSearchRequest
to mirror my core Search API calls?
You want to maintain consistency in your
searchParams
, such as filters, sort order, boost rules between your
ConversationalSearchRequest
and your
SearchService.Search
calls. Maintaining consistency helps to ensure that any conversational answers or refined queries provided by the API are aligned with the actual product results being displayed to the user. This prevents discrepancies and provides a coherent shopping experience.
4. If a basic product search is detected, does the conversation end? Can the user go back to other conversational modes?
The conversation
doesn't end
. The conversation ID remains valid. However, from a UX perspective, retailers often transition the user to a standard search results page. If the user then submits a new query
without
the original conversation ID, such as typing directly into the standard search bar, a new conversation session starts. Retailers can, however, design their UX to keep the chat window persistent and allow users to continue the conversation (especially if
conversationalFilteringSpec.mode
is
ENABLED
to enable follow-up questions). The ability to "revert back" to a rich conversational mode depends on this specific UX implementation choice.
5. What data does the Conversational API store for conversation context, and for how long?
To maintain the flow of a conversation, the Conversational API stores the user query, the conversational text response, and the follow-up question that are linked to the conversation ID. This contextual information is retained for
seven days
to ensure that when you pass the conversation ID in subsequent requests, the system can retrieve and utilize this history.
6. Why doesn't the Conversational API provide suggested answers for follow up questions, similarly to how conversational product filtering does?
While providing suggested answers to follow up questions isn't supported, it is on our roadmap to provide this capability. Stay tuned!
7. How does the Conversational API use caching for performance and context?
The Conversational API caches the query types and refined search queries for a given customer and project for up to
10 days
. This means that if the same query is repeated, then the system can quickly retrieve the intent and suggested refinements.
Models
These are frequently asked questions about models.
1. I've uploaded my catalog & events, but I'm still getting this response when I call the predict API:
Recommendation model is not ready.
You can set 'dryRun'
to true in prediction request for integration purpose, which returns
arbitrary catalog items from your Catalog (please DO NOT use this for production
traffic)."**
This usually means that your model has not finished training. If it has been
more than 10 days since you created the model and you are continuing to get this
response, please contact Support.
2. How long does it take to train a model?
Initial model training and tuning takes 2-5 days to complete, but can take
longer for large datasets.
 Subsequently, models are automatically
retrained daily unless disabled. See
Pause and resume training for a model
.
3. Can I download or export the model?
No.
4. Can I use models I created in an existing project in a new project?
No. You need to
create and retrain
the models in the new
project.
5. I want to use a model for my category pages. Can I do that?
Yes. Recommended for You is useful on category pages. 
A category page is similar to a home page, except that you display only items from that category.
You can achieve this using a standard Recommended for You model with filter tags.
For example, you can add customized filter tags (corresponding to each category page) to the items
in your catalog. When you send the prediction request, set the user event object as
category-page-view
and specify a specific category page's tag in the
filter
field. Only recommendation results matching the requested filter tag are
returned. Diversity should be disabled in this use case, because diversity can conflict with
category-based filter tags.
6. Can I disable personalization for my models?
By default, prediction results are personalized by user for the
Others You May Like
,
Recommended for You
, and
Buy it Again
recommendation model types.
Disabling personalization isn't recommended because it can negatively impact
model performance.
If you need to show catalog items relevant to the product being viewed rather
than based on the user's previous engagements with your site, it is possible to
receive non-personalized recommendations by using a random unique visitor ID in
a prediction request. Make sure you only do so for requests in serving
configurations that you don't want to be personalized.
Search for commerce console
These are frequently asked questions about using the Search for commerce console.
1. I purged a number of events, but the dashboard still shows the counts for those event types.
This is expected. The Search for commerce dashboard shows the number of
events ingested over a certain period of time; it doesn't show the current count
or number of events.
Generally, you should leave user events in place after they have been recorded.
Purging events is not recommended. If you plan to reset user events entirely,
consider creating a new project instead.
If you do need to purge events that have not been recorded properly, see the
documentation for
Remove user events
. An event purge can take
up to several days to complete.
2. How can I tell if there are errors with my catalog or user events?
Most API calls for catalog item updates or user events return an error if there
is a problem with syntax or the request can't be processed for some reason.
The Search for commerce dashboard shows percentage of unjoined events, which
is also a useful metric to use for spotting catalog or event issues. Unjoined
events (or unjoined predict calls) happen when an item ID is specified that
isn't in the catalog. This usually means the catalog is out of date and the new
or changed catalog items need to be uploaded, but it can also be due to bad item
IDs being passed. Check your requests to make sure the item IDs map correctly to
the catalog, then check the catalog you uploaded to be sure the items exist.
Cloud Monitoring
and
Cloud Logging
can be used to
monitor the status of events. For example, you can receive alerts if there are
no events over a given period of time, or if predict calls drop below a certain
threshold.
3. Why do my recommendation serving configs show as inactive? How do I activate them?
In order to use recommendation serving configs, you first need to submit
catalog
and
user event data
to train the corresponding
model. Once a model has been trained, the dashboard indicates that the model
is ready to query.
4. In what currency does Search for commerce report revenue metrics?
Search for commerce reports metrics in the currency used in
your uploaded data. Vertex AI Search for commerce does not support using multiple
currencies per catalog and does not convert currencies.
If you plan to use the Search for commerce console to get your
revenue metrics, make sure your events all use a single currency or convert
them all to the same currency before uploading them to Vertex AI Search for commerce.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/features.txt
Features and capabilities of Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Features and capabilities of Vertex AI Search for commerce
Within the Vertex AI Search for commerce product, you get both the recommendations capability
and the search and browse capability.
You can upload and manage product catalog
information and user event logs for your ecommerce applications. You can get and
customize results based on this information, and this data continues to be used
to train and update models, thus improving your recommendations and search
results.
For more information about the process of implementing Vertex AI Search for commerce
for your application, see
Implementing Vertex AI Search for commerce
.
Recommendations
Vertex AI Search for commerce lets you build high quality, personalized
product recommendation systems without requiring a high level of expertise in
machine learning, systems design, or operations. Leveraging your site's retail
products and user behavior, you can use recommendations to build recommendation models specific to your use case,
such as "Frequently Bought Together" and "Recommended for You".
Vertex AI Search for commerce uses user events and your product catalog to train
your recommendation machine learning models, which provide recommendations
based on this data.
When you deploy recommendation models to your application, you can then request
recommendations for other products in your catalog and display to your users.
Recommendations capabilities include:
Custom models
. Each model is trained specifically for your data, based
on sequence-based machine learning models using transformers.
Personalized results
. Use personalization algorithms without any
machine learning expertise. Recommendations are based on user behavior and
activities like views, clicks, and in-store purchases as well as online
activity, so that every prediction result is personalized.
Real-time predictions
. Each recommendation served considers previous
user activity like click, view, and purchase events, so recommendations are
in real time.
Automatic model training and tuning
. Daily model retraining ensures all
the models can accurately capture user behavior every day.
Optimization objectives
. Goals like conversion rate, click-through rate,
and revenue optimization help you precisely optimize for your business goal.
Omnichannel recommendations
. With the API model, go beyond website
recommendations to personalize your entire shopper journey to
recommendations on mobile apps, personalized email recommendations, store
kiosks, or call center applications.
Search
Vertex AI Search for commerce lets you provide high quality product search results
that are customizable for your retail business needs. Use Google's query
and contextual understanding to improve product discovery across your website
and mobile applications.
Search capabilities include:
Product hierarchies
: You can include collections and variants in your
searchable product catalog.
Query expansion
: Increase the relevant results returned for query terms
that would normally produce fewer results, such as queries that use very
specific keywords.
Relevance thresholding
: Adjust how Vertex AI Search for commerce balances
returning precision (the relevance of the search results returned) and
recall (returning more results for that query).
Pagination
: Control pagination of your search results to decrease lookup
time and response size.
Filtering
: Use expression syntax to provide filtering that refines your
site's search results.
Ordering
: Set the order of search results by multiple fields in order of
priority.
Faceting
: Generate faceting to provide more relevant options to your
users based on attributes you provide. Buckets need to be provided for
numerical attributes in the search request to return them in the search
response.
Dynamic faceting
: Automatically generate facet keys based on search
queries and automatically combine (and rerank) with facet keys provided in
the search request. This feature is based on an allowlist. Contact
support for help enabling this feature.
Boosting and burying
: Control search result ranking by prioritizing or
deprioritizing some types of results.
Browsing
: Get results that are sorted to maximize revenue when your
users browse products using site navigation. Browse search can be combined
with filtering, ordering, faceting, dynamic faceting, boosting, and burying.
Personalized results
. Deliver personalized text search and browse search
results that are personalized for each end-user, based on each user's
behavior on your site, including each user's history of product views,
clicks, add to cart, and purchases.
Use Vertex AI Search for commerce
In order to build machine learning models for recommendations or search,
you need to supply two sets of information:
Product catalog:
Information about the products being recommended to
customers. This includes the product title, description, in-stock
availability, and pricing.
User events:
End user behavior on your website. This includes events
such as when a user views or purchases a specific item, or when your
website shows the user a list of products.
With many integration options, you can ingest your data using tools you might
already use, such as BigQuery, Cloud Storage, Tag Manager, and
Google Analytics.
Important:
Vertex AI Search for commerce processes data on your behalf. It is your
responsibility to ensure that the data you send to Vertex AI Search for commerce is
collected in accordance with applicable laws.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/filter-and-order.txt
Filter and order results  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Filter and order results
This page describes filtering and ordering with search.
Semantic filtering optimizes non-default sorting
Vertex AI Search for commerce is designed to show a wide variety of results, including marginally relevant items that are popular or trending. This is effective in default searches (sorted by relevance), but in non-default searches that use the
order_by
feature, such as sort-by-price, less relevant items can appear more prominently due to lower price, for example.
To ameliorate this effect, Vertex AI Search for commerce has introduced semantic embedding-based filtering to remove these less relevant items from non-default search results, improving user experience.
This intended behavior could, however, lead fewer search results overall. Disabling filtering can impact search-result quality. So if fewer search results is of concern, contact
support
.
Filtering tutorial
This tutorial demonstrates the filtering feature. It lets you fine-tune search requests according to your or your customer's needs. You can filter by single or multiple fields, filter by text or numeric fields, or both. You can use an expression language to construct a predicate for each field or combine different expressions using logical operators. For example, a shopper looking for shoes can use filters to narrow their search to their preferred brand and color.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Ordering tutorial
This tutorial shows how to order items in a search response. When an end user looks for a product on your site, they are shown results ordered by multiple fields. For example, a user is searching for a dress with the best price and discount. Price and discount are multiple fields here. The user will see the dresses ordered by price, and for the dresses with the same price, ordered by discount.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Example dataset
This page uses the following dataset as an example. Only the fields necessary
for the example are included.
Example product dataset
id
title
brands
categories
price_info.price
"nest_mini_2nd_gen"
"Nest Mini (2nd gen)"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"nest_audio"
"Nest Audio"
["Google", "Nest"]
["Nest > speakers and displays"]
99.99
"nest_hub_max"
"Nest Hub Max"
["Google", "Nest"]
["Nest > speakers and displays"]
229.00
"nest_hub"
"Nest Hub"
["Google", "Nest"]
["Nest > speakers and displays"]
88.99
"google_home_max"
"Google Home Max"
["Google", "Nest"]
["Nest > speakers and displays"]
299.00
"google_home_mini"
"Google Home Mini"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"google_pixel_5"
"Google Pixel 5"
["Google", "Pixel"]
["Pixel > phones"]
699.00
"google_pixel_4a_with_5g"
"Google Pixel 4a with 5G"
["Google", "Pixel"]
["Pixel > phones"]
499.00
"google_pixel_4a"
"Google Pixel 4a Phones"
["Google", "Pixel"]
["Pixel > phones"]
349.00
"google_pixel_stand"
"Google Pixel Stand"
["Google", "Pixel"]
["Pixel > featured accessories"]
79.00
"google_pixel_buds"
"Google Pixel Buds"
["Google", "Pixel"]
["Pixel > featured accessories"]
179.00
"google_pixel_5_case"
"Google Pixel 5 Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_5g_case"
"Google Pixel 4a (5G) Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_case"
"Google Pixel 4a Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
Filter
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchFilteredProducts
(
String
query
,
int
pageSize
,
String
filter
)
throws
IOException
,
InterruptedException
{
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setFilter
(
filter
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
The filter expression syntax can be summarized by the following
EBNF
:
# A single expression or multiple expressions that are joined by "AND" or "OR".
filter
=
expression
,
{
" AND "
|
"OR"
,
expression
}
;
# Expressions can be prefixed with "-" or "NOT" to express a negation.
expression
=
[
"-"
|
"NOT "
]
,
# A parenthetical expression.
|
"("
,
expression,
")"
# A simple expression applying to a text field.
# Function "ANY" returns true if the field contains any of the literals.
(
text_field
,
":"
,
"ANY"
,
"("
,
literal
,
{
","
,
literal
}
,
")"
# A simple expression applying to a numerical field. Function "IN" returns true
# if a field value is within the range. By default, lower_bound is inclusive and
# upper_bound is exclusive.
|
numerical_field
,
":"
,
"IN"
,
"("
,
lower_bound
,
","
,
upper_bound
,
")"
# A simple expression that applies to a numerical field and compares with a double value.
|
numerical_field
,
comparison
,
double
)
;
# A lower_bound is either a double or "*", which represents negative infinity.
# Explicitly specify inclusive bound with the character 'i' or exclusive bound
# with the character 'e'.
lower_bound
=
(
double,
[
"e"
|
"i"
]
)
|
"*"
;
# An upper_bound is either a double or "*", which represents infinity.
# Explicitly specify inclusive bound with the character 'i' or exclusive bound
# with the character 'e'.
upper_bound
=
(
double,
[
"e"
|
"i"
]
)
|
"*"
;
# Supported comparison operators.
comparison
=
"<="
|
"<"
|
">="
|
">"
|
"="
;
# A literal is any double quoted string. You must escape backslash (\) and
# quote (") characters.
literal
=
double
quoted
string
;
text_field
=
see
the
table
below
;
numerical_field
=
see
the
table
below
;
The supported textual fields are summarized in the following table.
field
description
"productId"
The product ID (the last segment of Product.name).
"brands"
The Product.brands.
"categories"
The Product.categories.
"genders"
The Audience.genders.
"ageGroups"
The Audience.age_groups.
"availability"
The Product.availability. Value is one of "IN_STOCK", "OUT_OF_STOCK",
        PREORDER", "BACKORDER".
"colorFamilies"
The ColorInfo.color_families.
"colors"
The ColorInfo.colors.
"sizes"
The Product.sizes.
"materials"
The Product.materials.
"patterns"
The Product.patterns.
"conditions"
The Product.conditions.
"attributes.key"
The textual custom attribute in Product object. Key can be any key in
        the Product.attributes map, if the attribute values are textual.
"pickupInStore"
The FulfillmentInfo.place_ids for type "pickup-in-store".
"shipToStore"
The FulfillmentInfo.place_ids for type "ship-to-store".
"sameDayDelivery"
The FulfillmentInfo.place_ids for type "same-day-delivery".
"nextDayDelivery"
The FulfillmentInfo.place_ids for type "next-day-delivery".
"customFulfillment1"
The FulfillmentInfo.place_ids for type "custom-type-1".
"customFulfillment2"
The FulfillmentInfo.place_ids for type "custom-type-2".
"customFulfillment3"
The FulfillmentInfo.place_ids for type "custom-type-3".
"customFulfillment4"
The FulfillmentInfo.place_ids for type "custom-type-4".
"customFulfillment5"
The FulfillmentInfo.place_ids for type "custom-type-5".
"inventory(place_id,attributes.key)"
The textual custom attribute in Inventory.
The supported numerical fields are summarized in the following table.
field
description
"price"
The PriceInfo.price.
"discount"
The discount. Computed by (original_price - price) / original_price.
"rating"
The Rating.average_rating.
"ratingCount"
The Rating.rating_count.
"attributes.key"
The numerical custom attribute in Product object. Key can be any key in
        the Product.attributes map, if the attribute values are numerical.
"inventory(place_id,price)"
The inventory price.
"inventory(place_id,original_price)"
The original inventory price.
"inventory(place_id,attributes.key)"
The numerical custom attribute in Inventory.
At most, 10 nested conjunctions or disjunctions are allowed.
For example, to search for a Google product in the following situations
respectively, you could set
query
as "Google" and set
filter
as the values
shown in the following table:
scenario
filter
not a Pixel accessory
"NOT categories: ANY(\"Pixel > featured accessories\")"
"cheaper than 100 dollars"
"price: IN(*, 100.0e)"
"Nest speaker not cheaper than 80 dollars"
"(categories: ANY(\"Nest > speakers and displays\")) AND (price: IN(80.0i, *))"
Note:
Due to the built-in pagination capability of Search, it's good to maintain local inventory fields when filtering. For more information, see
Update local inventory
.
Order
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchOrderedProducts
(
String
query
,
int
pageSize
,
String
orderBy
)
throws
IOException
,
InterruptedException
{
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setOrderBy
(
orderBy
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
The supported orderable fields are summarized in the following table.
field
description
"productId"
The product ID (the last segment of Product.name).
"title"
The Product.title.
"brands"
The Product.brands.
"categories"
The Product.categories.
"genders"
The Audience.genders.
"ageGroups"
The Audience.age_groups.
"price"
The PriceInfo.price.
"discount"
The discount. Computed by (original_price - price) / price.
"rating"
The Rating.average_rating.
"ratingCount"
The Rating.rating_count.
"attributes.key"
The custom attribute in Product object. Key can be any key in the
        Product.attributes map.
"inventory(place_id,price)"
The inventory price.
"inventory(place_id,original_price)"
The original inventory price.
"inventory(place_id,attributes.key)"
The numerical or textual custom attribute in Inventory.
By default, the order is ascending. Descending order can be specified by "desc"
suffix, such as, "rating desc".
For a numeric field with multiple values, for example, a repeated field or a
field that is set for variant products, the minimum value is used for sorting by
ascending order and the maximum value is used for sorting by descending order.
Ordering by multiple fields is supported through the use of comma-separated fields
in order of priority. The lower priority fields are used to order items with
equal values for higher priority fields. For example, "rating desc, price"
orders items with the same rating by price.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/filter-recs.txt
Filter recommendations  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Filter recommendations
This page describes filtering results for recommendations using
product attributes.
You can filter prediction results by specifying a filter expression in predict
requests. The filter expression is a logical expression that is evaluated for
each product. The list of products in the response is narrowed down to products
where the expression evaluates to true.
Note:
Tag expression updates can take up to eight hours to become available for
use in filtering predictions with v1 and v2, including to the attribute configs for filtering and product-level metadata changes. Only the
Availability
field has real-time updates.
There are two versions of filtering for recommendations:
Version 2
is recommended.
Version 1
is deprecated but may still be in use.
The sections in this how-to guide only apply to version 2 of filtering, which
filters recommendations using product attributes.
Recommendation filtering, version 2
Version 2 uses product attributes. Filter expressions
are based on product attributes. These can be predefined system attributes,
such as
categories
and
colors
, or custom attributes you define, such as
attributes.styles
. When you set a product attribute as filterable,
recommendations can then automatically use those attributes as
tags for recommendations filtering, instead of requiring that you manually
add filter tags.
When you use attributes to filter products, the prediction response
returns primary products that contain at least one primary or variant product
that has an attribute value matching the filter
expression. For more about primary and variant products, see
Product levels
.
The following filter expression example also filters for any red or blue
products set as "New-Arrival" and not set as promotional:
colors: ANY("red", "blue") AND attributes.status: ANY("New-Arrival") AND NOT attributes.is_promotional: ANY("true")
To use version 2 of filtering for recommendations follow these
procedures. Each procedure is given later on this page.
Turn on recommendations filtering for a model
that will
serve filtered recommendations.
Turn on recommendations filtering for product attributes
that you plan to filter on.
Use filterable product attributes in predict requests
.
Recommendation filtering, version 1 (deprecated)
Version 1 uses manually created filter tags. Filter expressions are based
on
filter tags
, which you must manually add to any products in your
catalog that you plan to filter.
The following filter expression example uses filter tags to specify products
tagged as "Red" or "Blue", as well as the tag "New-Arrival", and are not
tagged as "promotional":
tag=("Red" OR "Blue") tag="New-Arrival" tag=(NOT "promotional")
See the API reference documentation for the
Product.tags[]
field.
Tag expressions can contain the boolean operators
OR
or
NOT
, which must
be separated from the tag values by one or more spaces. Tag values can
also be immediately prepended by a dash (
-
), which is equivalent to
the
NOT
operator. Tag expressions that use the boolean operators must
be enclosed in parentheses.
In addition to tags, you can filter by
filterOutOfStockItems
.
The
filterOutOfStockItems
flag filters out any products with a
stockState
of
OUT_OF_STOCK
.
You can combine tag filters and out-of-stock filters so that only items that
satisfy all specified filter expressions are returned.
Some example filter strings:
"filter": "tag=\"spring-sale\""
"filter": "filterOutOfStockItems"
"filter": "tag=\"spring-sale\" tag=\"exclusive\" filterOutOfStockItems"
The following example returns only items that are in stock that have either
the
spring-sale
or the
exclusive
tag (or both) and also does not have the
items-to-exclude
tag.
"filter": "tag=(\"spring-sale\" OR \"exclusive\") tag=(-\"items-to-exclude\") filterOutOfStockItems"
Attribute filter and tag filter compatibility
If a model has both manually created tags and filterable product attributes, it
can serve predict requests using either version of filtering. However, it's not
possible to include both v1 filtering and v2 filtering expressions in the same
predict request.
Recommendations filtering limits
Manually add filter criteria to restrict the set of recommendations returned to end users.
Use Vertex AI Search for commerce to apply business rules to fine-tune what customers see, including options to filter by product availability, custom tags, and other criteria.
Each filterable attribute consumes some memory in each of your models. The
following limits help prevent adverse effects on serving performance:
Up to 10 custom attributes can be set as filterable in your catalog.
Up to 100,000,000 filterable attribute values can be present in your catalog.
The total number of attribute values in your catalog can be estimated by
multiplying the number of products in your catalog by the number of filterable
attributes.
For example, if you have a catalog with 1,000 products and 3 attributes set
as filterable, the total number of attribute values can be estimated as
3*1000=3000.
If you are using version 1 recommendations filtering alongside version 2, the
number of filter tags count towards your quota. Make sure that the number of
filter tags added to the total number of attribute values is less than
100,000,000.
If you exceed the limits, you are prevented from
setting additional attributes as filterable. If you need to exceed these limits,
request a quota increase.
The total number of tags is computed during model training. If the total number
exceeds the limit, model training fails. If more than 10 filterable custom
attributes are found during model training, only 10 are used.
Recommendations filter expression syntax
The filter expression syntaxes for search and
recommendations are similar. However, recommendations have several limitations.
The recommendations filter expression syntax can be summarized by
the following
EBNF
:
# A single expression or multiple expressions that are joined by "AND" or "OR".
filter
=
expression
,
{
" AND "
|
"OR"
,
expression
}
;
# An expression can be prefixed with "-" or "NOT" to express a negation.
expression
=
[
"-"
|
"NOT "
]
,
# A parenthesized expression
|
"("
,
expression,
")"
# A simple expression applying to a textual field.
# Function "ANY" returns true if the field contains any of the literals.
(
textual_field
,
":"
,
"ANY"
,
"("
,
literal
,
{
","
,
literal
}
,
")"
# A literal is any double-quoted case sensitive string. You must escape backslash (\) and
# quote (") characters. We do not support textual values containing `/` characters, or partial string matches.
# The literal must be an exact match for products in the catalog. The Predict
# API returns empty results when no possible matches exist.
literal
=
double-quoted
string
;
textual_field
=
see
the
tables
below
;
Filter syntax restrictions
The following restrictions apply:
The depth of embedding
AND
and
OR
operators in parentheses is limited. The
logical expressions in the filter must be in
conjunctive normal form (CNF)
. The most complex
supported logical expression can be an
AND
-connected list of clauses that
only contain
OR
operators, such as:
(... OR ... OR ...) AND (... OR ...)
AND (... OR ...)
Expressions can be negated with the
NOT
keyword or with
-
. This only works
with
ANY()
-expressions with a single argument that don't include
inventory-related attributes.
availability
-based restrictions must be on the top-level. They cannot be
used as part of an
OR
-clause or a negation (
NOT
).
Because standard recommendations filtering supports textual fields only,
less-than, greater-than, and range-check operations are not supported for
standard recommendations filtering. Less-than and greater-than operations can
be used only with recommendations boost or bury control conditions, which support
some numerical fields (see
Boost/bury supported fields
).
The maximum number of terms in the top-level
AND
-clause is 20.
An
OR
clause can have up to 100 arguments that are included in
ANY()
expressions. If an
OR
clause has multiple
ANY()
expressions, their
arguments all count toward this limit. For example,
colors: ANY("red",
"green") OR colors: ANY("blue")
has three arguments. For the Vertex AI Search for commerce use case, you can think of an
argument as the equivalent of an attribute value.
The following table shows valid filter expression examples, as well as invalid
examples and the reasons they are invalid.
Expression
Valid
Notes
colors: ANY("red", "green")
Yes
NOT colors: ANY("red")
Yes
NOT colors: ANY("red", green")
No
Negates an `ANY()` with more than one argument.
colors: ANY("red", "green") OR
categories: ANY(\"Phone > Android > Pixel\")
Yes
(colors: ANY("red") OR colors: ANY("green")) AND
categories: ANY(\"Phone > Android > Pixel\")
Yes
(colors: ANY("red") AND colors: ANY("green")) OR
categories: ANY(\"Phone > Android > Pixel\")
No
Not in conjunctive normal form.
(colors: ANY("red")) AND (availability: ANY("IN_STOCK")
Yes
(colors: ANY("red")) OR (availability: ANY("IN_STOCK"))
No
Combines
availability
in an
OR
expression with other conditions.
Inventory-related attribute filtering
Filtering on inventory-related attributes is based on the real-time state of
your products. For
availability: ANY("IN_STOCK")
filtering, the prediction response
returns primary products where the primary or a variant product has the matching value of
IN_STOCK
. For more about primary and variant products, see
Product levels
. We don't support
Primary only
or
Variant only
filtering.
IN_STOCK
is the only
availability
attribute value supported by version 2 of
recommendations filtering.
Inventory-related attributes can be used in
AND
-clauses, but not in
OR
-clauses.
Tip:
While the Search API supports filtering by local inventory stock status, the Recommendations API doesn't. A workaround to filter Recommendations responses by stock status at the
local inventory level
is to add a post-processing step, where you filter the product list using your own method before sending the product list on to the client.
Supported fields
Supported textual fields are summarized in the following table.
Boost or bury for recommendations supports additional fields that
are not supported by standard recommendations filtering. For a list of
such fields, see
Boost/bury supported fields
.
field
description
"productId"
The product ID (the last segment of Product.name).
"brands"
The Product.brands.
"categories"
The Product.categories.
"genders"
The Audience.genders.
"ageGroups"
The Audience.age_groups.
"colorFamilies"
The ColorInfo.color_families.
"colors"
The ColorInfo.colors.
"sizes"
The Product.sizes.
"materials"
The Product.materials.
"patterns"
The Product.patterns.
"conditions"
The Product.conditions.
"attributes.key"
The textual custom attribute in Product object. Key can be any key in
        the Product.attributes map, if the attribute values are textual.
Boost/bury supported fields
Boost/bury supports some additional fields that are not supported by standard
recommendations filtering, including numerical fields.
In addition to the fields listed in
Supported fields
,
boost/bury for recommendations supports the following fields:
Textual fields
field
description
"tags"
Product.tags[]
. Custom tags associated with the
        product.
Numerical fields
field
description
"price"
PriceInfo.price
. The price of the product.
"discount"
The product discount. This field is computed using the original price
        and price field values from
PriceInfo
.
"rating"
Product.rating
. The total number of ratings for the
        product.
"ratingCount"
rating.ratingCount
. The total number of ratings for the
        product.
Set recommendations filtering for a model
You can turn on filtering for recommendations using the
Search for commerce console or the
Models
API resource.
From the console, you can create a new model that has recommendations filtering
enabled. You can also update this option for existing models.
Using the
Models
API resource, you can create a new model with recommendations
filtering turned on or update this setting for an existing model using
models.Patch
.
Note that if the serving config that returns predictions has
category matching
enabled, filtering does not work
the "categories" attribute because the response returns only product results
that share a category with the context product.
Set filtering for a model using the console
Using the Search for commerce console, select the
Auto generate tags
option during model creation to allow recommendation filtering for that model.
Double check the compatibility with other settings such as
diversity-level
and
category-match-level
etc because the total effects combine together and filtering happens last.
For example, combining rule-based
diversity-level
and
category attribute filtering
frequently results in empty output.
diversity-level=high-diversity
forces the model to limit the maximum results for the same category strings. Ie, 1 result for category1, 1 result for category2, etc.
Attribute filtering using category metadata (
Product.categories = ANY ("category2")
) causes the model to discard items that don't match.
Final output has fewer than three results.
For the
similar-items
model, it already contains extra category relevancy boosting with the default
category-match-level = relaxed-category-match
. Switch to
category-match-level=no-category-match
to disable the behavior and use custom filtering rules.
See
Create recommendation models
for instructions on creating a
recommendation model using the console.
This setting can't be updated in the console for existing models. To update this
setting for a model, use the
models.Patch
API method.
Set filtering for a model using the API
You can turn on recommendations filtering for a model using
models.Create
when creating a new model or
models.Patch
when updating an existing model.
To allow filtering, set the
filteringOption
field for your model. This field's
allowed values are:
RECOMMENDATIONS_FILTERING_DISABLED
(default): Filtering is turned off for
the model.
RECOMMENDATIONS_FILTERING_ENABLED
: Filtering is turned on for primary
products.
The following curl example creates a new model that has recommendations
filtering turned on.
curl
-
X
PATCH
\
-
H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
-
H
"Content-Type: application/json; charset=utf-8"
\
-
H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
--
data
"{
'name': '
MODEL_NAME
',
'displayName': '
MODEL_DISPLAY_NAME
',
'type': 'home-page',
'filteringOption': 'RECOMMENDATIONS_FILTERING_ENABLED',
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/models"
The following curl example updates the filtering option setting for an existing
model.
curl
-X
PATCH
\
-H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
--data
"{
'filteringOption': 'RECOMMENDATIONS_FILTERING_ENABLED',
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/models/
MODEL_ID
?updateMask=filteringOption"
Set attributes as filterable
To filter recommended products, turn on filtering for the product attributes
that you will use in filter expressions. You can update this setting using the
Search for commerce console or using the
Attributes
API resource.
Don't make more attributes filterable than needed. There is a limit on the
number of filterable attributes.
Set attributes as filterable using the console
You can set an attribute as filterable
Controls page
in the
Search for commerce console.
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
Go to the
Attribute controls
tab.
This tab displays a table of all product attributes you can set site-wide
controls for.
Click
edit
Modify Controls
.
Set
Filterable
to
True
for the product attribute.
Click
Save Controls
.
You can start using the attribute for filtering after the next model training
cycle has completed.
Set attributes as filterable using the API
AttributesConfig
represents a list of attributes for a catalog.
Set the
AttributesConfig.filteringOption
field for
CatalogAttribute
. This
field's allowed values are:
RECOMMENDATIONS_FILTERING_DISABLED
(default): Filtering is turned off for
the attribute.
RECOMMENDATIONS_FILTERING_ENABLED
: Filtering is turned on for the attribute.
The following curl example queries your existing product attributes.
curl
-X
GET
\
-H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/attributesConfig"
The following curl example sets the product attribute
categories
as
filterable.
When updating an existing attribute, keep the attribute's original values for
indexableOption
,
dynamicFacetableOption
, and
searchableOption
as they
appear in the previous step. If your chosen attribute did not appear when
viewing
attributesConfig
as in the previous example, then use the default
settings as shown in the following example.
curl
-X
PATCH
\
-H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
--data
"{
'name': 'projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/attributesConfig',
'catalogAttributes': {
'categories': {
'key': 'categories',
'indexableOption': 'INDEXABLE_ENABLED',
'dynamicFacetableOption': 'DYNAMIC_FACETABLE_DISABLED',
'searchableOption': 'SEARCHABLE_DISABLED',
'recommendationsFilteringOption': 'RECOMMENDATIONS_FILTERING_ENABLED'
}
},
'attributeConfigLevel': 'CATALOG_LEVEL_ATTRIBUTE_CONFIG'
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/attributesConfig"
You can start using the attribute for filtering after the next model training
cycle has completed. This typically takes at least eight hours.
Use filterable attributes in a predict request
After your model has been retrained, you can use filterable product attributes
in your predict requests.
Set the request parameter value
filterSyntaxV2
to true to activate version 2
recommendations filtering. If the parameter is not set, version 1 filtering
remains active. If a model has both manually created tags and filterable product
attributes, it can serve predict requests using either version of filtering.
However, it's not possible to include both v1 filtering and v2 filtering
expressions in the same predict request.
The following partial curl example shows
filterSyntaxV2
set to true, and a
filter expression using the product attributes
colors
and
categories
. This
example assumes
colors
and
categories
are set as filterable.
"params": {
  "filterSyntaxV2": true
},
"filter": "(categories: ANY(\"Phone > Android > Pixel\") OR colors: ANY(\"red\", \"green\")) AND (availability: ANY(\"IN_STOCK\"))"
The following curl example shows a complete predict request.
curl
-X
POST
\
-H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-H
"X-Goog-User-Project:
PROJECT_NUMBER
"
\
--data
"{
'userEvent': {
'eventType': 'detail-page-view',
'visitorId': '
VISITOR_ID
',
'productDetails': {
'product': {
'id': '
PRODUCT_ID
'
}
}
},
'params': {
'returnProduct': true,
'filterSyntaxV2': true,
'strictFiltering': true,
},
'filter': 'categories: ANY(\"xyz\")'
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/placements/
SERVING_CONFIG
:predict"
In addition to filters, the serving config's
diversification setting
can also affect the number of
results returned by the response.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/generate-sales-forecasts.txt
Generate sales forecasts from ecommerce data  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Generate sales forecasts from ecommerce data
The page provides guidance for getting predictions from Vertex AI,
based on retail
data exported into
BigQuery
.
We provide several SQL code blocks to help you transform retail product and user
event data into a format that Vertex AI can use. These code blocks are
followed by procedures for the Vertex AI console to create a dataset,
train a model, and then generate a forecast.
Before you begin
Before you can generate sales forecasts using your retail data, you must:
Have your retail data uploaded using Vertex AI Search for commerce. For more
information, see:
Import catalog information
Record real-time user events
Import historical user events
Export your retail data from Vertex AI Search for commerce into
BigQuery. This leaves you with a product table and a user
event table in BigQuery, which you can use in the following
procedures. For more information, see
Export your data into
BigQuery
.
Alternatively, if your product and user event data is already in
BigQuery, in Vertex AI Search for commerce format, you can use
that data to generate sales forecasts from retail data. In this case you don't
need to upload your retail data and export it to BigQuery. For
more information about the
format, see
Product schema
and
About user
events
.
Make sure that you've been granted the
roles/aiplatform.user
IAM role, so you can do the procedures using the Vertex AI console.
Create an aggregated sales table
The SQL code in this section transforms the user event table into an aggregated
sales table. This means that for each product in the user event table that was
sold at least once, the sales quantity for the product is aggregated over a
weekly period. In addition, the SQL code does the following:
For any product in the user event table, if any timestamps are missing
between the first sale of the product in the table and the last sale of any
product in the table, each of the missing timestamps is backfilled with a new
row with zero sales. This is to eliminate gaps in sales history.
If there is not at least one product in the user event table that has at least
20 timestamps, a product from the table is chosen at random and is backfilled
with enough rows (each with zero sales) to reach 20 timestamps. This is to
accommodate the Vertex AI requirement of having at least 20 timestamps
when training a model.
To create an aggregated sales table:
Replace the variables in the following SQL example code as follows:
starting_day_of_week
. The day that the week starts on. Valid values:
MONDAY
,
TUESDAY
,
WEDNESDAY
,
THURSDAY
,
FRIDAY
,
SATURDAY
,
SUNDAY
.
rdm_user_event_table
. The project, dataset, and table IDs of the user
event table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
rdm_product_table
. The project, dataset, and table IDs of the product
table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
aggregated_sales_table
. The project, dataset, and table IDs in
BigQuery for the new aggregated sales table. Use the same
project ID as the product and user event tables. Use the ID of an existing
dataset. Specify a table ID, but don't use the ID of an existing table
unless you want to overwrite it. The format is
project_id.dataset_id.table_id
.
SQL code sample
DECLARE
max_date
DATE
;
SET
max_date
=
(
SELECT
LAST_DAY
(
DATETIME
(
max
(
event_time
)),
WEEK
(
STARTING_DAY_OF_WEEK
))
FROM
`
RDM_USER_EVENT_TABLE
`
);
CREATE
OR
REPLACE
TABLE
`
AGGREGATED_SALES_TABLE
`
AS
WITH
flatten_sku
AS
(
SELECT
*
EXCEPT
(
quantity
,
product
),
COALESCE
(
quantity
,
1
)
as
quantity
,
product
.
id
as
sku
FROM
(
SELECT
*
EXCEPT
(
product_details
),
FROM
`
RDM_USER_EVENT_TABLE
`
,
UNNEST
(
product_details
)
AS
product_detail
)
WHERE
product
IS
NOT
NULL
),
aggregate_by_type
as
(
SELECT
event_type
,
sum
(
quantity
)
as
quantity
,
sku
,
LAST_DAY
(
DATETIME
(
event_time
),
WEEK
(
STARTING_DAY_OF_WEEK
))
as
last_day_of_week
from
flatten_sku
group
by
event_type
,
sku
,
last_day_of_week
),
sales_table
as
(
SELECT
quantity
,
sku
,
last_day_of_week
FROM
aggregate_by_type
where
event_type
=
'purchase-complete'
),
sales_table_with_known_products
as
(
SELECT
*
EXCEPT
(
product_table_sku
)
FROM
(
SELECT
s
.
*
,
p
.
id
as
product_table_sku
FROM
sales_table
as
s
LEFT
JOIN
`
RDM_PRODUCT_TABLE
`
as
p
ON
s
.
sku
=
p
.
id
)
WHERE
product_table_sku
is
NOT
NULL
),
fill_gap
as
(
SELECT
sku
,
sale_date
as
last_day_of_week
,
0
as
quantity
FROM
(
SELECT
sku
,
GENERATE_DATE_ARRAY
(
min_date
,
max_date
,
INTERVAL
7
DAY
)
date_range
FROM
(
SELECT
sku
,
MIN
(
last_day_of_week
)
as
min_date
FROM
sales_table_with_known_products
GROUP
BY
sku
)
),
UNNEST
(
date_range
)
sale_date
),
sales_table_backfill
as
(
SELECT
fill_gap
.
sku
,
fill_gap
.
last_day_of_week
,
coalesce
(
original
.
quantity
,
fill_gap
.
quantity
)
as
quantity
FROM
fill_gap
LEFT
JOIN
sales_table_with_known_products
original
ON
fill_gap
.
sku
=
original
.
sku
and
fill_gap
.
last_day_of_week
=
original
.
last_day_of_week
),
one_sku_extend_history
as
(
SELECT
sku
,
GENERATE_DATE_ARRAY
(
IF
(
min_date
<
DATE_SUB
(
max_date
,
INTERVAL
140
DAY
),
min_date
,
DATE_SUB
(
max_date
,
INTERVAL
140
DAY
)),
max_date
,
INTERVAL
7
DAY
)
date_range
FROM
(
SELECT
sku
,
MIN
(
last_day_of_week
)
as
min_date
FROM
sales_table_backfill
GROUP
BY
sku
LIMIT
1
)
),
one_sku_extend_history2
as
(
SELECT
backfill
.
sku
,
backfill
.
sale_date
as
last_day_of_week
,
coalesce
(
original
.
quantity
,
backfill
.
sale_quantity
)
as
quantity
FROM
(
SELECT
sku
,
sale_date
,
0
as
sale_quantity
FROM
one_sku_extend_history
,
UNNEST
(
date_range
)
sale_date
)
backfill
LEFT
JOIN
sales_table_backfill
original
ON
backfill
.
sku
=
original
.
sku
and
backfill
.
sale_date
=
original
.
last_day_of_week
),
sales_table_extend_history
as
(
SELECT
quantity
,
sku
,
last_day_of_week
FROM
sales_table_backfill
WHERE
sku
not
in
(
select
sku
from
one_sku_extend_history
)
UNION
ALL
SELECT
quantity
,
sku
,
last_day_of_week
FROM
one_sku_extend_history2
),
other_event_table
as
(
SELECT
sku
,
last_day_of_week
,
SUM
(
category_page_view_quantity
)
as
category_page_view_quantity
,
SUM
(
search_quantity
)
as
search_quantity
,
SUM
(
detail_page_view_quantity
)
as
detail_page_view_quantity
,
SUM
(
add_to_cart_quantity
)
as
add_to_cart_quantity
FROM
(
SELECT
sku
,
last_day_of_week
,
CASE
WHEN
event_type
=
'category-page-view'
THEN
quantity
END
as
category_page_view_quantity
,
CASE
WHEN
event_type
=
'search'
THEN
quantity
END
as
search_quantity
,
CASE
WHEN
event_type
=
'detail-page-view'
THEN
quantity
END
as
detail_page_view_quantity
,
CASE
WHEN
event_type
=
'add-to-cart'
THEN
quantity
END
as
add_to_cart_quantity
,
FROM
aggregate_by_type
WHERE
event_type
!=
'purchase-complete'
)
GROUP
BY
sku
,
last_day_of_week
)
SELECT
t1
.
*
,
t2
.
category_page_view_quantity
,
t2
.
search_quantity
,
t2
.
detail_page_view_quantity
,
t2
.
add_to_cart_quantity
FROM
sales_table_extend_history
as
t1
left
join
other_event_table
as
t2
ON
t1
.
sku
=
t2
.
sku
AND
t1
.
last_day_of_week
=
t2
.
last_day_of_week
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your product
and user event tables.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new aggregated sales table is written to the location in
BigQuery that you set using the
aggregated_sales_table
variable.
Process the product table
The SQL code in this section acts on the product table that you exported to
BigQuery, removing the repeated and struct fields and unnesting
the
price_info
field into its child fields. This is required because
Vertex AI does not accept lists or nested structures. The result is the
processed product table.
To process the product table:
Replace the variables in the following SQL example code as follows:
rdm_product_table
. The project, dataset, and table IDs for the product
table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
processed_product_table
. The project, dataset, and table IDs in
BigQuery for the new processed product table. Use the same
project ID as the product and user event tables. Use the ID of an existing
dataset. Specify a table ID, but don't use the ID of an existing table
unless you want to overwrite it. The format is
project_id.dataset_id.table_id
.
CREATE
OR
REPLACE
TABLE
`
PROCESSED_PRODUCT_TABLE
`
AS
SELECT
*
EXCEPT
(
id
,
attributes
,
price_info
,
rating
,
expire_time
,
available_time
,
fulfillment_info
,
images
,
audience
,
color_info
,
promotions
,
publish_time
,
retrievable_fields
,
categories
,
brands
,
conditions
,
sizes
,
collection_member_ids
,
tags
,
materials
,
patterns
),
id
as
sku
,
price_info
.
price
as
price_info_price
,
price_info
.
currency_code
as
price_info_currency_code
,
price_info
.
cost
as
price_info_cost
,
FROM
`
RDM_PRODUCT_TABLE
`
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your product
and user event tables.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new processed product table is written to the location in
BigQuery that you set using the
processed_product_table
variable.
Create an events prediction table
The SQL code in this section extracts each SKU that was sold at least once in
the user events table. The code creates an events prediction table containing
all of the extracted SKUs across all timestamps in the future. The future
timestamps are an array of continuous weekly timestamps, starting from the final
week in the user event table + 1 week and ending at the final week in the user
event table +
future_length
weeks. You set the
future_length
value to
the number of weeks into the future that you want the model to predict. Each row
in the events prediction table can be uniquely identified by a SKU and a
timestamp.
To create an events prediction table:
Replace the variables in the following SQL example code as follows:
starting_day_of_week
. The day that the week starts on. Valid values:
MONDAY
,
TUESDAY
,
WEDNESDAY
,
THURSDAY
,
FRIDAY
,
SATURDAY
,
SUNDAY
.
rdm_user_event_table
. The project, dataset, and table IDs for the user
event table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
events_prediction_table
. The project, dataset, and table IDs in
BigQuery for the new events prediction table. Use the same
project ID as the product and user event tables. Use the ID of an existing
dataset. Specify a table ID, but don't use the ID of an existing table
unless you want to overwrite it. The format is
project_id.dataset_id.table_id
.
rdm_product_table
. The project, dataset, and table IDs for the product
table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
future_length
. The number of weeks into the future, after the final week
in the user event table, that the model will predict.
SQL code sample
DECLARE
max_date
DATE
;
SET
max_date
=
(
SELECT
LAST_DAY
(
DATETIME
(
max
(
event_time
)),
WEEK
(
STARTING_DAY_OF_WEEK
))
FROM
`
RDM_USER_EVENT_TABLE
`
);
CREATE
OR
REPLACE
TABLE
`
EVENTS_PREDICTION_TABLE
`
AS
WITH
purchase_events
as
(
SELECT
*
EXCEPT
(
product_details
,
product
),
order_item
.
product
.
id
as
sku
FROM
`
RDM_USER_EVENT_TABLE
`
,
UNNEST
(
product_details
)
as
order_item
WHERE
event_type
=
'purchase-complete'
),
known_products_in_purchase_events
as
(
SELECT
sku
FROM
(
SELECT
s
.
sku
,
p
.
id
as
product_table_sku
FROM
(
SELECT
DISTINCT
(
sku
)
FROM
purchase_events
)
as
s
LEFT
JOIN
`
RDM_PRODUCT_TABLE
`
as
p
ON
s
.
sku
=
p
.
id
)
WHERE
product_table_sku
is
NOT
NULL
),
sales_table_future
as
(
SELECT
sku
,
future_date
as
last_day_of_week
,
NULL
as
quantity
FROM
(
SELECT
sku
,
GENERATE_DATE_ARRAY
(
DATE_ADD
(
max_date
,
INTERVAL
1
WEEK
),
DATE_ADD
(
max_date
,
INTERVAL
FUTURE_LENGTH
WEEK
),
INTERVAL
1
WEEK
)
date_range
FROM
known_products_in_purchase_events
),
UNNEST
(
date_range
)
future_date
)
SELECT
*
FROM
sales_table_future
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your product
and user event tables.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new events prediction table is written to the location in
BigQuery that you set using the
events_prediction_table
variable.
Create a Vertex AI training table
The SQL code in this section joins the aggregated sales table with the processed
product table. The result is a Vertex AI training table, which
Vertex AI uses for model training.
To create a Vertex AI training table:
Replace the variables in the following SQL example code as follows:
vertex_ai_training_table
. The project, dataset, and table IDs in
BigQuery for the new Vertex AI training table. Use
the same project ID as the product and user event tables. Use the ID of an
existing dataset. Specify a table ID, but don't use the ID of an existing
table unless you want to overwrite it. The format is
project_id.dataset_id.table_id
.
aggregated_sales_table
. The project, dataset, and table IDs in
BigQuery of the aggregated sales table, which you created in
Create an aggregated sales table
.
processed_product_table
. The project, dataset, and table IDs in
BigQuery for the processed product table, which you created
in
Process the product table
.
CREATE
OR
REPLACE
TABLE
`
VERTEX_AI_TRAINING_TABLE
`
AS
SELECT
t1
.
*
,
t2
.
*
EXCEPT
(
sku
)
FROM
`
AGGREGATED_SALES_TABLE
`
AS
t1
LEFT
JOIN
`
PROCESSED_PRODUCT_TABLE
`
AS
t2
ON
t1
.
sku
=
t2
.
sku
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your product
and user event tables.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new Vertex AI training table is written to the location in
BigQuery that you set using the
vertex_ai_training_table
variable.
Create a Vertex AI prediction table
The SQL code in this section appends the events prediction table to the
aggregated sales table, then joins it with the processed product table. The
result is the Vertex AI prediction table, which is used to
create a
forecast
.
To create a Vertex AI prediction table:
Replace the variables in the following SQL example code as follows:
vertex_ai_prediction_table
. The project, dataset, and table IDs in
BigQuery for the new Vertex AI prediction table. Use
the same project ID and dataset ID that you used for the product and user
event tables. Don't use the ID of an existing table unless you want to
overwrite it. The format is
project_id.dataset_id.table_id
.
aggregated_sales_table
. The project, dataset, and table IDs in
BigQuery for the aggregated sales table, which you created in
Create an aggregated sales table
.
processed_product_table
. The project, dataset, and table IDs in
BigQuery for the processed product table, which you created
in
Process the product table
.
events_prediction_table
. The project, dataset, and table IDs in
BigQuery for the events prediction table, which you created
in
Create an events prediction table
.
CREATE
OR
REPLACE
TABLE
`
VERTEX_AI_PREDICTION_TABLE
`
AS
WITH
append_predict_to_history
AS
(
SELECT
add_to_cart_quantity
,
category_page_view_quantity
,
detail_page_view_quantity
,
last_day_of_week
,
quantity
,
search_quantity
,
sku
FROM
`
AGGREGATED_SALES_TABLE
`
UNION
ALL
SELECT
NULL
AS
add_to_cart_quantity
,
NULL
AS
category_page_view_quantity
,
NULL
AS
detail_page_view_quantity
,
last_day_of_week
,
NULL
AS
quantity
,
NULL
AS
search_quantity
,
sku
FROM
`
EVENTS_PREDICTION_TABLE
`
)
SELECT
t1
.
*
,
t2
.
*
EXCEPT
(
sku
)
FROM
append_predict_to_history
AS
t1
LEFT
JOIN
`
PROCESSED_PRODUCT_TABLE
`
AS
t2
ON
t1
.
sku
=
t2
.
sku
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your product
and user event tables.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new Vertex AI prediction table is written to the location in
BigQuery that you set using the
vertex_ai_prediction_table
variable.
Create a Vertex AI dataset
This section shows you how to create a Vertex AI dataset that you can
use to train a forecast model. For more information, see
Create a dataset for
training forecast models
in the
Vertex AI documentation.
To create a Vertex AI dataset:
In the Google Cloud console, in the Vertex AI section, go to the
Dataset
page.
Go to the Datasets page
Click
Create
to open the
Create dataset
page.
In the
Dataset name
field, enter a name for your new dataset.
Select the
Tabular
tab.
Select the
Forecasting
objective.
In the
Region
list, select the region that you used when you created a
dataset to export your retail data into BigQuery. If you
selected
us
when you created your BigQuery dataset, you
can select any region in the United States. Likewise, if you selected
eu
when you created your BigQuery dataset, you can select any
region in the European Union. For more information, see
Export your data
into BigQuery
.
Click
Create
to create your empty dataset, and advance to the
Source
tab.
Select
Select a table or view from BigQuery
.
Under
Select a table or view from BigQuery
, enter the
project, dataset, and table IDs for the Vertex AI training table
that you created in
Create a Vertex AI training
table
. The format is
project_id.dataset_id.table_id
.
Click
Continue
.
Your data source is associated with your dataset.
On the
Analyze
tab, select
sku
in the
Series identifier column
list and
last_day_of_week
in the
Timestamp column
list.
Click
Train new model
to advance to the
Train new model
page. For
instructions for training your model, go to
Train a forecast model
.
Train a forecast model
This section shows you how to train a forecast model using the dataset that you
created in
Create a Vertex AI dataset
.
For more information, see
Train a forecast model
in
the Vertex AI documentation.
Before you begin
Before you can train a forecast model, you must
create a Vertex AI
dataset
.
Train a model
In the
Training method
page, select the model training method. For
information about training methods, see
Train a model
in the
Vertex AI documentation.
Click
Continue
.
In the
Model details
page, configure as follows:
Select
Train new model
if it's not already selected.
Enter a name for your new model.
Select
quantity (INTEGER)
from the
Target column
list.
Select
Weekly
from the
Data granularity
list.
Enter your
Context window
and
Forecast horizon
.
The
Forecast horizon
determines how far into the future the model
forecasts the target value for each row of prediction data. The
Forecast horizon
is specified in units of
Data granularity
.
The
Context window
sets how far back the model looks during training
(and for forecasts). In other words, for each training datapoint, the
context window determines how far back the model looks for predictive
patterns. If you don't specify a
Context window
, it defaults to the
value set for
Forecast horizon
. The
Context window
is specified
in units of
Data granularity
.
For more information, see
Considerations for setting the context window
and forecast horizon
in
the Vertex AI documentation.
Click
Continue
.
In the
Training options
page, configure as follows. Note that when a
arrow_drop_down
drop-down arrow is grey, or
when there is no drop-down arrow, that value cannot be changed.
Select a
Transformation
value for the columns in the
Column name
list as follows:
If the
BigQuery type
value is
Float
,
Integer
, or
Numeric
, set the
Transformation
value to
Numeric
.
If the
BigQuery type
value is
String
or
Boolean
, set the
Transformation
value to
Categorical
.
If the
BigQuery type
value is
Date
, set the
Transformation
value to
Timestamp
.
Select a
Feature type
value for the columns in the
Column name
list as follows:
For
add_to_cart_quantity
,
category_page_view_quantity
,
detail_page_view_quantity
, and
search_quantity
,
set the
Feature type
value to
Covariate
.
Of the remaining columns, for those that can be changed, set the
Feature type
to
Attribute
.
Select an
Available at forecast
value for the columns in the
Column
type
list as follows:
For
add_to_cart_quantity
,
category_page_view_quantity
,
detail_page_view_quantity
, and
search_quantity
,
set the
Availability at forecast
value to
Not available
.
Of the remaining columns, for those that can be changed, set the
Feature type
value to
Available
.
Click
Continue
.
In the
Compute and pricing
page, enter the maximum number of hours that
you want your model to train for. This setting helps you put a cap on training
costs. The actual time elapsed can be longer than this value because there are
other operations involved in creating a new model. For information about the
amount of time that can be needed to train high-quality models, see
Train a
model
in the Vertex AI documentation.
Click
Start training
.
Model training can take many hours, depending on the size and complexity of
your data and your training budget, if you specified one. You can close this
tab and return to it later. You receive an email when your model has
completed training. If you want to monitor the progress of the model
training, see
Monitor the progress of your training
.
Monitor the progress of your training
In the Google Cloud console, in the Vertex AI section, go to the
Training
page.
Go to the Training page
If it's not already selected, select the
Training pipelines
tab. The
model you are training should be in the list. Training is finished when the
status changes from
Training
to
Finished
.
Create a forecast
This page shows you how to create a forecast using the forecast model that you
trained in
Train a forecast model
.
Before you begin
Before you can create a forecast, you must
train a forecast model
.
Make a batch prediction request to your model
In the Google Cloud console console, under the Vertex AI section, go to the
Batch predictions
page.
Go to the Batch predictions page
Click
Create
to open the
New batch prediction
window and complete the
following steps:
Enter a name for the batch prediction.
In the
Model name
list, select the model that you trained in
Train a
forecast model
.
In the
Version
list, select the version of the model.
Under
Select source
:
Select
BigQuery table
if it's not already selected.
Enter the project, dataset, and table IDs in BigQuery
for the Vertex AI prediction table that you created in
Create
a Vertex AI prediction
table
. The format is
project_id.dataset_id.table_id
.
Under
Batch prediction output
:
In the
Output format
list, select
BigQuery table
.
Enter project and dataset IDs in BigQuery for the batch
prediction output table that you are creating. Use the same project ID
and dataset ID that you used for the product and user event tables. The
format is
project_id.dataset_id.
Click
Create
. The
Batch predictions
page appears.
The prediction is finished when the status changes from
Pending
to
Finished
. You also receive an email when your batch prediction is
finished. The output of your batch prediction request is returned in the
dataset in the BigQuery project that you specified. The
name of your new output table is "predictions_" appended with the
timestamp of when the prediction job started. For more information about
retrieving and interpreting your forecast results, see
Retrieve batch
prediction results
and
Interpret
forecast results
in the Vertex AI
documentation.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/get-dashboards-that-show-kpis.txt
Get dashboards that show key performance indicators  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Get dashboards that show key performance indicators
This page explains the process for getting Looker dashboards that can
display key performance indicators for your retail business.
Before you begin
Before you can get Looker dashboards for your retail business, you
must:
Have your retail data uploaded using Vertex AI Search for commerce. For more
information, see:
Import catalog information
Record real-time user events
Import historical user events
Export your retail data from Vertex AI Search for commerce into
BigQuery. For more information, see
Export your data into
BigQuery
.
Alternatively, if your product and user event data is already in
BigQuery, in the Vertex AI Search for commerce format, you can use
that data to get Looker dashboards. In this case you don't need to
upload your retail data and export it to BigQuery. For more
information about the BigQuery format,
see
Product schema
and
About user events
.
Set up Looker
Get a Looker instance from your Looker Sales Engineer or
Professional Services consultant.
Set up a connection in Looker to BigQuery by
following the instructions in
Google
BigQuery
in the Looker
documentation. Your Looker Sales Engineer or Professional Services
consultant will assist you in this task if needed. Save the name of the
connection that you set up to use in
Install the Looker
Block
.
Convert your user event BigQuery view to a table
Looker Dashboards require your user event data to be in a BiqQuery
table, not a view.
To convert your user event BigQuery view to a table, do the
following:
Replace the variables in the following SQL example code as follows:
rdm_user_event_view
. The project, dataset, and table IDs of the user
event view that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
rdm_user_event_table
. The project, dataset, and table IDs in
BigQuery for the new BigQuery table. Use the
same project ID and dataset ID that you used for the user event view that
you exported to BigQuery. For the table ID, use
tbl_events
.
The format is
project_id.dataset_id.tbl_events
.
CREATE
OR
REPLACE
TABLE
`
RDM_USER_EVENT_TABLE
`
AS
SELECT
*
FROM
`
RDM_USER_EVENT_VIEW
`
Copy the SQL code sample from the previous step.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your user
event table.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new table is written to the location in BigQuery that you
set using the
rdm_user_event_table
variable. Save this location to use in
Install the Looker Block
.
Create a materialized view for sales
Use the following SQL example code to create a materialized view that your
Looker dashboards can query. For more information, see
Introduction to
materialized views
in the
BigQuery documentation.
To create a materialized view for sales, do the following:
Replace the variables in the following SQL example code as follows:
mv_sales
. The project, dataset, and table IDs in BigQuery
for the new materialized view for sales. Use the same project ID and dataset
ID that you used for the user event table that you exported to
BigQuery. For the table ID, use
mv_sales
. The format is
project_id.dataset_id.mv_sales
.
rdm_user_event_table
. The project, dataset, and table IDs of the user
event table that you exported to BigQuery. The format is
project_id.dataset_id.table_id
.
CREATE
MATERIALIZED
VIEW
`
MV_SALES
`
OPTIONS
(
friendly_name
=
"Sales View"
,
description
=
"View of Sales Data"
,
labels
=
[
(
"team"
,
"cloud_retail_solutions"
),
(
"environment"
,
"development"
)
]
)
AS
SELECT
EXTRACT
(
DATE
FROM
event_time
)
as
day
,
session_id
as
session
,
ANY_VALUE
(
TRIM
(
UPPER
(
visitor_id
)))
as
visitor
,
ANY_VALUE
(
TRIM
(
UPPER
(
user_info
.
user_id
)))
as
user
,
ANY_VALUE
(
TRIM
(
UPPER
(
purchase_transaction
.
id
)))
as
tx_id
,
MAX
(
purchase_transaction
.
revenue
)
as
tx_total
,
MAX
(
purchase_transaction
.
tax
)
as
tx_tax
,
MAX
(
purchase_transaction
.
cost
)
as
tx_cost
,
MAX
(
purchase_transaction
.
currency_code
)
as
tx_cur
,
SUM
(
d
.
quantity
*
d
.
product
.
price_info
.
price
)
as
product_total
,
COUNT
(
d
)
AS
basket_size
FROM
`
RDM_USER_EVENT_TABLE
`
,
UNNEST
(
product_details
)
d
WHERE
event_type
=
'purchase-complete'
GROUP
BY
EXTRACT
(
DATE
FROM
event_time
),
session_id
;
Copy the SQL code sample from the previous step.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the project that contains your user
event table.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Your new materialized view for sales is written to the location in
BigQuery that you set using the
mv_sales
variable. Save this
location to use in
Install the Looker
Block
.
Install the Looker Block
In this procedure, you download a Looker Block using the
Looker Marketplace website that is connected to your Looker
instance. We also have a public
Looker
Marketplace
, where you can view the various Looker
Blocks that are available, but you cannot download Looker Blocks from
that website.
Go to the Looker instance that your Looker Sales Engineer
helped you set up in
Set up Looker
.
Click
storefront
, and then click
Discover
.
The Looker Marketplace page appears.
In the search box, enter
discovery
.
The
Models
pane appears, displaying
Discovery: E-Commerce Insights
.
Click
Discovery: E-Commerce Insights
.
Click
Install > Install
.
If you accept the license agreement, click
Accept
.
If you agree to allow Looker to do the actions shown in the dialog,
click
Agree and Continue
.
The
Configuration
dialog appears.
Set the
Configuration
dialog:
In the
Events Table
box, enter the project, dataset, and table IDs of
the user event table that you exported to BigQuery. The
format is
project_id.dataset_id.table_id.
In the
Products Table
box, enter the project, dataset, and table IDs
of the retail product table that you exported to BigQuery.
The format is
project_id.dataset_id.table_id.
In the
Sales Materialized View
box, enter the project, dataset, and
table IDs of the materialized view for sales that you created in
Create a
materialized view for sales
. The
format is
project_id.dataset_id.table_id.
In the
Connection
box, select the name of the connection that you
created in
Set up Looker
.
Click
Install
to complete the configuration and install the
Looker Block.
The
Looker Marketplace
page appears.
On the
Looker Marketplace
page, in the
Discovery: E-Commerce
Insights
row, click
Open
.
The
Discovery: E-Commerce Insights
page appears.
Click a pane under the
Dashboards
heading to view a dashboard.
Customize the Looker Block
This Looker Block uses refinements for customization. For more
information about using refinements to customize Looker Blocks
installed from the Looker Marketplace, see
Customizing Looker
Marketplace Blocks
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/getting-support.txt
Get support  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All support
Get support
Billing questions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Support
Send feedback
Get support
Get a Google support package
Google Cloud offers different support packages to meet different needs, such as 24/7 coverage,
  phone support, and access to a technical support manager. For more information, see
Google Cloud Support
.
Get support from the community
Community resources are available for recommendations.
Ask a question on Stack Overflow
Ask a question about recommendations on
Stack Overflow
.
  Use the tag
google-cloud-recommendations
for questions about
  recommendations.
Discuss Vertex AI Search for commerce
Join the
cloud-recommendations-users
Google group to discuss recommendations and receive recommendations
  announcements and updates.
You can visit the Google Cloud
Slack community
to discuss
  recommendations and other Google Cloud products. If you haven't already
  joined,
use this form to sign up
.
File bugs or feature requests
To file a bug or a feature request, file a support ticket. To set your ticket to the correct
  component, select the following fields.
For recommendations:
Category
: Machine Learning
Component
: Vertex AI Search for commerce: recommendations
Subcomponent
: Choose the subcomponent you are experiencing
  the issue with
Access & Permissions
Account Administration & Billing
API, SDK & Client Libraries
Outage & latency
Migration
Placement
Quality of Results
Feature Request
Quotas
Other
For search:
Category
: Machine Learning
Component
: Vertex AI Search for commerce: search & browse
Subcomponent
: Choose the subcomponent you are experiencing
    the issue with
Access & Permissions
Account Administration & Billing
API, SDK & Client Libraries
Autocomplete
Indexes
Indexing & serving
Dynamic Facets
Events Ingestion
Facets/Browsing
merchant center integration
Outage & latency
Product Data
Product Ingestion
Quality/Modeling
Feature Request
Quotas
Other
For more information on creating a support ticket, see
Getting support
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/how-it-works.txt
How Vertex AI Search for commerce works  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
How Vertex AI Search for commerce works
This page introduces you to the many features that drive Vertex AI Search for commerce.
The Vertex AI Search for commerce engine
Vertex AI Search for commerce uses state-of-the-art AI and machine learning models to deliver its
search capabilities
. Google technology enables advanced
query understanding
and
personalization
, improving search results from the
broadest queries
.
The service uses user interaction and ranking models to meet specific business goals and
optimize product ranking
for increased conversions and sales, effectively matching product attributes with website content for relevant product discovery.
Guided search serves users an interactive search experience to refine and narrow broad search queries through dynamic filtering and
product image tiles
. The service also offers semantic and
back-and-forth conversation
to facilitate an interactive ecommerce experience in real-time.
The fully managed Vertex AI Search for commerce service lets you:
Import catalog information
.
Manage
catalog information
.
Vertex AI Search for commerce handles data processing to:
Generate sales forecasts
.
Train models
.
Hypertune models
.
Scale features
.
End-to-end search
The
autocomplete search service
provides comprehensive search and a personalized shopping experience.
Additional resources are available to help you integrate Vertex AI Search for commerce into your complete search flow:
Onboarding
Managing user events
API references
Build your search interface
Refer to this documentation on each relevant page for instructions on how to integrate Vertex AI Search for commerce into your product search capabilities using any of these options:
The Search for commerce console
The Merchandising console
The Retail API
See the
Reference
guide for client libraries and REST and RPC resources.
Use Vertex AI Search for commerce for data insights and analytics
Vertex AI Search for commerce leverages user interaction and understands nuances behind
customer behavior
, context, and SKUs to
optimize search results
and
deliver relevant recommendations
, leading to possible improvements in click-through rate, search conversion and a drop in the No Results Found (NRF) rate. Vertex AI Search for commerce utilizes data for internal optimization and benefits customers by improving
metrics
.
Do more with your ecommerce data
After you upload product and user event data using Vertex AI Search for commerce, you
can export that data into
BigQuery
to perform analytics,
access Key Performance Indicator (KPI) dashboards, and generate sales forecasts.
The first step is exporting your data into BigQuery. Once you have the
data in BigQuery tables, you can input them into workflows that result
in prebuilt
Looker
dashboards or sales forecasts using
Vertex AI
.
For more information, see the following topics:
Export your data into BigQuery
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/how-to.txt
Features and capabilities of Vertex AI Search for commerce  |  Google Cloud Documentation
Skip to main content
Technology areas
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
/
Console
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Sign in
Vertex AI Search for commerce
Start free
Guides
Reference
Support
Resources
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Console
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Features and capabilities of Vertex AI Search for commerce
Stay organized with collections
Save and categorize content based on your preferences.
Within the Vertex AI Search for commerce product, you get both the recommendations capability
and the search and browse capability.
You can upload and manage product catalog
information and user event logs for your ecommerce applications. You can get and
customize results based on this information, and this data continues to be used
to train and update models, thus improving your recommendations and search
results.
For more information about the process of implementing Vertex AI Search for commerce
for your application, see
Implementing Vertex AI Search for commerce
.
Recommendations
Vertex AI Search for commerce lets you build high quality, personalized
product recommendation systems without requiring a high level of expertise in
machine learning, systems design, or operations. Leveraging your site's retail
products and user behavior, you can use recommendations to build recommendation models specific to your use case,
such as "Frequently Bought Together" and "Recommended for You".
Vertex AI Search for commerce uses user events and your product catalog to train
your recommendation machine learning models, which provide recommendations
based on this data.
When you deploy recommendation models to your application, you can then request
recommendations for other products in your catalog and display to your users.
Recommendations capabilities include:
Custom models
. Each model is trained specifically for your data, based
on sequence-based machine learning models using transformers.
Personalized results
. Use personalization algorithms without any
machine learning expertise. Recommendations are based on user behavior and
activities like views, clicks, and in-store purchases as well as online
activity, so that every prediction result is personalized.
Real-time predictions
. Each recommendation served considers previous
user activity like click, view, and purchase events, so recommendations are
in real time.
Automatic model training and tuning
. Daily model retraining ensures all
the models can accurately capture user behavior every day.
Optimization objectives
. Goals like conversion rate, click-through rate,
and revenue optimization help you precisely optimize for your business goal.
Omnichannel recommendations
. With the API model, go beyond website
recommendations to personalize your entire shopper journey to
recommendations on mobile apps, personalized email recommendations, store
kiosks, or call center applications.
Search
Vertex AI Search for commerce lets you provide high quality product search results
that are customizable for your retail business needs. Use Google's query
and contextual understanding to improve product discovery across your website
and mobile applications.
Search capabilities include:
Product hierarchies
: You can include collections and variants in your
searchable product catalog.
Query expansion
: Increase the relevant results returned for query terms
that would normally produce fewer results, such as queries that use very
specific keywords.
Relevance thresholding
: Adjust how Vertex AI Search for commerce balances
returning precision (the relevance of the search results returned) and
recall (returning more results for that query).
Pagination
: Control pagination of your search results to decrease lookup
time and response size.
Filtering
: Use expression syntax to provide filtering that refines your
site's search results.
Ordering
: Set the order of search results by multiple fields in order of
priority.
Faceting
: Generate faceting to provide more relevant options to your
users based on attributes you provide. Buckets need to be provided for
numerical attributes in the search request to return them in the search
response.
Dynamic faceting
: Automatically generate facet keys based on search
queries and automatically combine (and rerank) with facet keys provided in
the search request. This feature is based on an allowlist. Contact
support for help enabling this feature.
Boosting and burying
: Control search result ranking by prioritizing or
deprioritizing some types of results.
Browsing
: Get results that are sorted to maximize revenue when your
users browse products using site navigation. Browse search can be combined
with filtering, ordering, faceting, dynamic faceting, boosting, and burying.
Personalized results
. Deliver personalized text search and browse search
results that are personalized for each end-user, based on each user's
behavior on your site, including each user's history of product views,
clicks, add to cart, and purchases.
Use Vertex AI Search for commerce
In order to build machine learning models for recommendations or search,
you need to supply two sets of information:
Product catalog:
Information about the products being recommended to
customers. This includes the product title, description, in-stock
availability, and pricing.
User events:
End user behavior on your website. This includes events
such as when a user views or purchases a specific item, or when your
website shows the user a list of products.
With many integration options, you can ingest your data using tools you might
already use, such as BigQuery, Cloud Storage, Tag Manager, and
Google Analytics.
Important:
Vertex AI Search for commerce processes data on your behalf. It is your
responsibility to ensure that the data you send to Vertex AI Search for commerce is
collected in accordance with applicable laws.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Products and pricing
See all products
Google Cloud pricing
Google Cloud Marketplace
Contact sales
Support
Google Cloud Community
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Code samples
Cloud Architecture Center
Training and Certification
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/iam.txt
Identity and Access Management (IAM)  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Identity and Access Management (IAM)
This page describes how you can control Vertex AI Search for commerce access and
permissions using Identity and Access Management (IAM).
Overview
Google Cloud offers Identity and Access Management (IAM), which lets you give
more granular access to specific Google Cloud resources and prevents unwanted
access to other resources. This page describes the Vertex AI Search for commerce IAM roles and permissions. For a detailed description of Google Cloud
IAM, see the
IAM documentation
.
Vertex AI Search for commerce provides a set of
predefined roles
designed
for quick control over access to your Vertex AI Search for commerce resources.
You can also create your own
custom roles
, if the predefined
roles don't provide the sets of permissions you need. The prior
basic roles (Editor, Viewer, and Owner) are also still available to you,
although they don't provide the same fine-grained control as the
Vertex AI Search for commerce roles. In particular, the basic roles provide
access to resources across Google Cloud rather than just for
Vertex AI Search for commerce. See the
basic roles
documentation for more information.
Predefined roles
The Vertex AI Search for commerce provides some predefined roles you can use to provide
finer-grained permissions to principals. The role you grant to a principal
controls what actions the principal can take. Principals can be individuals,
groups, or service accounts.
You can grant multiple roles to the same principal, and you can change the roles
granted to a principal at any time, provided you have the permissions to do so.
The broader roles include the more narrowly defined roles. For example, the
Retail Editor role includes all of the permissions of the Retail Viewer role,
along with the addition permissions of the Retail Editor role. Likewise, the
Retail Admin role includes all of the permissions of the Retail Editor role,
along with its additional permissions.
The basic roles (Owner, Editor, Viewer) provide permissions across
Google Cloud. The roles specific to Vertex AI Search for commerce provide only
Vertex AI Search for commerce permissions, except for the following Google Cloud
(Google Cloud) permissions, which are needed for general
Google Cloud usage:
resourcemanager.projects.get
resourcemanager.projects.list
serviceusage.services.list
serviceusage.services.get
The following table lists the predefined roles available for
Vertex AI Search for commerce, along with their Vertex AI Search for commerce permissions:
View table
Name
Vertex AI Search for commerce permissions
Description
Project > Owner
All
retail
permissions
Full access and control for all Google Cloud resources; manage user
       access and set up billing for a project.
Project > Editor
All
retail
permissions except the permissions in the Retail
  Admin role.
Read-write access to all Google Cloud and Vertex AI Search for commerce
    resources (except the ability to modify permissions and billing).
Project > Viewer
retail.*.get
retail.*.list
Read-only access to all Google Cloud resources, including
    Vertex AI Search for commerce resources.
Retail Admin
retail.retailProjects.acceptDataTerms
retail.solutions.enroll
retail.products.purge
retail.places.purge
retail.places.purgeInventoryActivities
retail.places.purgeProductPrices
retail.places.purgeProductSettings
retail.orders.purge
retail.products.setSponsorship
retail.userEvents.purge
retail.userEvents.rejoin
retail.attributesConfigs.removeCatalogAttribute
retail.attributesConfigs.batchRemoveCatalogAttributes
retail.merchantConfigs.get
retail.merchantConfigs.update
retail.merchantControls.approverDelete
retail.merchantControls.approverGet
retail.merchantControls.approverList
retail.merchantControls.approverUpdate
retail.merchantControls.creatorCreate
retail.merchantControls.creatorDelete
retail.merchantControls.creatorGet
retail.merchantControls.creatorList
retail.merchantControls.creatorSubmit
retail.merchantControls.creatorUpdate
automlrecommendations.events.purge
automlrecommendations.events.rejoin
This role also includes all permissions in the Retail Editor and Retail Viewer
  roles.
Full control for all Vertex AI Search for commerce resources.
Retail Editor
retail.catalogs.import
retail.catalogs.update
retail.products.create
retail.products.delete
retail.products.update
retail.products.import
retail.userEvents.create
retail.userEvents.import
retail.servingConfigs.create
retail.servingConfigs.update
retail.servingConfigs.delete
retail.controls.create
retail.controls.update
retail.controls.delete
retail.controls.import
retail.controls.export
retail.attributesConfigs.update
retail.attributesConfigs.addCatalogAttribute
retail.attributesConfigs.importCatalogAttributes
retail.attributesConfigs.exportCatalogAttributes
retail.attributesConfigs.replaceCatalogAttribute
retail.completionConfigs.update
retail.models.create
retail.models.delete
retail.models.update
retail.models.pause
retail.models.resume
retail.loggingConfigs.update
retail.alertConfigs.update
rretail.merchantCenterAccountLinks.create
retail.merchantCenterAccountLinks.delete
retail.metrics.writeMetricValue
retail.merchantConfigs.get
retail.merchantConfigs.update
retail.merchantControls.approverDelete
retail.merchantControls.approverGet
retail.merchantControls.approverList
retail.merchantControls.approverUpdate
retail.merchantControls.creatorCreate
retail.merchantControls.creatorDelete
retail.merchantControls.creatorGet
retail.merchantControls.creatorList
retail.merchantControls.creatorSubmit
retail.merchantControls.creatorUpdate
automlrecommendations.apiKeys.create
automlrecommendations.apiKeys.delete
automlrecommendations.catalogItems.create
automlrecommendations.catalogItems.delete
automlrecommendations.catalogItems.update
automlrecommendations.catalogs.update
automlrecommendations.events.create
automlrecommendations.placements.create
automlrecommendations.placements.delete
automlrecommendations.recommendations.create
automlrecommendations.recommendations.delete
automlrecommendations.recommendations.pause
automlrecommendations.recommendations.resume
automlrecommendations.recommendations.update
This role also includes all permissions in the Retail Viewer role.
Can read all Vertex AI Search for commerce resources and write
products
,
events
, and other resources.
Retail Viewer
retail.retailProjects.get
retail.attributesConfigs.exportCatalogAttributes
retail.catalogs.completeQuery
retail.catalogs.listProductAttributes
retail.controls.export
retail.merchantConfigs.get
retail.placements.search
retail.placements.predict
retail.products.export
retail.userEvents.export
retail.*.get
retail.*.list
Read-only access to all Vertex AI Search for commerce resources.
Retail Merchant Approver
retail.attributesConfigs.get
retail.controls.get
retail.controls.list
retail.merchantConfigs.get
retail.merchantConfigs.update
retail.merchantControls.approverDelete
retail.merchantControls.approverGet
retail.merchantControls.approverList
retail.merchantControls.approverUpdate
retail.merchantControls.creatorCreate
retail.merchantControls.creatorDelete
retail.merchantControls.creatorGet
retail.merchantControls.creatorList
retail.merchantControls.creatorSubmit
retail.merchantControls.creatorUpdate
retail.products.get
retail.servingConfigs.list
retail.servingConfigs.search
Can approve content in the Merchandising console.
Retail  Merchant Creator
retail.attributesConfigs.get
retail.controls.get
retail.controls.list
retail.merchantConfigs.get
retail.merchantControls.creatorCreate
retail.merchantControls.creatorDelete
retail.merchantControls.creatorGet
retail.merchantControls.creatorList
retail.merchantControls.creatorSubmit
retail.merchantControls.creatorUpdate
retail.products.get
retail.servingConfigs.list
retail.servingConfigs.search
Can create content in the Merchandising console.
Migrate permissions from the Recommendations API
If you are migrating from the previous
Recommendations Engine API
to Vertex AI Search for commerce, note that
the following predefined roles also include
permissions for the previous API
.
Retail Admin
: Includes all the permissions of Recommendations Admin,
except for
apiKeys
permissions.
Retail Editor
: Includes all the permissions of Recommendations Editor, as
well as
catalog.update
, and excluding
apiKeys
permissions.
Retail Viewer
: Includes all the permissions of Recommendations Viewer.
Manage Vertex AI Search for commerce IAM
You can get and set IAM policies and IAM roles using the Google Cloud
console, the IAM methods of the API, or Vertex AI Search for commerce. For more
information, see
Granting, Changing, and Revoking Access
.
What's next
Learn how to
grant and revoke access
.
Learn more about
IAM
.
Learn more about
basic roles
.
Learn more about
custom roles
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/implement-user-events.txt
Implement user events  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Implement user events
To configure your user events:
Import
historical user events
.
Record
live user events
.
Tag user events
with entities
.
Flag user events with
attribution tokens
.
User information
The
visitorId
value represents the unique user identifier. It's required when you record a user event. (
UserInfo
) is included when you record a user event that has the
visitorId
value and, if available, the
userId
value.
You can use the optional
userId
value as a unique, persistent identifier for a user across devices whenever a user signs in to your site. When you record the
userId
for a user, Vertex AI Search for commerce can generate more personalized results for one user across multiple devices, such as a mobile device and web browser.
Note:
Use a secure form of a unique identifier to keep users anonymous to Vertex AI Search for commerce and
protect your users' privacy. You are responsible for redacting PII (personally identifiable
information), such as email or home addresses, from your data.
User event timestamp
When you record a user event, be sure to include an accurate timestamp of when
the event occurred. Accurate timestamps ensure that events are stored in the
correct order. Timestamps are recorded automatically for events collected using
Tag Manager and the JavaScript Pixel. When you
import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Custom attributes for user events
You can include additional custom attributes and features for user events. This
can result in improved, more specific recommendations for your users when you
use recommendations. To add custom attributes, use
attributes
when you record a user event.
If you provide custom attributes for ingested user events, it's important to
also include them in the user events that you associate with prediction
requests. The formatting of custom attributes must be consistent between
imported events and events provided with prediction requests. This enables
use of those custom attributes when training models and
serving predictions, which helps improve recommendation quality.
You can provide custom text values by using the
text
field, or custom
numerical values by using the
number
field.
For example, the following shows the
attributes
section from a request
to record a user event:
"attributes"
:
{
"user_age"
:
{
"text"
:
[
"teen"
,
"young adult"
]},
"user_location"
:
{
"text"
:
[
"CA"
]}
}
Monitor import health
Recording user events successfully is important for getting high-quality
results. You should monitor the event recording error rates and take
action if needed. For more information, see
Setting up alerts for data upload issues
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/import-completion.txt
Import autocomplete data for search  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Import autocomplete data for search
Autocomplete is a feature for predicting the rest of a word a user is typing,
which can improve the user search experience. It can provide typeahead
suggestion based on your provided dataset or based on user events you provided.
Consider importing autocomplete data only if you want to have additional
controls (Do Not Remove List, Deny List) or if you need to use your own
autocomplete data. Turning on auto-learning is sufficient for most cases
where autocomplete is needed. Auto-learning provides a machine
learning-powered suggestion dataset  based on user search events. See
Autocomplete
for how to turn on auto-learning.
Note:
From September 2022, you can use
Cloud console >
Controls
>
Autocomplete Controls
UI to trigger data import.
These instructions are for uploading your own autocomplete
data only. Keep it up to date if you plan to use your autocomplete
dataset all the time. For getting autocomplete results at query time, refer
to
CompletionService.CompleteQuery
. Autocomplete data is
used only for search. This data is not used by
recommendations.
Before you begin
Before you can import your autocomplete information, you must have completed
the instructions in
Before you begin
, specifically
setting up your project
,
creating a service account
, and
adding the service account to your local environment
.
You must have the
Retail Editor
IAM role to perform the import.
Autocomplete import best practices
When you import autocomplete data, ensure that you implement the following best
practices:
Read the BigQuery schema listed in the following
sections
and API documentation.
Do not use placeholder values.
Include as many fields as possible.
Keep your own autocomplete dataset up to date if you plan to use own
uploaded dataset.
Importing data from another project is disallowed.
Import autocomplete data
Import autocomplete data from BigQuery
Vertex AI Search for commerce supports BigQuery data import for Deny
List, Do Not Remove List, and Suggestion Terms List. See more details in
Autocomplete
.
To import autocomplete data in the correct format from
BigQuery, use the
Vertex AI Search for commerce autocomplete schema
to
create a BigQuery table
with the correct format and
load the table
with your autocomplete data. Then, upload your
data to Vertex AI Search for commerce.
For more help with BigQuery tables, see
Introduction to tables
.
For help with BigQuery queries, see
Overview of querying BigQuery data
.
BigQuery dataset location
When you first create your BigQuery dataset for your
autocomplete BigQuery tables, make sure the dataset
location is set to the multi-region location
"US"
. Not setting it correctly
will cause your import request to fail later. To learn more about
BigQuery dataset locations, see
Dataset locations
in the BigQuery
documentation.
Populate data to BigQuery
Use the
Vertex AI Search for commerce autocomplete schema
to
upload your autocomplete data to BigQuery.
BigQuery can use the schema to validate whether JSON-formatted
data has correct field names and types (such as
STRING
,
INTEGER
, and
RECORD
), but cannot perform validations such as determining:
If a string field mapped into recognizable enum value.
If a string field is using the correct format.
If an integer or float field has value in a valid range.
If a missing field is a required field.
To ensure the quality of your data and the end user search experience, make
sure you refer to the schema and reference documentation for details about
values and format.
Set up access to your BigQuery dataset
To set up access, make sure that your BigQuery dataset is in the
same project as your Vertex AI Search for commerce service and complete the following
steps.
Open the IAM page in the Google Cloud console.
Open
the IAM page
Select your Vertex AI Search for commerce project.
On the
IAM & Admin
page, click
person_add
Grant Access
.
For
New principals
, enter
cloud-retail-customer-data-access@system.gserviceaccount.com
and select the
BigQuery > BigQuery Data Viewer
role.
If you do not want to provide the Data Viewer role to the entire
project, you can add this role directly to the dataset.
Learn more
.
Click
Save
.
Trigger data import to Vertex AI Search for commerce
Console
Go to the Controls page
Go to the
Autocomplete Controls
tab.
In the
Term Lists
section, find the type of list you plan to import
(
Deny list
,
Do Not Remove list
, or
Suggested terms list
) and
click
Import
or
Replace
.
The
Import
pane opens.
Enter the BigQuery path of your data location, or select
Browse
to select the location.
The BigQuery path must be in the same project and its
schema should be correct. To check this, click
Browse
and click the
table name to view its contents in theBigQuery console.
In the
Import
pane, click
Import
.
The import begins. You can leave the page without disrupting the import.
cURL
Create a data file for the input parameters for the import. Your
input parameter values depend on whether you are importing from
Cloud Storage or BigQuery.
Use the
BigQuerySource
object to point to your
BigQuery dataset.
dataset-id
: The ID of the BigQuery dataset.
table-id
: The ID of the BigQuery table
holding your data.
data-schema
: For the
dataSchema
property, use value
suggestions
(default),
allowlist
,
denylist
. Use the
Vertex AI Search for commerce autocomplete schema
.
{
"inputConfig"
:{
"bigQuerySource"
:
{
"datasetId"
:
"
dataset-id
"
,
"tableId"
:
"
table-id
"
,
"dataSchema"
:
"
data-schema
"
}
}
}
Import your autocomplete information to Vertex AI Search for commerce by
making a
POST
request to the
CompletionData:import
REST method, providing the
name of the data file (shown as
input.json
in the example below).
curl -X POST \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" -d @./input.json
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/completionData:import"
You can check the status programmatically using the API.
You should receive a response object that looks something like this:
{
"name": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/123456",
"done": false
}
The name field is the ID of the
operation object
. To
request the status of this object, replace the name field with the
value returned by the import method. When the import is complete, the
done
field returns as
true
:
curl
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/123456"
When the operation completes, the returned object has a
done
value of
true
, and includes a Status object similar to the following example:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/123456"
,
"metadata"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2alpha.ImportMetadata"
,
"createTime"
:
"2020-01-01T03:33:33.000001Z"
,
"updateTime"
:
"2020-01-01T03:34:33.000001Z"
,
"successCount"
:
"2"
,
"failureCount"
:
"1"
},
"done"
:
true
"response"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2alpha.ImportCompletionDataResponse"
,
}
}
Autocomplete data format
Your JSON file should look like the following examples. The line breaks are
for readability; you should provide an entire suggestion on a single line.
Each suggestion should be on its own line.
Suggestion minimum required fields:
{
  "suggestion": "ABC",
  "globalScore": "0.5"
}
Or:
{
  "suggestion": "ABC",
  "frequency": "100"
}
Autocomplete data import duration
It usually takes about a few minutes to one hour for one import from
BigQuery to complete.
When the dataset import is finished, the
done
field in the
operation object
is marked as true.
After that, it might take additional 1~2 days for data to be indexed and be used
in production serving.
Keep your autocomplete dataset up to date
If you plan to use your own uploaded dataset, it's a best practice to keep the
uploaded dataset up-to-date on a regular basis.
Batch update
You can use the import method to batch update your autocomplete. You do this
the same way you do the initial import; follow the steps in
Importing autocomplete data
. This will replace the whole imported
dataset.
Monitor import health
Keeping your own dataset up to date is important for getting high-quality
suggestion results when you use it. You should monitor the import error rates
and take action if needed.
Vertex AI Search for commerce autocomplete schema
When importing autocomplete dataset from BigQuery, use the
Vertex AI Search for commerce schema below to create
BigQuery tables with the correct format and load them with
your autocomplete data.
Schema for suggestions
This dataset is used to provide your own autocomplete suggestion phrases with
your own scores.
Vertex AI Search for commerce autocomplete suggestions schema JSON
JSON
[
{
"description"
:
"The suggestion text"
,
"mode"
:
"NULLABLE"
,
"name"
:
"suggestion"
,
"type"
:
"STRING"
},
{
"description"
:
"Global score of this suggestion. Control how this suggestion would be scored / ranked. Only one of this and frequency should be set."
,
"mode"
:
"NULLABLE"
,
"name"
:
"globalScore"
,
"type"
:
"FLOAT"
},
{
"description"
:
"Frequency of this suggestion. Will be used to rank suggestions when score is not available."
,
"mode"
:
"NULLABLE"
,
"name"
:
"frequency"
,
"type"
:
"INTEGER"
},
{
"description"
:
"BCP-47 language code of this suggestion."
,
"mode"
:
"NULLABLE"
,
"name"
:
"languageCode"
,
"type"
:
"STRING"
},
{
"description"
:
"If two suggestions have the same groupID, they will not be returned together. Instead the one ranked higher will be returned. This can be used to deduplicate semantically identical suggestions."
,
"mode"
:
"NULLABLE"
,
"name"
:
"groupID"
,
"type"
:
"STRING"
},
{
"description"
:
"The score of this suggestion within its group"
,
"mode"
:
"NULLABLE"
,
"name"
:
"groupScore"
,
"type"
:
"FLOAT"
},
{
"description"
:
"Device type for this suggestion."
,
"mode"
:
"NULLABLE"
,
"name"
:
"deviceType"
,
"type"
:
"STRING"
},
{
"description"
:
"Alternative matching phrases for this suggestion."
,
"mode"
:
"REPEATED"
,
"name"
:
"alternativePhrases"
,
"type"
:
"STRING"
},
{
"fields"
:
[
{
"description"
:
"The name of the custom attribute."
,
"mode"
:
"NULLABLE"
,
"name"
:
"key"
,
"type"
:
"STRING"
},
{
"fields"
:
[
{
"description"
:
"The textual values of this custom attribute."
,
"mode"
:
"REPEATED"
,
"name"
:
"text"
,
"type"
:
"STRING"
},
{
"description"
:
"The numerical values of this custom attribute."
,
"mode"
:
"REPEATED"
,
"name"
:
"numbers"
,
"type"
:
"FLOAT"
}
],
"mode"
:
"NULLABLE"
,
"name"
:
"value"
,
"type"
:
"RECORD"
}
],
"description"
:
"A custom attribute that is not explicitly modeled, which can be retrieved together with the suggestion at serving time."
,
"mode"
:
"REPEATED"
,
"name"
:
"customAttributes"
,
"type"
:
"RECORD"
}
]
Schema for denylist
This dataset is used as a denylist to block phrases from being suggested.
Vertex AI Search for commerce autocomplete denylist schema JSON
JSON
[
{
"description"
:
"The phrase to block from autocomplete suggestions."
,
"mode"
:
"REQUIRED"
,
"name"
:
"phrase"
,
"type"
:
"STRING"
},
{
"description"
:
"The operator to apply for this phrase. Choose whether to block the exact phrase, or block any suggestions containing this phrase. Supported value \"EXACT_MATCH\", \"CONTAINS\""
,
"mode"
:
"REQUIRED"
,
"name"
:
"operator"
,
"type"
:
"STRING"
}
]
Schema for allowlist
This dataset is used for skipping post processes (such as spell correction and
zero-result filtering) for all the phrases in this allowlist.
Vertex AI Search for commerce autocomplete allowlist schema JSON
JSON
[
{
"description"
:
"The phrase to be exempted from autocomplete post processing, e.g. spell correction, filtering"
,
"mode"
:
"REQUIRED"
,
"name"
:
"phrase"
,
"type"
:
"STRING"
},
{
"description"
:
"The operator to apply for this phrase. Whether to match the exact phrase, or any suggestions contain this phrase. Supported values are \"EXACT_MATCH\", \"CONTAINS\"."
,
"mode"
:
"REQUIRED"
,
"name"
:
"operator"
,
"type"
:
"STRING"
}
]
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/import-user-events.txt
Import historical user events  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Import historical user events
This page describes how to import user event data from past events in bulk into Vertex AI Search for commerce. User event data is required for training models.
After you've set up
real-time event recording
, it can take a
considerable amount of time to record sufficient user event data to train your
models. Importing historical data can accelerate the process.
The import procedures on this page apply to both recommendations
and search. After you import data, both services are able to use those events, so you don't need to import the same
data twice if you use both services.
You can import events from:
Cloud Storage
.
BigQuery
.
BigQuery
for Google Analytics 360 events.
BigQuery
for Google Analytics 4 events.
Events inline
using the
userEvents.import
method.
General tips to start
Verify that the data is completely imported from Google Analytics 4 to BigQuery.
Check the import status in the console
, and refer to
debug or error data
for troubleshooting.
Before importing historical user event data, review the
best practices for recording user events
and the
Before you begin
section on this page.
Importing
historical catalog data
can further enhance user events and improve model accuracy.
Caution:
Use a secure form of a unique identifier to keep users anonymous to Vertex AI Search for commerce and
protect your users' privacy. You are responsible for redacting PII (personally identifiable
information), such as email or home addresses, from your data.
Tutorials
These tutorials show you how to import user events from various sources.
Import events from Cloud Storage
This tutorial shows how to import user events from Cloud Storage.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Import events from BigQuery
This tutorial shows how to import user events from BigQuery.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Import events inline
This tutorial shows how to import user events data inline.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Before you begin
To avoid import errors and verify that there is sufficient data
to generate good results, review the following information before importing your
user events.
Review the
best practices for recording user events
.
User event formatting differs depending on the user event type. See
User event types and examples schema
for the format to
specify when creating tables for each event type.
Recommendations and search have differing
minimum data requirements. Make sure your user events meet the requirements of
the service you plan to use:
See
User event requirements and best practices
for
search and recommendations requirements.
If you use recommendations models, also see
User event data requirements
, which lists additional
requirements depending on the recommendation model type and optimization
objective you plan to use.
Event import considerations
This section describes the methods that can be used for batch importing of your
historical user events, when you might use each method, and some of their
limitations.
Cloud Storage
Description
Import data in a JSON format from files loaded in a Cloud Storage
      bucket. Each file must be 2 GB or smaller, and up to 100 files at a time
      can be imported. The import can be done using the Google Cloud console
      or curl. Uses the
Product
JSON data format, which allows
      custom attributes.
When to use
If you need higher volumes of data to be loaded in a single step.
Limitations
If your data is in Google Analytics, that data can only be exported to
      BigQuery and requires the extra step of then importing it
      to Cloud Storage.
BigQuery
Description
Import data from a previously loaded BigQuery table that
      uses the Vertex AI Search for commerce schema. Can be performed using
      Google Cloud console or curl.
When to use
If you are also using analytics or preprocessing event data before
      importing it.
Limitations
Requires the extra step of creating a BigQuery table that
      maps to the Vertex AI Search for commerce schema. If you have a high volume of
      user events, also consider that BigQuery is a higher cost
      resource than Cloud Storage.
BigQuery with Analytics 360
Description
Import pre-existing data from Analytics 360 into
      Vertex AI Search for commerce.
When to use
If you have Analytics 360 and track conversions for
      recommendations or searches. No additional schema mapping is required.
Limitations
Only a subset of attributes is available, so some advanced
      Vertex AI Search for commerce features cannot be used. Tracking impressions in
      Google Analytics is required if you plan to use
      search.
BigQuery with Google Analytics 4
Description
Import pre-existing data from Google Analytics 4 into
      Vertex AI Search for commerce.
When to use
If you have Google Analytics 4 and track conversions for
      recommendations or searches. No additional schema mapping is required.
Limitations
Only a subset of attributes is available, so some advanced
      Vertex AI Search for commerce features cannot be used.
      If you plan to use search, you need to set up event
      parameter key-value pairs for tracking; the recommended key is
search_query
.
Inline import
Description
Import using a call to the
userEvents.import
method.
When to use
If you want to have the increased privacy of having all authentication
      occur on the backend and are capable of performing a backend import.
Limitations
Usually more complicated than a web import.
Size limitations
There is a total system limit of 40 billion user events. The following size limitations for data imports according to ingest platform are:
For bulk import from Cloud Storage, each file must be 2 GB or smaller, and you can include up to 100 files in a single bulk import request.
For BigQuery imports, the size limitation is 128 GB.
For inline imports, a recommended maximum of 10,000 user events is suggested per request.
For the minimum days needed for recording live or importing historical user events for model training and search optimization:
General model training and tuning
: Initial model training and tuning typically takes 2-5 days to complete, though it can take longer for larger datasets.
Search optimization
To optimize the search experience based on ingested events, at least 250,000 search events in the last 90 days are required.
For optimizing search results using user events, 500,000 detail-page-view events attributable to a search event in the last 30 days are required.
An average of 10 detail-page-view events attributable to a search event per product in the last 30 days is required, unless events for the past 21 days are uploaded.
For search personalization, at least 100,000 search events served by search in the last 30 days are required.
Import user events from Cloud Storage
Import user events from Cloud Storage using the Google Cloud console
or the
userEvents.import
method.
Console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
User events
.
Select
Google Cloud Storage
as the data source.
Choose
Retail User Events Schema
as the schema.
Enter the Cloud Storage location of your data.
Click
Import
.
curl
Use the
userEvents.import
method to import your user
events.
Create a data file for the input parameters for the import. Use the
GcsSource
object to point to your Cloud Storage
bucket.
You can provide multiple files, or just one.
INPUT_FILE
: A file or files in Cloud Storage
containing your user event data. See
About user events
for
examples of each user event type format. Make sure each user event is
on its own single line, with no line breaks.
ERROR_DIRECTORY
: A Cloud Storage directory for
error information about the import.
The input file fields must be in the format
gs://<bucket>/<path-to-file>/
.
The error directory must be in the format
gs://<bucket>/<folder>/
.
If the error directory does not exist, Vertex AI Search for commerce
creates it. The bucket must already exist.
{
"inputConfig"
:{
"gcsSource"
:
{
"inputUris"
:
[
"
INPUT_FILE_1
"
,
"
INPUT_FILE_2
"
],
},
"errorsConfig"
:{
"gcsPrefix"
:
"
ERROR_DIRECTORY
"
}
}
Import your catalog information by
making a
POST
request to the
userEvents:import
REST
method, providing the name of the data file.
export GOOGLE_APPLICATION_CREDENTIALS=/tmp/my-key.json
curl -X POST \
-v \
-H "Content-Type: application/json; charset=utf-8" \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
--data @./
DATA_FILE
.json \
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:import"
}
}'
Import user events from BigQuery
Import user events from BigQuery using the Google Cloud console
or the
userEvents.import
method.
Set up BigQuery access
Follow the instructions in
Setting up access to your BigQuery dataset
to give your
Vertex AI Search for commerce service account the minimum
BigQuery User
role required for the import to succeed and the additional
BigQuery Data Editor
role for your
BigQuery dataset. The
BigQuery Data Owner
role is unnecessary.
Import your user events from BigQuery
You can import user events using the
Search for commerce console or the
userEvents.import
method.
Console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
User events
.
Select
BigQuery
as the data source.
Select the data schema.
Google Analytics 4
: Use for Google Analytics 4 events.
Google Analytics 360
: Use for Google Analytics
        360 events, unless you are
importing events only home-page-views from Google Analytics 360
(in that case, use
Retail User Events Schema
).
Retail User Events Schema
: Use for importing events from sources other
        than Google Analytics and for
importing events only home-page-views from Google Analytics 360
.
Enter the BigQuery table where your data is located.
Optional: Enter the location of a Cloud Storage bucket in
   your project as a temporary location for your data.
If not specified, a default location is
   used. If specified, the BigQuery and Cloud Storage bucket have to be
   in the same region.
Optional: Under
Show advanced options
, enter the location of a
   Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
   Cloud Storage bucket have to be in the same region.
Click
Import
.
curl
Import your user events by including the data for the events in your call
to the
userEvents.import
method. See the
userEvents.import
API reference.
The value you specify for
dataSchema
depends on what you're importing:
user_event_ga4
: Use for Google Analytics 4 events.
user_event_ga360
: Use for Google Analytics 360 events,
unless you are
importing only home-page-views from
Google Analytics 360
(in that case, use
user_event
).
user_event
: Use for importing events from sources other than
Google Analytics and for
importing events only home-page-views from
Google Analytics 360
.
export GOOGLE_APPLICATION_CREDENTIALS=/tmp/my-key.json
curl \
-v \
-X POST \
-H "Content-Type: application/json; charset=utf-8" \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:import" \
--data '{
"inputConfig": {
"bigQuerySource": {
"datasetId": "
DATASET_ID
",
"tableId": "
TABLE_ID
",
"dataSchema": "
SCHEMA_TYPE
"
}
}
}'
Import Analytics 360 user events with BigQuery
You can import Analytics 360 user events if you have
integrated Analytics 360 with BigQuery and use
Enhanced Ecommerce.
Note:
If you use Google Analytics 4,
see
Importing Google Analytics 4 user events with BigQuery
.
The following procedures assume you are familiar with using
BigQuery
and Analytics 360.
Before you begin
Before you begin the next steps, make sure:
You're using
Enhanced Ecommerce
.
You have
BigQuery linked to Analytics 360
.
Check your data source
Make sure that the user event data that you will import is correctly formatted
in a BigQuery table you have access to.
Make sure that the table is named
project_id:ga360_export_dataset.ga_sessions_YYYYMMDD
.
See the
Google Analytics documentation
for more about
the table format and naming.
In the
BigQuery Google Cloud console
,
select the table from the
Explorer
panel to preview the table.
Check that:
The
clientId
column has a valid value—for example,
123456789.123456789
.
Note that this value is different from the full _ga cookie value (which has
a format such as
GA1.3.123456789.123456789
).
The
hits.transaction.currencyCode
column has a
valid currency code
.
Note:
The Vertex AI Search for commerce
purchase-complete
event type requires a
currency code. If you're importing purchase events, which
some Vertex AI Search for commerce models
require,
update Enhanced Ecommerce reporting
to include
currency code.
If you plan to import
search
events, check that either a
hits.page.searchKeyword
or
hits.customVariable.searchQuery
column
is present.
While Vertex AI Search for commerce requires both
searchQuery
and
productDetails
to
return a list of search results
, Analytics 360 doesn't store both search queries and product impressions in one event. For Vertex AI Search for commerce to work, you need to create a tag at the data layer or a JavaScript Pixel to be able to import both types of user events from Google Analytics sources:
searchQuery
, which is read from the
search_term
parameter, or from
view_search_results
events, is derived from either
hits.page.searchKeyword
, or from
hits.customVariables.customVarValue
if
hits.customVariables.customVarName
is
searchQuery
.
productDetails
, the product impression which is read from the
items
parameter of the
view_item_list
event, is taken from
hits.product
if
hits.product.isImpressions
is
TRUE
.
Check the consistency of item IDs between the uploaded catalog and the
Analytics 360 user event table.
Using any product ID from the
hits.product.productSKU
column in the
BigQuery table preview, use the
product.get
method to make sure the same product is in your uploaded catalog.
export
GOOGLE_APPLICATION_CREDENTIALS
=/
tmp
/
my
-
key
.
json
curl
\
-
v
\
-
X
GET
\
-
H
"Content-Type: application/json; charset=utf-8"
\
-
H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/default_branch/products/
PRODUCT_ID
"
Import your Analytics 360 events
You can import Google Analytics 360 events using the
Search for commerce console or the
userEvents.import
method.
Console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
User events
.
Select
BigQuery
as the data source.
Select the data schema.
Google Analytics 4
: Use for Google Analytics 4 events.
Google Analytics 360
: Use for Google Analytics
        360 events, unless you are
importing events only home-page-views from Google Analytics 360
(in that case, use
Retail User Events Schema
).
Retail User Events Schema
: Use for importing events from sources other
        than Google Analytics and for
importing events only home-page-views from Google Analytics 360
.
Enter the BigQuery table where your data is located.
Optional: Enter the location of a Cloud Storage bucket in
   your project as a temporary location for your data.
If not specified, a default location is
   used. If specified, the BigQuery and Cloud Storage bucket have to be
   in the same region.
Optional: Under
Show advanced options
, enter the location of a
   Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
   Cloud Storage bucket have to be in the same region.
Click
Import
.
REST
Import your user events by including the data for the events in your call
to the
userEvents.import
method.
For
dataSchema
, use the value
user_event_ga360
.
export GOOGLE_APPLICATION_CREDENTIALS=/tmp/my-key.json
curl \\
  -v \\
  -X POST \\
  -H "Content-Type: application/json; charset=utf-8" \\
  -H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \\
  "https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:import" \\
  --data '{
    "inputConfig": {
      "bigQuerySource": {
        "datasetId": "
some_ga360_export_dataset
",
        "tableId": "
ga_sessions_YYYYMMDD
",
        "dataSchema": "user_event_ga360"
    }
  }
}'
Java
public
static
String
importUserEventsFromBigQuerySource
()
throws
IOException
,
InterruptedException
,
ExecutionException
{
UserEventServiceClient
userEventsClient
=
getUserEventServiceClient
();
BigQuerySource
bigQuerySource
=
BigQuerySource
.
newBuilder
()
.
setProjectId
(
PROJECT_ID
)
.
setDatasetId
(
DATASET_ID
)
.
setTableId
(
TABLE_ID
)
.
setDataSchema
(
"user_event"
)
.
build
();
UserEventInputConfig
inputConfig
=
UserEventInputConfig
.
newBuilder
()
.
setBigQuerySource
(
bigQuerySource
)
.
build
();
ImportUserEventsRequest
importRequest
=
ImportUserEventsRequest
.
newBuilder
()
.
setParent
(
DEFAULT_CATALOG_NAME
)
.
setInputConfig
(
inputConfig
)
.
build
();
String
operationName
=
userEventsClient
.
importUserEventsAsync
(
importRequest
).
getName
();
userEventsClient
.
shutdownNow
();
userEventsClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
operationName
;
}
Import your Analytics 360 home-page-views with BigQuery
In Analytics 360, home-page-view events are not
distinguished from other page-view events. This means that home-page-view events
are not imported as events with the other event types (such as detail-page-view)
in
Import your Analytics 360 events
.
The following procedure explains how you can extract home-page-view events from
your Analytics 360 data and import them into
Vertex AI Search for commerce. In short, this is done by extracting users' views of the home
page (identified by the home-page path) into a new BigQuery table
and then importing data from that new table into Vertex AI Search for commerce.
To import home-page-view events from Analytics 360 into
Vertex AI Search for commerce:
Create a BigQuery dataset or make sure that you have a
BigQuery dataset available that you can add a table to.
This dataset can be in your Vertex AI Search for commerce project or in the project where
you have your Analytics 360 data. It is the target
dataset into which you'll copy the Analytics 360
home-page-view events.
Create a BigQuery table in the dataset as follows:
Replace the variables in the following SQL code as follows.
target_project_id:
The project where the dataset from step 1 is
located.
target_dataset:
The dataset name from step 1.
CREATE TABLE
TARGET_PROJECT_ID
.
TARGET_DATASET
.ga_homepage (
 eventType STRING NOT NULL,
 visitorId STRING NOT NULL,
 userId STRING,
 eventTime STRING NOT NULL
);
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the target project.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Running this code creates a table in the format
target_project_id:target_dataset.ga_homepage_YYYYMMDD
—for example,
my-project:view_events.ga_homepage_20230115
.
Copy the Analytics 360 home-page-view events from your
Analytics 360 data table into the table created in the
preceding step 2.
Replace the variables in the following SQL example code as follows:
source_project_id:
The ID of the project that contains the
Analytics 360 data in a BigQuery
table.
source_dataset:
The dataset in the source project that
contains the Analytics 360 data in a
BigQuery table.
source_table:
The table in the source project that contains
the Analytics 360 data.
target_project_id:
The same target project ID as in the
preceding step 2.
target_dataset:
The same target dataset as in the preceding
step 2.
path:
This is the path to the home page. Usually this is
/
—for
example, if the home page is
example.com/
. However, if the home page
is like
examplepetstore.com/index.html
, the path is
/index.html
.
INSERT
INTO
`
TARGET_PROJECT_ID
.
TARGET_DATASET
.
ga_homepage
(
eventType
,
visitorId
,
userID
,
eventTime
)
`
SELECT
"home-page-view"
as
eventType
,
clientId
as
visitorId
,
userId
,
CAST
(
FORMAT_TIMESTAMP
(
"%Y-%m-%dT%H:%M:%SZ"
,
TIMESTAMP_SECONDS
(
visitStartTime
))
as
STRING
)
AS
eventTime
FROM
`
SOURCE_PROJECT_ID
.
SOURCE_DATASET
.
SOURCE_TABLE
`
,
UNNEST
(
hits
)
as
hits
WHERE
hits
.
page
.
pagePath
=
"
PATH
"
AND
visitorId
is
NOT
NULL
;
Copy the SQL code sample.
Open the BigQuery page in the Google Cloud console.
Go to the BigQuery page
If it's not already selected, select the target project.
In the
Editor
pane, paste the SQL code sample.
Click
play_circle
Run
and wait for
the query to finish running.
Follow the instructions in
Import user events from BigQuery
to import
the home-page-view events from the target table. During schema selection, if
you import using console, select
Retail User Events Schema
; if you import
using
userEvents.import
, specify
user_event
for the
dataSchema
value.
Delete the table and dataset that you created in steps 1 and 2.
Import Google Analytics 4 user events with BigQuery
You can import Google Analytics 4 user events if you have
integrated Google Analytics 4 with BigQuery and use
Google Analytics Ecommerce.
The following procedures assume you are familiar with using
BigQuery
and Google Analytics 4.
Before you begin
Before you begin the next steps, make sure:
You're using
Google Analytics Ecommerce
.
You have
BigQuery linked to Google Analytics 4
.
Check your data source
To make sure that your user event data is prepared for importing, follow these
steps.
For a table of Google Analytics 4 fields that Vertex AI Search for commerce
uses and which Vertex AI Search for commerce fields they map to,
see
Google Analytics 4 user event fields
.
For all Google Analytics event parameters, see the
Google Analytics Events reference documentation
.
Make sure that the user event data that you will import is correctly formatted
in a BigQuery table you have access to.
The dataset should be named
analytics_PROPERTY_ID
.
The table should be named
events_YYYYMMDD
.
For information about the table names and format, see the
Google Analytics documentation
.
In the
BigQuery Google Cloud console
,
select the dataset from the
Explorer
panel and find the table of user
events that you plan to import.
Check that:
The
event_params.key
column has a
currency
key and that its associated
string value is a
valid currency code
.
Note:
The Vertex AI Search for commerce
purchase-complete
event type requires a
currency code. If you're importing purchase events, which
some Vertex AI Search for commerce models
require,
update your event reporting
to include currency codes.
If you plan to import
search
events, check that the
event.event_params.key
column has a
search_term
key and an associated
value.
While Vertex AI Search for commerce requires both
searchQuery
and
productDetails
to
return a list of search results
, Google Analytics 4 doesn't store both search queries and product impressions in one event. For Vertex AI Search for commerce to work, you need to create a tag at the data layer or from a JavaScript Pixel to be able to import both types of user events from Google Analytics sources:
searchQuery
, which is read from the
search_term
parameter, or from
view_search_results
events.
productDetails
, the product impression which is read from the
items
parameter of the
view_item_list
event.
For information about
search
in Google Analytics 4, see
search
in the Google Analytics documentation.
Check the consistency of item IDs between the uploaded catalog and the
Google Analytics 4 user event table.
To make sure that a product in the Google Analytics 4 user table is
also in your uploaded catalog, copy a product ID from the
event.items.item_id
column in the BigQuery table preview
and use the
product.get
method to check if that product ID
is in your uploaded catalog.
export
GOOGLE_APPLICATION_CREDENTIALS
=/
tmp
/
my
-
key
.
json
curl
\
-
v
\
-
X
GET
\
-
H
"Content-Type: application/json; charset=utf-8"
\
-
H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/default_branch/products/
PRODUCT_ID
"
Import your Google Analytics 4 events
You can import Google Analytics 4 events using the
Search for commerce console or the
userEvents.import
method.
Use the console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
User events
.
Select
BigQuery
as the data source.
Select the data schema.
Google Analytics 4
: Use for Google Analytics 4 events.
Google Analytics 360
: Use for Google Analytics
        360 events, unless you are
importing events only home-page-views from Google Analytics 360
(in that case, use
Retail User Events Schema
).
Retail User Events Schema
: Use for importing events from sources other
        than Google Analytics and for
importing events only home-page-views from Google Analytics 360
.
Enter the BigQuery table where your data is located.
Optional: Enter the location of a Cloud Storage bucket in
   your project as a temporary location for your data.
If not specified, a default location is
   used. If specified, the BigQuery and Cloud Storage bucket have to be
   in the same region.
Optional: Under
Show advanced options
, enter the location of a
   Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
   Cloud Storage bucket have to be in the same region.
Click
Import
.
Use the API
Import your user events by including the data for the events in your call
to the
userEvents.import
method. See the
userEvents.import
API reference.
For
dataSchema
, use the value
user_event_ga4
.
export
GOOGLE_APPLICATION_CREDENTIALS
=/
tmp
/
my
-
key
.
json
curl
\\
-
v
\\
-
X
POST
\\
-
H
"Content-Type: application/json; charset=utf-8"
\\
-
H
"Authorization: Bearer $(gcloud auth application-default print-access-token)"
\\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:import"
\\
--
data
'{
"inputConfig"
:
{
"bigQuerySource"
:
{
"projectId"
:
"
PROJECT_ID
"
,
"datasetId"
:
"
DATASET_ID
"
,
"tableId"
:
"
TABLE_ID
"
,
"dataSchema"
:
"user_event_ga4"
}
}
}
'
Import user events inline
You can import user events inline by including the data for the events in your
call to the
userEvents.import
method.
The easiest way to do this is to put your user event data into a JSON file and
provide the file to curl.
For the formats of the user event types, see
About user events
.
curl
Create the JSON file:
{
  "inputConfig": {
    "userEventInlineSource": {
      "userEvents": [
        \{
          "<userEvent1>"
        \},
        \{
          "<userEvent2>"
        \},
        \....
      \]
    \}
  }
}
Call the POST method:
curl -X POST \
     -H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
     -H "Content-Type: application/json; charset=utf-8" \
     --data @./data.json \
  "https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:import"
Java
public
static
String
importUserEventsFromInlineSource
(
List<UserEvent>
userEventsToImport
)
throws
IOException
,
InterruptedException
,
ExecutionException
{
UserEventServiceClient
userEventsClient
=
getUserEventServiceClient
();
UserEventInlineSource
inlineSource
=
UserEventInlineSource
.
newBuilder
()
.
addAllUserEvents
(
userEventsToImport
)
.
build
();
UserEventInputConfig
inputConfig
=
UserEventInputConfig
.
newBuilder
()
.
setUserEventInlineSource
(
inlineSource
)
.
build
();
ImportUserEventsRequest
importRequest
=
ImportUserEventsRequest
.
newBuilder
()
.
setParent
(
DEFAULT_CATALOG_NAME
)
.
setInputConfig
(
inputConfig
)
.
build
();
String
operationName
=
userEventsClient
.
importUserEventsAsync
(
importRequest
).
getName
();
userEventsClient
.
shutdownNow
();
userEventsClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
operationName
;
}
Historical catalog data
You can also import catalog data that appears in your historical
user events. This catalog data can be helpful because
past product information can be used to enrich
user event capturing, which can in turn improve model accuracy.
For more details, see
Import historical catalog data
.
View imported events
View event integration metrics in the
Events
tab on the Search for commerce console
Data
page. This page shows all events written or imported in last year. Metrics can take up
  to 24 hours to appear after successful data ingestion.
Go to the Data page
A/B testing evaluation
The following parameters for A/B apply, depending on your testing objective:
For a click-through rate (CTR) objective, at least 21 days of user events are required, or specific event volumes. For example, more than 2 million search events and more than 500,000 search clicks.
For a conversion rate (CVR) or revenue objective, at least 28 days of user events are required, or specific event volumes. For example, over 4 million search events, over 1 million search clicks, over 0.5 purchase events per searchable product.
Refer to the
A/B testing
page For more information about A/B testing and best practices.
What's next
Start
recording user events
.
Manage your user events
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/inventory-updates.txt
Update inventory for Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Update inventory for Vertex AI Search for commerce
While the
Product
create, read, update, and delete (CRUD) methods are used to
broadly modify a
Product
's attributes, there is a set of
Product
methods
that can be used for updating inventory-specific fields with varying levels of
granularity. The following
Product
fields are considered inventory fields:
Product.price_info
Product.availability
Product.available_quantity
Product.fulfillment_info
Set inventory tutorial
This tutorial shows how to push inventory updates using the
SetInventory
method instead of updating the entire product.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Add fulfillment tutorial
We recommend using the
AddLocalInventories
method instead of
AddFulfillmentPlaces
.
AddLocalInventories
achieves the same results but provides more fine-grained control over ingesting local inventory data. For more information, see the
AddLocalInventories
documentation
.
This tutorial shows how to update product fulfillment information using the
AddFulfillmentPlaces
method. In this way, search can show updates where products are available and
orders can be fulfilled. For example, a shopper is looking for blue jeans in a
shop but they're out of stock. The moment the jeans are in stock again at this
shop or any other shop, the shopper sees the updates and can proceed with their
order.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Remove fulfillment tutorial
We recommend using the
RemoveLocalInventories
method instead of
RemoveFulfillmentPlaces
.
RmoveLocalInventories
achieves the same results but provides more fine-grained control over ingesting local inventory data. For more information, see the
RemoveLocalInventories
documentation
.
This tutorial shows how to update product fulfillment information using
the
RemoveFulfillmentPlaces
method. In this way,
Vertex AI Search for commerce can show updates where products aren't available and orders
can't be fulfilled. In this way, search can show updates where products aren't
available and orders can't be fulfilled. For example, a shopper is looking for
blue jeans in a shop. If the jeans become out of stock in this shop, the shopper
sees this and can't proceed with their order.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Inventory update methods
Changes to a product's inventory information may occur much more frequently than
changes to its catalog information. As such, a specialized set of methods are
provided to handle large volumes of inventory-specific updates. These methods
are asynchronous because of downstream optimizations that support hundreds of
concurrent updates per product, without sacrificing performance.
Incremental updates
Note that it is recommended to follow the
local inventory updates guide
to issue incremental inventory updates. The newer API methods provide more fine-grained control for per-place inventory attributes.
fulfillment_info
is often used to encode place-level fulfillment availability
for a
Product
. In some cases, fulfillment availability for some specific
place(s) may change, and you may decide to issue updates that describe this
change instead of using the
UpdateProduct
method to re-
specify the entire product's fulfillment information.
In such cases, the
AddFulfillmentPlaces
and
RemoveFulfillmentPlaces
methods can be used to
incrementally update a product's fulfillment changes based on which place IDs
are added or removed for a given fulfillment type.
Java
To learn how to install and use the client library for Vertex AI Search for commerce, see
Vertex AI Search for commerce client libraries
.
        
      
      
  For more information, see the
Vertex AI Search for commerce
Java
API
    reference documentation
.
To authenticate to Vertex AI Search for commerce, set up Application Default Credentials.
      For more information, see
Set up authentication for a local development environment
.
public
static
AddFulfillmentPlacesResponse
addFulfillmentPlaces
(
Product
productToUpdate
,
String
fulfillmentInfoType
,
ImmutableList<String>
placeIds
)
throws
IOException
,
InterruptedException
,
ExecutionException
{
ProductServiceClient
productClient
=
getProductServiceClient
();
AddFulfillmentPlacesRequest
request
=
AddFulfillmentPlacesRequest
.
newBuilder
()
.
setProduct
(
productToUpdate
.
getName
())
.
setType
(
fulfillmentInfoType
)
.
addAllPlaceIds
(
placeIds
)
.
setAddTime
(
Timestamps
.
fromMillis
(
System
.
currentTimeMillis
()))
.
build
();
AddFulfillmentPlacesResponse
response
=
productClient
.
addFulfillmentPlacesAsync
(
request
).
get
();
productClient
.
shutdownNow
();
productClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
response
;
}
Proto
{
product
:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
type
:
"pickup-in-store"
place_ids
:
"store0"
place_ids
:
"store1"
add_time
:
{
seconds
:
100
nanos
:
100
}
allow_missing
:
true
}
This sample
AddFulfillmentPlacesRequest
adds fulfillment type
"pickup-in-store"
to place IDs
"store0"
and
"store1"
for the specified
product. Because
AddFulfillmentPlacesRequest.allow_missing
is set to true, even if the product
does not already exist, the updated inventory information will be stored for
when the product is eventually created. The update is time stamped with
AddFulfillmentPlacesRequest.add_time
to prevent stale updates from overriding
the fulfillment status of these place IDs. These features are discussed in
greater detail in the following sections.
The behavior is identical for
RemoveFulfillmentPlacesRequest
and the schema is
very similar.
When
fulfillment_types
is updated by
AddLocalInventories
and
RemoveLocalInventories
, it reflects a mapping from
each place ID to a list of fulfillment types it supports. When
fulfillment_info
is updated by
AddFulfillmentPlaces
and
RemoveFulfillmentPlaces
, it reflects a mapping
from each specific fulfillment type to a list of place IDs that supports each
type. Both API types are modifying the same underlying fulfillment
information, and the effect of both types of APIs is reflected by
Product.fulfillment_info
.
Non-incremental updates
price_info
,
availability
, and
available_quantity
cannot be incrementally
updated because they represent product-level inventory, as opposed to place-
level information. Furthermore, it may be desirable to issue non-incremental
updates to
fulfillment_info
instead of only incremental changes. In such
cases, the
SetInventory
method is recommended.
Java
To learn how to install and use the client library for Vertex AI Search for commerce, see
Vertex AI Search for commerce client libraries
.
        
      
      
  For more information, see the
Vertex AI Search for commerce
Java
API
    reference documentation
.
To authenticate to Vertex AI Search for commerce, set up Application Default Credentials.
      For more information, see
Set up authentication for a local development environment
.
public
static
SetInventoryResponse
setInventoryWithMask
(
Product
productToUpdate
,
FieldMask
updateMask
)
throws
IOException
,
ExecutionException
,
InterruptedException
{
ProductServiceClient
productClient
=
getProductServiceClient
();
SetInventoryRequest
request
=
SetInventoryRequest
.
newBuilder
()
.
setInventory
(
productToUpdate
)
.
setSetMask
(
updateMask
)
.
setSetTime
(
Timestamps
.
fromMillis
(
System
.
currentTimeMillis
()))
.
setAllowMissing
(
true
)
.
build
();
SetInventoryResponse
response
=
productClient
.
setInventoryAsync
(
request
).
get
();
productClient
.
shutdownNow
();
productClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
response
;
}
Proto
{
product
:
{
name
:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
availability
:
IN_STOCK
fulfillment_info
:
{
type
:
"pickup-in-store"
place_ids
:
"store0"
place_ids
:
"store1"
place_ids
:
"store2"
place_ids
:
"store3"
}
fulfillment_info
:
{
type
:
"same-day-delivery"
}
}
set_time
:
{
seconds
:
100
nanos
:
100
}
set_mask
:
{
paths
:
"availability"
paths
:
"fulfillment_info"
}
allow_missing
:
true
}
In this particular request, the
SetInventoryRequest.product.fulfillment_info
fields are complete descriptions of each fulfillment type's eligible place IDs,
as opposed to incremental specifications. The update to
"same-day-delivery"
indicates that no place IDs are eligible for this fulfillment type for this
product. All other fulfillment types are not updated in this request. Thus, this method can be used to replace the place IDs for only a subset of fulfillment types while leaving the other types untouched.
By default,
SetInventory
will update all inventory fields if
SetInventory.set_mask
is unset or empty. If the mask is not empty or if an
inventory field is not explicitly listed in
SetInventoryRequest.set_mask
, then
any specified value for that inventory field will be ignored in the update
request.
As with incremental updates, the
SetInventoryRequest.set_time
field can be
used to set an update time that will be against the last recorded update time of
all updated inventory fields.
Timestamp protections for inventory updates
There are several different paths to update a product's inventory fields, and to
protect against out-of-order updates, each inventory field is associated with a
latest update time.
The latest update time is recorded for
price_info
,
availability
,
available_quantity
, and each pair of
(fulfillment_info.place_ids,
fulfillment_info.type)
.
The
AddFulfillmentPlaces
,
RemoveFulfillmentPlaces
, and
SetInventory
methods allow the caller to specify an update
time for when the request is issued. This update time is compared against the
latest update time recorded for the relevant inventory fields, and the update is
committed if and only if the update time is strictly after the latest update
time.
For example, suppose place ID
"store1"
has fulfillment type
"pickup-in-
store"
enabled, with the last recorded update time set to time
T
. If
RemoveFulfillmentPlacesRequest.type = "pickup-in-store"
and
RemoveFulfillmentPlacesRequest.place_ids
contains
"store1"
, the request will
clear
"pickup-in-store"
from
"store1"
if and only if the
RemoveFulfillmentPlacesRequest.remove_time
is later than time
T
. The same is
true for
AddFulfillmentPlacesRequests
.
SetInventory
operates in a similar way for updating
price_info
,
availability
, and
available_quantity
. When updating
fulfillment_info
, a
SetInventoryRequest
is implicitly asking to add all specified place IDs for a
given fulfillment type and remove all unspecified existing place IDs.
Thus, when the
SetInventoryRequest
is processed, the
fulfillment_info
update
is implicitly converted into an
AddFulfillmentPlacesRequest
and
RemoveFulfillmentPlacesRequest
for each specified fulfillment type. This means
that if any existing place
"store1"
with fulfillment
"pickup-in-store"
has a
last update time
T
that is more recent than
SetInventoryRequest.set_time
,
then the implicit add/remove on
"store1"
and
"pickup-in-store"
will not be
applied.
Preload inventory information
Each of the inventory update methods allows the caller to set
allow_missing
in
the request. When
allow_missing
is set to true, an inventory update to a
nonexistent
Product
will be processed as if the
Product
exists according to
the method specification(s). The inventory information will be retained for a
maximum of two days if the corresponding
Product
is not created via
CreateProduct
within this timeframe.
Java
public
static
SetInventoryResponse
setInventory
(
Product
productToUpdate
)
throws
IOException
,
ExecutionException
,
InterruptedException
{
ProductServiceClient
productClient
=
getProductServiceClient
();
SetInventoryRequest
request
=
SetInventoryRequest
.
newBuilder
()
.
setInventory
(
productToUpdate
)
.
setSetTime
(
Timestamps
.
fromMillis
(
System
.
currentTimeMillis
()))
.
setAllowMissing
(
true
)
.
build
();
SetInventoryResponse
response
=
productClient
.
setInventoryAsync
(
request
).
get
();
productClient
.
shutdownNow
();
productClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
response
;
}
When to use the
Product
methods
While it is possible to update inventory fields with the Product CRUD methods,
the caller should be explicitly aware of the effects on existing or pre-existing
inventory information.
These are synchronous methods, which means the downstream optimizations used for
inventory methods do not apply, and it may become expensive to rely on these
methods for frequent inventory updates. Wherever possible, prefer to use the
aforementioned inventory update methods.
CreateProduct
When
CreateProduct
is invoked with any inventory fields set,
the provided values in the
CreateProductRequest.product
will override any
preloaded values for those respective fields. If no inventory fields are set,
then any pre-existing inventory information will be automatically used.
Furthermore, the latest update time for the overridden inventory fields will be
reset to the time of the method call.
CreateProduct
with preloaded inventory
PROTO
{
parent:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch"
product_id:
"p123"
product:
{
name:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
title:
"some product"
type:
VARIANT
}
}
In this example, the created product does not have any inventory fields set,
which means any preloaded inventory information will be automatically used if
updated using the inventory update methods. This can be helpful when inventory
updates are decoupled from catalog updates and you want to have a newly
created
Product
synchronize with any pre-existing inventory information.
CreateProduct
with explicit inventory
PROTO
{
parent:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch"
product_id:
"p123"
product:
{
name:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
title:
"some product"
type:
VARIANT
availability:
OUT_OF_STOCK
fulfillment_info:
{
type:
"pickup-in-store"
}
fulfillment_info:
{
type:
"same-day-delivery"
}
}
}
In this example, a
Product
is created with explicitly set inventory fields.
These fields will override any pre-existing values, ignoring the latest update
time for the corresponding fields. Thus, the newly created
Product
is
guaranteed to have availability set to
OUT_OF_STOCK
, and no place IDs will
support fulfillment types
"pickup-in-store"
and
"same-day-delivery"
.
CreateProduct
with inventory information can be helpful if you are not
sure if all the preloaded inventory information is accurate, and prefer to
explicitly set the inventory at creation time of
Product
to fully synchronize
the catalog and inventory.
UpdateProduct
When
UpdateProduct
is invoked and the field mask
UpdateProductRequest.update_mask
contains any inventory fields, the provided
values in the
UpdateProductRequest.product
will override any preloaded values
for those respective fields.
Furthermore, the latest update time for the overridden inventory fields will be
reset to the time of the method call.
PROTO
{
product:
{
name:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
availability:
IN_STOCK
fulfillment_info:
{
type:
"pickup-in-store"
place_ids:
"store0"
place_ids:
"store1"
place_ids:
"store2"
place_ids:
"store3"
}
fulfillment_info:
{
type:
"same-day-delivery"
}
}
update_mask:
{
paths:
"availability"
paths:
"fulfillment_info"
}
}
This example is very similar to the
SetInventory
example, except the update is
guaranteed to be applied regardless of the latest update time of each inventory
field.
UpdateProduct
for inventory can be helpful when a full sync on inventory
information is needed while ignoring timestamp protections.
While it is possible to preload inventory information using
UpdateProduct
by
setting
UpdateProductRequest.allow_missing
to
true
to perform a
Product
upsert, the method requires setting specific catalog fields such as
UpdateProductRequest.product.title
. Thus, it is recommended to use the
inventory update methods for preloading use-cases.
DeleteProduct
When
DeleteProduct
is invoked, all existing inventory
information for the product specified in
DeleteProductRequest.name
will be
deleted, including all records of the latest update time for each inventory
field.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/libraries.txt
Vertex AI Search for commerce client libraries  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All APIs & references
Client Libraries
Overview
C++ Reference
C Sharp Reference
Go Reference
Java Reference
Node.js Reference
PHP Reference
Python Reference
Ruby Reference
REST reference
Overview
v2
REST Resources
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
Types
BigQuerySource
BoostSpec
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalSearchCustomizationConfig
ConversationalSearchSpec
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
PredictResponse
ProductAttributeValue
QueryExpansionSpec
SearchMode
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
v2beta
REST Resources
projects
Overview
getAlertConfig
updateAlertConfig
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
batchRemoveCatalogAttributes
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
export
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
export
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
Types
AlertConfig
BigQuerySource
BoostSpec
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalSearchCustomizationConfig
ConversationalSearchSpec
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
OutputConfig
PredictResponse
ProductAttributeValue
QueryExpansionSpec
RecommendationsFilteringOption
SearchMode
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
v2alpha
REST Resources
projects
Overview
enrollSolution
getAlertConfig
getLoggingConfig
getRetailProject
listEnrolledSolutions
updateAlertConfig
updateLoggingConfig
projects.locations.catalogs
Overview
completeQuery
exportAnalyticsMetrics
getAttributesConfig
getCompletionConfig
getConversationalSearchCustomizationConfig
getDefaultBranch
getGenerativeQuestionFeature
list
patch
setDefaultBranch
updateAttributesConfig
updateCompletionConfig
updateConversationalSearchCustomizationConfig
updateGenerativeQuestion
updateGenerativeQuestionFeature
projects.locations.catalogs.attributesConfig
Overview
addCatalogAttribute
batchRemoveCatalogAttributes
removeCatalogAttribute
replaceCatalogAttribute
projects.locations.catalogs.branches
Overview
get
list
projects.locations.catalogs.branches.operations
Overview
get
projects.locations.catalogs.branches.places.operations
Overview
get
projects.locations.catalogs.branches.products
Overview
addFulfillmentPlaces
addLocalInventories
create
delete
export
get
import
list
patch
purge
removeFulfillmentPlaces
removeLocalInventories
setInventory
projects.locations.catalogs.completionData
Overview
import
projects.locations.catalogs.controls
Overview
create
delete
get
list
patch
projects.locations.catalogs.generativeQuestion
Overview
batchUpdate
projects.locations.catalogs.generativeQuestions
Overview
list
projects.locations.catalogs.merchantCenterAccountLinks
Overview
create
delete
list
projects.locations.catalogs.models
Overview
create
delete
get
list
patch
pause
resume
tune
projects.locations.catalogs.operations
Overview
get
list
projects.locations.catalogs.placements
Overview
conversationalSearch
predict
search
projects.locations.catalogs.servingConfigs
Overview
addControl
conversationalSearch
create
delete
get
list
patch
predict
removeControl
search
projects.locations.catalogs.userEvents
Overview
collect
export
import
purge
rejoin
write
projects.locations.operations
Overview
get
list
projects.operations
Overview
get
list
projects.retailProject
Overview
acceptTerms
Types
AlertConfig
BigQuerySource
BoostSpec
BranchView
CompletionConfig
CompletionDataInputConfig
ConditionBoostSpec
ConversationalFilteringSpec
ConversationalSearchCustomizationConfig
ConversationalSearchResponse
ConversationalSearchSpec
Facet
FacetSpec
GcsSource
GenerativeQuestionConfig
GenerativeQuestionsFeatureConfig
ImportErrorsConfig
Interval
LoggingConfig
OutputConfig
PredictResponse
ProductAttributeInterval
ProductAttributeValue
Project
QueryExpansionSpec
RecommendationsFilteringOption
RelevanceThreshold
SafetySetting
SearchMode
SearchParams
SearchResponse
SolutionType
SpellCorrectionSpec
StringList
Tile
TileNavigationSpec
Shared Types
Types
Date
GetOperationRequest
HttpBody
ListOperationsRequest
ListOperationsResponse
RPC reference
Overview
google.api
google.cloud.location
google.cloud.retail.logging
google.cloud.retail.v2
google.cloud.retail.v2alpha
google.cloud.retail.v2beta
google.longrunning
google.rpc
google.type
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Reference
Send feedback
Vertex AI Search for commerce client libraries
This page shows how to get started with the Cloud Client Libraries for the
Vertex AI Search for commerce API. Client libraries make it easier to access
Google Cloud APIs from a supported language. Although you can use
Google Cloud APIs directly by making raw requests to the server, client
libraries provide simplifications that significantly reduce the amount of code
you need to write.
Read more about the Cloud Client Libraries
and the older Google API Client Libraries in
Client libraries explained
.
Install the client library
C++
See
Setting up a C++ development environment
for details about this client library's requirements and install dependencies.
C#
See the
Reference Page
for this client library's requirements and install dependencies.
For more information, see
Setting Up a C# Development Environment
.
Go
See the
GitHub
README
for this client library's requirements and install dependencies.
For more information, see
Setting Up a Go Development Environment
.
Java
See the
GitHub
README
for this client library's requirements and install dependencies.
For more information, see
Setting Up a Java Development Environment
.
Node.js
See the
GitHub
README
for this client library's requirements and install dependencies.
For more information, see
Setting Up a Node.js Development Environment
.
PHP
See the
GitHub
README
for this client library's requirements and install dependencies.
For more information, see
Using PHP on Google Cloud
.
Python
See the
PyPI
README
for details about this client library's
  requirements and install dependencies.
For more information, see
Setting Up a Python Development Environment
.
Ruby
See the
RubyDoc
README
for details about this client library's
  requirements and install dependencies.
For more information, see
Setting Up a Ruby Development Environment
.
Set up authentication
To authenticate calls to Google Cloud APIs, client libraries support
Application Default Credentials (ADC)
;
the libraries look for credentials in a set of defined locations and use those credentials
to authenticate requests to the API. With ADC, you can make
credentials available to your application in a variety of environments, such as local
development or production, without needing to modify your application code.
For production environments, the way you set up ADC depends on the service
and context. For more information, see
Set up Application Default Credentials
.
For a local development environment, you can set up ADC with the credentials
that are associated with your Google Account:
Install
the Google Cloud CLI.
        
          After installation,
initialize
the Google Cloud CLI by running the following command:
gcloud
init
If you're using an external identity provider (IdP), you must first
sign in to the gcloud CLI with your federated identity
.
If you're using a local shell, then create local authentication credentials for your user
        account:
gcloud
auth
application-default
login
You don't need to do this if you're using Cloud Shell.
If an authentication error is returned, and you are using an external identity provider
        (IdP), confirm that you have
signed in to the gcloud CLI with your federated identity
.
A sign-in screen appears. After you sign in, your credentials are stored in the
local credential file used by ADC
.
Additional resources
C++
The following list contains links to more resources related to the
client library for C++:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
C#
The following list contains links to more resources related to the
client library for C#:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Go
The following list contains links to more resources related to the
client library for Go:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Java
The following list contains links to more resources related to the
client library for Java:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Node.js
The following list contains links to more resources related to the
client library for Node.js:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
PHP
The following list contains links to more resources related to the
client library for PHP:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Python
The following list contains links to more resources related to the
client library for Python:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Ruby
The following list contains links to more resources related to the
client library for Ruby:
API reference
Client libraries best practices
Issue tracker
tbd
on Stack Overflow
Source code
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/local-inventory-updates.txt
Update local inventory for Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Update local inventory for Vertex AI Search for commerce
LocalInventory
is the inventory information associated with a certain
place, identified by its
place_id
. For example, a
LocalInventory
could be
created for a store or a region where a certain price is available.
LocalInventory
has the following fields:
LocalInventory.price_info
LocalInventory.attributes
LocalInventory.fulfillment_types
Existing
LocalInventory
entries are visible through
Product.local_inventories
(with the exception of
fulfillment_types
which,
for backward compatibility, is available through
Product.fulfillment_info
). This field is output only. Setting
Product.local_inventories
for
Product
CRUD APIs or
SetInventory
has no
effect.
Each
(LocalInventory.place_id,
LocalInventory.fulfillment_types[...])
pair points to the same
(fulfillment_info.place_ids, fulfillment_info.type)
pair mentioned in the
Inventory update documentation
.
fulfillment_types
updated by
AddLocalInventories
and
RemoveLocalInventories
reflects a mapping from each place ID to a list of fulfillment types it
supports, while
fulfillment_info
updated by
AddFulfillmentPlaces
and
RemoveFulfillmentPlaces
reflects a mapping from each
specific fulfillment type to a list of place IDs that supports such type.
However, both types of the APIs are modifying the same underlying fulfillment
information, and the effect of both types of APIs will be reflected onto
Product.fulfillment_info
.
Local inventory update methods
Changes to a product's local inventory information can occur much more
frequently than changes to its catalog information. A specialized set
of methods are provided to handle large volumes of local inventory-specific
updates. These methods are asynchronous because of downstream optimizations that
support hundreds of concurrent updates per product, without sacrificing
performance.
Note:
There is no
availability
facet for
localInventory
objects. Instead, you can use custom
fulfillment_types
. For search queries, the filter or facet key can be changed to
"pickupInStore"
. See the
Filter and order
and
Facets
pages for more information.
AddLocalInventories
AddLocalInventories
can be used to create local
inventories at new places (represented with new
place_id
s), or update existing
fields on existing local inventories. Fields that are added or updated on the
list of
LocalInventory
entries in the request body can be specified through
AddLocalInventoriesRequest.add_mask
. Valid
add_mask
values are:
price_info
: overwrites
LocalInventory.price_info
.
attributes
: overwrites all
LocalInventory.attributes
. Existing attributes that are not mentioned in the request body are removed.
attributes.
PLACEHOLDER_NAME
: overwrites only the specified custom attribute. If an existing attribute name is not provided in the request, the attribute is deleted. Multiple
attributes.
PLACEHOLDER_NAME
can be specified, as long as each attribute name is different. However,
AddLocalInventoriesRequest.add_mask
can't include both the
attributes
value and
attributes.
PLACEHOLDER_NAME
values in the same request.
fulfillment_types
: overwrites all supported fulfillment types. Existing fulfillment types that are not mentioned in the request body are removed.
Proto
{
product
:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
local_inventories
:
{
place_id
:
"store1"
price_info
:
{
currency_code
:
"USD"
price
:
100
original_price
:
110
cost
:
95
}
fulfillment_types
:
"pickup-in-store"
fulfillment_types
:
"ship-to-store"
}
local_inventories
:
{
place_id
:
"store2"
price_info
:
{
currency_code
:
"USD"
price
:
200
original_price
:
210
cost
:
195
}
attributes
:
{
key
:
"attr1"
,
value
:
{
text
:
"store2_value"
}
}
fulfillment_types
:
"custom-type-1"
}
add_mask
:
{
paths
:
"price_info"
paths
:
"attributes.attr1"
paths
:
"fulfillment_types"
}
add_time
:
{
seconds
:
100
nanos
:
100
}
allow_missing
:
true
}
This sample
AddLocalInventoriesRequest
adds or updates two local inventories
with place IDs
"store1"
and
"store2"
for the specified product. If
store1
exists, and
store2
does not exist before the request, the request
will update fields of
store1
, and create
store2
with the given field values.
This
AddLocalInventoriesRequest.add_mask
specifies that
price_info
, a single
custom attribute with the name
"attr1"
, and
fulfillment_types
should be
updated using the values provided in the
AddLocalInventoriesRequest.local_inventories
.
attributes
are attributes associated with a place with customizable name and
values. Since
LocalInventory
of
store1
does not provide the value of
attr1
in the request, custom attribute
attr1
will be deleted from the existing
LocalInventory
of
store1
if it exists.
store2
will have its attribute
attr1
's value set to a text value
store2_value
. Other existing custom
attributes on
store1
and
store2
are untouched.
fulfillment_types
represents a list of fulfillment availability for a
Product
at a single place. It is the same and accepts the same values as
fulfillment_info.type
. This
AddLocalInventoriesRequest
specifies that
store1
supports
pickup-in-store
and
ship-to-store
fulfillment types, while
store1
supports
custom-type-1
. Fulfillment types existing before this update
that are not mentioned in the request will be deleted.
Since
AddLocalInventoriesRequest.allow_missing
is set to true, even if the
product does not already exist, the updated local inventory information will be
stored for when the product is eventually created. The update is timestamped
with
AddLocalInventoriesRequest.add_time
to prevent stale updates from
overriding the specified fields of these place IDs. For more about preventing
stale updates and storing local inventory information before the product is
created, see
Timestamp protections for local inventory updates
and
Preloading inventory information
.
Proto
{
product
:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
local_inventories
:
{
place_id
:
"store3"
attributes
:
{
key
:
"attr1"
,
value
:
{
text
:
"attr1_value"
}
}
attributes
:
{
key
:
"attr2"
,
value
:
{
numbers
:
123
}
}
}
add_mask
:
{
paths
:
"attributes"
}
add_time
:
{
seconds
:
100
nanos
:
100
}
}
This sample
AddLocalInventoriesRequest
adds or updates a single local
inventory with place ID
"store3"
for the specified product. Since its
add_mask
contains
"attributes"
, all existing custom attributes of
store3
are deleted, and replaced with
attr1
and
attr2
as specified in the request.
Note that since
allow_missing
is not set, it requires the specified product to
exist. Otherwise, a
NOT_FOUND
error is thrown.
RemoveLocalInventories
RemoveLocalInventories
can be used to remove
existing local inventories at places with given place IDs.
Proto
{
product
:
"projects/123/locations/global/catalogs/default_catalog/branches/default_branch/products/p123"
place_ids
:
"store1"
place_ids
:
"store2"
remove_time
:
{
seconds
:
100
nanos
:
100
}
allow_missing
:
true
}
This sample
RemoveLocalInventoriesRequest
removes local inventories for places
with place IDs
"store1"
and
"store2"
for the specified product. The update
is timestamped with
RemoveLocalInventoriesRequest.remove_time
to prevent
stale updates from overriding the deletion of these place IDs. For specified
place IDs without existing local inventories, the request also records their
update time to
remove_time
. For more about update timestamps, see
Timestamp protections for local inventory updates
Timestamp protections for local inventory updates
To protect against out-of-order updates, each local inventory field is
associated with a latest update time.
The latest update time is recorded for each
(place_id, price_info)
,
(place_id, attributes[...])
, and
(place_id, fulfillment_types[...])
pair.
The
AddLocalInventories
and
RemoveLocalInventories
methods allow the caller to
specify an update time for when the request is issued. This update time is
compared against the latest update time recorded for the relevant inventory
fields, and the update is committed if and only if the update time is strictly
after the latest update time.
For example, suppose place ID
"store1"
has
price_info
with the last recorded
update time set to time
T
. If
RemoveLocalInventoriesRequest.place_ids
contains
"store1"
, the request will remove
price_info
from
"store1"
only if the
RemoveLocalInventoriesRequest.remove_time
is later than time
T
.
The same is true for
RemoveLocalInventoriesRequest
s.
Under timestamp protection, it is possible that a
RemoveLocalInventoriesRequest
might remove only certain fields of a
LocalInventory
instead of all of it. Suppose a local inventory with place ID
"store1"
has
price_info
with last recorded update time set to time
T1
, and
has its only existing custom attribute with name
"attr1"
with last recorded
update time at
T2
. If a
RemoveLocalInventoriesRequest.place_ids
contains
"store1"
, and has
remove_time
set to
T3
(where
T1 < T3 < T2
), then
store_1
's
price_info
will be removed, while its attribute
attr1
will be
untouched.
Preloading inventory information
Each of the local inventory update methods allows the caller to set
allow_missing
in the request. When
allow_missing
is set to true, a local
inventory update to a nonexistent
Product
is processed as if the
Product
exists according to the method specification(s). The local inventory
information will be retained for a maximum of two days if the corresponding
Product
is not created using
CreateProduct
within this
timeframe.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/locations.txt
Vertex AI Search for commerce locations  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Vertex AI Search for commerce locations
Vertex AI Search for commerce is a global service, independent of location.
There is no need to specify the location in the endpoint. Just send a global query to a global endpoint and Vertex AI Search for commerce routes it for you.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-catalog.txt
Manage catalog information  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage catalog information
This page describes how to manage your product information after you have
imported a catalog into Vertex AI Search for commerce. You can read, write, and
delete products in your catalog.
To keep your catalog up to date as product information changes, import your
catalog the same way as the very first time. For help with importing your
catalog, see
Importing catalog information
.
Create, access, and manage product tutorials
This tutorial shows you how to use the API
methods, which perform the following actions:
Create a product
Get a product
Update a product
Delete a product
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Create product
This tutorial shows you how to create a single product.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Get product
This tutorial shows you how to retrieve a product item.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Update product
This tutorial shows you how to update a product in a catalog.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Delete product
This tutorial shows you how to delete a product from a catalog.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Upload a single product item
curl
Create a single product item by using the
products.create
REST method.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"title": "
PRODUCT_TITLE
",
"categories": "
CATEGORY
"
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products?productId=
PRODUCT_ID
"
If the request is successful, the product object is returned, such as in the
following example.
{
"name"
:
"projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
"
,
"id"
:
"
PRODUCT_ID
"
,
"primaryProductId"
:
"
PRODUCT_ID
"
,
"type"
:
"PRIMARY"
,
"categories"
:
\[
"
CATEGORY
"
\]
,
"title"
:
"
PRODUCT_TITLE
"
,
"availability"
:
"IN_STOCK"
}
Java
public
static
Product
createProduct
(
Product
productToCreate
,
String
productId
)
throws
IOException
{
return
getProductServiceClient
().
createProduct
(
DEFAULT_BRANCH_NAME
,
productToCreate
,
productId
);
}
Update product information
As your product catalog changes, you can refresh your catalog by uploading
changes in products such as new products, prices, and stock status in real
time. You can upload only products that have been added or changed; you don't need to reload your entire catalog.
curl
Update product information by using the
products.patch
method.
The following example updates the title for a specific product:
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
"{
"
title
": "
new-title-value
"
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
?updateMask=title"
If the request is successful, the product object is returned, such as in the
following example.
{
"name"
:
"projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
"
,
"id"
:
"
PRODUCT_ID
"
,
"primaryProductId"
:
"
PRODUCT_ID
"
,
"type"
:
"PRIMARY"
,
"categories"
:
\[
"Parent category > Child category"
\]
,
"title"
:
"new product title"
,
"availability"
:
"IN_STOCK"
}
Java
public
static
Product
updateProduct
(
Product
productToUpdate
)
throws
IOException
{
return
getProductServiceClient
().
updateProduct
(
productToUpdate
,
FieldMask
.
getDefaultInstance
());
}
Delete product information
Although the API provides a way to delete products from your
catalog, keep in mind that if you record a user event that relates to a product
item that has been deleted, the API cannot process the user
event properly and it might be deleted. In addition, including historical
catalog data improves the quality of your model and is critical for good
recommendations and search results.
You should set the
availability
of obsolete products to
OUT_OF_STOCK
rather than deleting them.
curl
Delete a product by using the
delete
method, replacing
PRODUCT_ID
with the ID of the product you want to
delete.
curl
-X
DELETE
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
"
Java
public
static
void
deleteProduct
(
String
productName
)
throws
IOException
{
getProductServiceClient
().
deleteProduct
(
productName
);
}
Retrieve a product item
curl
You retrieve a product item by making a
GET
request to the
products
endpoint, replacing
PRODUCT_ID
with the ID
of the product you want to retrieve:
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
"
You should see output similar to the following:
{
"name"
:
"projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/
PRODUCT_ID
"
"id"
:
"
PRODUCT_ID
"
,
"primaryProductId"
:
"
PRODUCT_ID
"
,
"type"
:
"PRIMARY"
,
"categories"
:
\
[
"Parent category > Child category"
\
],
"title"
:
"product title"
,
"availability"
:
"IN_STOCK"
}
Java
public
static
Product
getProduct
(
String
productName
)
throws
IOException
{
return
getProductServiceClient
().
getProduct
(
productName
);
}
View aggregated information about your catalog
You can view aggregated information about your catalog and preview uploaded
products under the
Catalog
tab in the
Data
page of the Search for commerce console.
Assess catalog data quality
To assess the quality of your catalog data:
Go to the
Data quality
page in the Search for commerce console.
Go to the Data quality page
The
Data quality
page
assesses if you need to update catalog data to improve the quality of your
search results and unlock search performance tiers.
For more about how to check search data quality and view search performance
tiers, see
Unlock search performance tiers
.
For a summary of available catalog metrics, see
Catalog quality metrics
.
Change product types
When importing a product, you can specify if the product's type is primary,
variant, or a collection. If a product's type changes or was specified
incorrectly, you must
delete the product
and
create it
it
with the updated type specified.
A product's type can be set to
TYPE_UNSPECIFIED
,
PRIMARY
,
VARIANT
, or
COLLECTION
. For more details, see
product.Type
in the
reference documentation.
Change product level configuration
Deprecated:
The Merchant Center connector is deprecated and only
available to current users. New users must use the Catalog API or BigQuery to
import catalogs. Only customers with prior access can use the feature. If you're an existing customer and have access to Merchant Center, then continue reading.
To import a catalog with Merchant Center, you must specify
if the products are primaries or variants.
If the
product levels
change or were specified incorrectly, use this
procedure to correct their configuration. You must have the
Retail Admin
IAM role to complete this procedure.
Make sure no imports are occurring while you reconfigure the product
levels. This verifies that data does not get uploaded at the wrong level.
Delete all product items. See
products.delete
.
The catalog must be completely empty before proceeding to the next step.
Re-import your data to change the product level configuration.
This procedure depends on how you import. Follow the appropriate procedure in
Import Catalog Information
to set the product levels to
their new configuration.
Finish importing the new catalog with the modified level configuration, using
your chosen procedure in
Import Catalog Information
.
Tune all existing models.
To tune a model, go to the
Models page
, click the model
name to view its details page, then click
Manual Tune
in the button bar.
Go to the Models page
For tuning cost details, see
Pricing
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-configs.txt
Manage serving configs  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage serving configs
This page describes how to delete, edit, and list serving configs, as
well as review statistics about each configuration.
For help with creating a new serving config, see
Create serving configs
.
It is not necessary to configure a serving config for search to work. Any
serving_config_id
can be placed as part of the search request, in which case, it defaults to an empty or non-configured serving control. The catalog is then searched with Vertex AI Search for commerce default search capability.
If you have existing placements, or create new placements, Vertex AI Search for commerce
automatically creates a serving config associated
with each placement. Creating a serving config does not create a
corresponding placement. Deleting a serving config deletes its
corresponding placement, and deleting a placement deletes its corresponding
serving config.
Edit serving configs
You can edit serving configs using the Search for commerce console
or the API.
Note:
If you are making significant changes to a a serving config that contains
a Page-Level Optimization model, the Page-Level Optimization model might return suboptimal results while it is
retraining. Because it can take a long time to retrain the Page-Level Optimization model,
consider recreating the Page-Level Optimization model and its associated serving config.
Edit serving configs in the console
You can see and edit the controls for each serving config on the
Serving Configs page
. Click a
serving config to see its
Details
page, which lists all serving and
site-wide controls for that configuration.
On this page, you can edit controls, create new controls, or apply existing
controls to the configuration.
It takes a few minutes for newly created or updated serving configs to
be ready to serve live traffic. You can test changes right away on the
Evaluate
page
.
Edit serving configs inline
You can update serving config fields, add serving controls, and remove
serving controls inline using API methods.
Patch serving configs inline
To update fields in a serving config, use
ServingConfig.patch
and include an instance of
ServingConfig
in the request body. Specify the
fields to update with the
updateMask
parameter, or leave it unset to update
all supported fields.
For more about this method, see the
ServingConfig.patch
API reference
.
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-d
'{
"name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
",
"
FIELD_NAME_1
": "
NEW_FIELD_VALUE_1
"
"
FIELD_NAME_2
": "
NEW_FIELD_VALUE_2
"
}'
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
?updateMask=
FIELD_NAME_1
,
FIELD_NAME_2
'
Add controls to serving configs inline
To add a control to a serving config, use
ServingConfig.addControl
.
The control is added in the last position of the list of controls it belongs to.
For example, a
facetSpec
control is applied in the last position of
servingConfig.facetSpecIds
.
For more about this method, see the
ServingConfig.addControl
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-d
'{
"controlID": "
CONTROL_ID
"
}'
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
:addControl'
Remove controls from serving configs inline
To remove a control from a serving config, use
ServingConfig.removeControl
.
For more about this method, see the
ServingConfig.removeControl
API reference
.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-d
'{
"controlID": "
CONTROL_ID
"
}'
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
:removeControl'
View serving configs
You can view serving configs using the Search for commerce console
or the API.
View serving configs in the console
You can see all of your serving configs on the
Serving Configs page
.
View serving configs inline
To see a single serving config inline, use
ServingConfig.get
.
For more about this method, see the
ServingConfig.get
API reference
.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
'
To list all serving configs inline, use
ServingConfig.list
.
Optionally, you can use the parameter
pageSize
to set a maximum number of
results to return. If more results are available, the
list
response includes a
page token. You can pass a page token in the
pageToken
parameter of a
list
request to retrieve the next page of results.
For more about this method, see the
ServingConfig.list
API reference
.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs?pageSize=
PAGE_SIZE
&pageToken=
PAGE_TOKEN
'
Delete a serving config
You can delete serving configs using the Search for commerce console
or the API.
Note:
If you delete a serving config that is being used by a Page-Level Optimization model, also
delete and re-create the Page-Level Optimization model. Otherwise the Page-Level Optimization model will return
the deleted serving config.
Delete serving configs in the console
To delete a serving config in the console:
Go to the
Serving Configs
page in the Search for commerce console.
Go to the Serving configs page
Click the serving config you want to delete to open its details page.
Click
delete
Delete
in the button bar at the
top of the page.
If the serving config is considered active, you must retype its ID and
click
Confirm
to complete the deletion.
Delete a serving config inline
To delete a single serving config inline, use
ServingConfig.delete
.
For more about this method, see the
ServingConfig.delete
API reference
.
curl
-X
DELETE
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
'
Reviewing serving config statistics
You can see details for each serving config on the
Serving Configs page
. For any
configuration in the table, click
View analytics
to see its statistics.
Click-through-rate
shows the clicks per search for the serving config.
Conversion rate
indicates the purchases per search for the configuration.
Note:
The time periods for statistics are in the Pacific time zone. For example,
daily statistics represent the data from yesterday at midnight Pacific time to
today at midnight Pacific time.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-controls.txt
Manage serving controls  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage serving controls
This page describes how to view, edit, delete, export, and import serving
controls.
For general information about serving controls and instructions on how to create
serving controls, see
About serving controls
and
Create serving controls
.
View and edit serving controls
You can view serving controls for Vertex AI Search for commerce using the console
and the API.
View and edit serving controls in the console
The
Serving Controls
tab
of the Controls page lists all of your serving controls and their associated
serving configs. Click the
edit
Edit control
icon for a control to change
its settings and associated serving configs in the
Edit control
panel. Click the
delete
Delete control
icon for
a control to delete it, which also removes it from all serving configs.
You can also see and edit the controls for a specific serving config on
the
Serving Configs
page
.
Click a serving config to see its
Details
page, which lists all
serving controls for that configuration. Click the
edit
Edit control
icon for a control to change
its settings in the
Edit control
panel. Click the
do_not_disturb_on
Remove control
icon to
dissociate the control from the serving config (this does not delete the
control).
It takes a few minutes for newly created or updated controls to be ready to
serve live traffic. You can test if your changes have been applied on
the console
Evaluate
page
.
View serving controls inline
To see a single serving control inline, use
Control.get
.
For more about this method, see the
Control.get
API reference
.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls/
CONTROL_ID
'
To list multiple serving controls inline, use
Controls.list
.
Optionally, you can use the parameter
pageSize
to set a maximum number of
results to return. If more results are available, the
list
response includes a
page token. You can pass a page token in the
pageToken
parameter of a
list
request to retrieve the next page of results.
To list only the controls associated with a certain serving config, use
the
filter
query parameter to specify the serving config ID.
For more about this method, see the
Control.list
API reference
.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'
https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls?pageSize
=
PAGE_SIZE
&
pageToken
=
PAGE_TOKEN
&
filter
=
servingConfig
=
SERVING_CONFIG_ID
Patch serving controls inline
To update fields in a serving control, use
Controls.patch
and include an instance of
Control
in the request body. Specify the
fields to update with the
updateMask
parameter, or leave it unset to update
all supported fields.
For more about this method, see the
Controls.patch
API reference
.
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-d
'{
"name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls/
CONTROL_ID
",
"
FIELD_NAME_1
": "
NEW_FIELD_VALUE_1
"
"
FIELD_NAME_2
": "
NEW_FIELD_VALUE_2
"
}'
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls/
CONTROL_ID
?updateMask=
FIELD_NAME_1
,
FIELD_NAME_2
'
Add controls to serving configs inline
To add a control to a serving config, use
ServingConfig.addControl
.
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Remove controls from serving configs inline
To remove a control from a serving config, use
ServingConfig.removeControl
.
For more about this method, see the
ServingConfig.addControl
API reference
.
For an example of this method, see
Manage serving configs
.
Delete a serving control
You can delete a serving control from the console or inline using the
Controls.delete
method.
Delete a serving control in the console
Delete a serving control to remove that control from all serving configs
that are using it.
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
In the table row of the control you plan to remove, click
delete
Delete
.
In the confirmation window, click
Delete
to complete the deletion.
Delete a serving control inline
To delete serving controls inline, use
Controls.delete
.
For more about this method, see the
Controls.delete
API reference
.
curl
-X
DELETE
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2beta/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/controls/
SERVING_CONTROL_ID
'
Export serving controls
Preview
This feature is
        
        subject to the "Pre-GA Offerings Terms" in the General Service Terms section of the
Service Specific
        Terms
.
        
        Pre-GA features are available "as is" and might have limited support.
      
      For more information, see the
launch stage descriptions
.
You can export your serving controls to a file in a Cloud Storage bucket.
There are two reasons that you might want to export and import serving controls:
To move serving controls from one project to another.
To perform a bulk edit on all or some serving controls. Export the serving
controls, edit the exported file, and then import the file to change or add
serving controls.
You can export and import through the Search for commerce console.
When you export serving controls, you export all the serving controls in the
project.
To export serving controls, do the following:
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
Export controls
.
In the
Export Serving Controls
window, select the Cloud Storage bucket
to which you want to export the controls file.
Click
Export
.
The exported controls are saved to a NDJSON file in the selected bucket with
a name in the following format:
projects_
PROJECT_ID
_
TIMESTAMP
_exported_controls.ndjson
After the export operation completes, you can see the operation status in
the
Bulk import, export, delete activities
list in the
Export
activity
window. Open the
Export activity
window by clicking
Show
in the message window or by following the instructions in
See status for a
specific integration operation
.
Import serving controls
Preview
This feature is
        
        subject to the "Pre-GA Offerings Terms" in the General Service Terms section of the
Service Specific
        Terms
.
        
        Pre-GA features are available "as is" and might have limited support.
      
      For more information, see the
launch stage descriptions
.
To add serving controls or modify existing ones in bulk, you can make your
changes in an exported controls file. You can then import them into
the original project or into a different
project.
Things to know about importing serving controls:
You can't import a serving control file if it contains both
search and recommendations serving controls.
When you import serving controls, all the serving controls in the file become
associated with the serving config that you specify on import. If a
serving control is already associated with another serving config in
the project, that association is also maintained.
To import serving controls, do the following:
Edit and review an exported serving control file and place the file in a
Cloud Storage bucket. (To export serving controls, see the preceding task
Export serving controls
.)
Ensure that the file contains only search serving controls or
only recommendations serving controls. You cannot import a
file that contains both types.
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
On the
Serving controls
tab, click
Import controls
.
In the
Import Serving Controls
window:
Browse and select the
Cloud Storage bucket and NDJSON file that contains the controls that you
want to import.
Select the serving config that you want to associate the imported serving
controls with.
Review the Import Preview plan. The controls that will be created are
displayed on the
New
tab and the controls that will be
modified are displayed on the
Modified
tab.
Click
Import
.
A long-running operation is started to import the new and modified
controls.
After the import operation completes, you can see the operation status in the
Controls
tab of the
Activity status
window. Open the
Activity
status
window by clicking
Show
in the message window or by following
the instructions in
See status for a specific integration operation
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-models.txt
Manage models  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage models
This page describes how to tune, pause, resume, delete, and list
recommendation models. For help with creating a new recommendation model, see
Create recommendation models
.
Note:
Model management is only available for recommendations.
General recommendations for model quality
Events should generally be uploaded at least daily to maintain good data quality.
Data age limits
: User events older than 2015 are not accepted. For auto-learning suggestions, the system uses user events from the past 180 days. Similarly, metrics for user events older than 180 days or generated more than 180 days ago are not exportable.
Unique visitor IDs
: The total number of unique visitor IDs for each event type should be at least 100 to ensure enough data for quality results.
Most models perform best with at least three months of product page views, home page views, and
add-to-cart
events.
For the Frequently Bought Together model, one to two years of purchase history is recommended. This model specifically requires
one
of the following:
On average, 10 occurrences per catalog item (with a one-year window of purchase-complete events).
Both
90 days of purchase-complete events in the last year
and
1,000 purchase-complete events in that same year.
One to two weeks of detail-page views can be sufficient to begin training
Others You May Like
and
Recommended for You
models.
Tune a model
Vertex AI Search for commerce uses the input data you provide to your model to
adjust hyperparameters for training.
Tuning takes 2-4 days, during which the model continues to work as usual.
 For tuning cost details, see
Pricing
.
Set a model's tuning frequency
We recommend you periodically tune your model. This keeps model training optimal
as data changes and customer behavior differs throughout the year. In addition,
some internal major model upgrades can only be applied after the model has
been tuned.
When creating the model, you can set it to automatically tune every three
months, or choose to only tune it manually. Regardless of the setting you
choose, the model automatically tunes one time after creation.
You can change the tuning status setting at any time. Changing this setting
doesn't affect running tuning processes.
To edit a model's tuning status setting:
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
You can see the tuning status of every model under
Tuning status
.
Click a model name to view its details page.
Click
Edit
edit
next to
Tuning
status
.
From the drop-down list, select a setting:
Every three months
. Automatically tunes when the last tune was 90
days ago.
Manual tune only
. Tunes only when you
manually tune
.
Click
Done
done
to save your setting.
curl
Make a
Models.patch
request using the API. See the
Models.patch
API reference.
For details about all
Models
fields, see the
Models
API reference
.
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
-d
'{
"name": "projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
",
"PeriodicTuningState": "
NEW_TUNING_STATE_VALUE
"
}'
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
?updateMask=PeriodicTuningState'
Manually tune a model
Manual tune triggers a one-time tune of your model. You might manually tune your
model when there is a significant change in your catalog (such as size increase
or change in catalog hierarchy) or events (such as backfilling historical events
or a change in data distribution after promoting certain groups of items).
To manually tune a model:
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
Click a model name to view its details page.
Click
Manual Tune
in the button bar.
Tuning takes 2-4 days, during which the model continues to work as usual.
curl
Make a
Models.tune
request using the API. See the
Models.tune
API reference.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
:tune'
Pause and resume training for a model
If your model is active (not paused), the model is retrained at least once a
week, but no more often than once a day. For consistent retraining, make sure
that you upload user event data no more than 24 hours after the event occurs.
You can pause your model to stop retraining. You might want to do this if you
have imported bad data or to stay under the limit of 10 active models per
project. If you have fewer than 10 active models,
you can restart a paused model at any time.
For training cost details, see
Pricing
.
You can start up to five model operations per minute. Limited model operations
include creation, deletion, pause, and resume.
To pause or restart a model:
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
You can see the training status of every model under
Training status
.
To pause an active model (
Training status
of
TRAINING
), click
Pause
pause
.
To start a paused model (
Training status
of
PAUSED
), click
Resume
play_arrow
.
curl
To pause an active model, make a
Models.pause
request using the
API. See the
Models.pause
API reference.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
:pause'
To start a paused model, make a
Models.resume
request using the
API.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
:resume'
View model details
View a model's details in the console or using the
Models.get
API method.
To see the serving configs that are associated with a specific model, use this procedure. All other model details are available in the
console and the API response.
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
The
Models
page lists all your models and their training and query
statuses.
Click a model name to view its
Details
page.
curl
To get a single model's information, make a
Models.get
request using the
API. See the
Models.get
API reference.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
'
List your models
View a list of your models in the console or using the
Models.list
API method.
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
The
Models
page lists all your models and their training and query
statuses.
curl
To list all models and their details inline, make a
Models.list
request
using the API. See the
Models.list
API
reference.
Optionally, you can use the parameter
pageSize
to set a maximum number of
results to return. If more results are available, the
list
response
includes a page token. You can pass a page token in the
pageToken
parameter of a
list
request to retrieve the next page of results. This
example uses both parameters.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models?pageSize=
PAGE_SIZE
&pageToken=
PAGE_TOKEN
'
Delete a model
You can start up to five model operations per minute. Limited model operations
include creation, deletion, pause, and resume.
Delete a model in the console or using the
Models.delete
API method.
Console
Go to the
Models
page in the Search for commerce console.
Go to the Models page
Click the name of the model you want to delete to open its details page.
Click
Delete
delete
in the button bar.
Reenter the model name and click
Confirm
.
curl
Make a
Models.delete
request using the API. See the
Models.delete
API reference.
For details about all
Models
fields, see the
Models
API reference
.
curl
-X
DELETE
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
'https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/models/
MODEL_ID
'
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-site-controls.txt
Manage site-wide attribute controls  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage site-wide attribute controls
This page describes how to manage site-wide attribute controls.
Site-wide controls apply to all search results or all recommendation
results, depending on what type of site-wide attribute control you apply.
About site-wide attribute controls
Side-wide attribute controls enable you to manage settings globally across all
serving configurations.
Site-wide attribute controls are available in the Search for commerce
console for your catalog's product attributes.
Search uses the following attribute settings:
Indexable
: Search can filter and facet using this attribute.
Dynamic faceting
: Search can automatically use this
    attribute as a dynamic facet based on past user behavior such as facet clicks
    and views. To enable dynamic faceting for an attribute,
Indexable
must be set to true for that attribute.
Searchable
: This attribute is searchable by search
    queries, which increases recall for that attribute. This control is applicable
    only for text attributes.
Retrievable
: If set to true, search returns this
    attribute in responses to search queries. If all attributes have
    Retrievable set to false, the search results contain only the product name
    or (for variants) the product name and color information. The REST field RetrievableFields is deprecated for products. Use the retrievable site-wide control instead.
Recommendations uses the following attribute settings:
Filterable
(Public Preview): This attribute can be used in recommendations
    filter expressions. This control is applicable only for text attributes.
You can enable or disable side-wide attribute controls for individual
attributes.
Dynamic faceting is available as a site-wide attribute control. By default,
dynamic faceting is enabled for all custom attributes.
In
catalog-level configuration mode
, site-wide attribute controls
are available for indexable and searchable.
For details about attribute configurations and what their default and allowed
settings are, see the topic
About product attributes
.
Modify site-wide attribute controls
Change a site-wide attribute control on the
Controls page
in the
Search for commerce console.
Note:
Setting site-wide attribute controls globally is available in the default
catalog-level configuration mode
. Previously, product-level
configuration was the default mode. If you are still on product-level
configuration mode and need to switch modes, contact Vertex AI Search for commerce support.
Go to the
Controls
page in the Search for commerce console.
Go to the Controls page
Go to the
Site-wide controls
tab.
This tab displays a table of all product attributes you can set site-wide
attribute controls for.
Click
edit
Modify Controls
.
Enable or disable a control.
True
: Enable a control for that attribute. This overrides any
product-level attributes configuration.
False
: Disable a control for that attribute. This overrides any
product-level attribute configuration.
Note that you can only set dynamic faceting to true for attributes that
are also set to indexable.
Click
Save Controls
.
Changes to attribute configuration settings for indexable and searchable take
effect within 12 hours, or immediately on your next catalog ingestion.
Dynamic faceting configuration changes take up to two days. You can test if
your changes have been applied on the
Evaluate
page
, which will
reflect your changes immediately.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/manage-user-events.txt
Manage user events  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Manage user events
This page describes how to view and delete user events. For information about
recording user events as they happen, see
Record real-time user events
. To import user event data from
past events, see
Import historical user events
.
Rejoin user events tutorial
This tutorial show how to rejoin user events by making a
POST
request to the
userEvents:rejoin
endpoint.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Remove user events tutorial
This tutorial show how to purge user events.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
View aggregated user event information
View event integration metrics in the
Events
tab on the Search for commerce console
Data
page. This page shows all events written or imported in last year. Metrics can take up
  to 24 hours to appear after successful data ingestion.
Go to the Data page
Rejoin user events
You can rejoin user events by making a
POST
request to the
userEvents:rejoin
endpoint.
The rejoin operation joins specified events with the latest version of the
product catalog.
A user event is considered unjoined if the product it is associated with isn't
present in the catalog at the time that the user event is ingested. Unjoined
events lack detailed product information and are not as useful to training
models and serving results.
In addition to addressing unjoined events, the rejoin operation can be used to
correct events that have been joined with the wrong product catalog.
You must have the
Retail AI Admin
IAM role to call this method. A rejoin
operation can take hours or days to complete.
curl
Set
userEventRejoinScope
according to the types of events you're rejoining:
USER_EVENT_REJOIN_SCOPE_UNSPECIFIED
: Default. Trigger rejoin for both joined
and unjoined events.
JOINED_EVENTS
: Trigger rejoin for only joined events.
UNJOINED_EVENTS
: Trigger rejoin for only unjoined events.
The following example triggers a rejoin for only unjoined events:
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
"{
'userEventRejoinScope': 'UNJOINED_EVENTS'
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:rejoin"
You should receive a response object that looks something like this:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/
OPERATION_ID
"
}
You can check the status of the rejoin. Replace
OPERATION_ID
with the
ID of the operation ID returned by the rejoin method:
curl
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/
OPERATION_ID
"
When the operation completes, the operation status returns as
done
:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/
OPERATION_ID
"
,
"done"
:
true,
"response"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.RejoinUserEventsResponse"
,
"rejoinedUserEventsCount"
:
"1"
}
}
Java
public
static
String
rejoinUserEvents
(
UserEventRejoinScope
scope
)
throws
IOException
,
InterruptedException
,
ExecutionException
{
UserEventServiceClient
userEventsClient
=
getUserEventServiceClient
();
RejoinUserEventsRequest
request
=
RejoinUserEventsRequest
.
newBuilder
()
.
setParent
(
DEFAULT_CATALOG_NAME
)
.
setUserEventRejoinScope
(
scope
)
.
build
();
String
operationName
=
userEventsClient
.
rejoinUserEventsAsync
(
request
).
getName
();
userEventsClient
.
shutdownNow
();
userEventsClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
operationName
;
}
Remove user events
Generally, you should leave user events in place after they have been recorded.
Purging events is not recommended.
An event purge can take up to several days to complete. If you plan to reset
user events entirely, consider creating a new project instead.
If you have user events that were not recorded properly and need to remove them,
you can do so using the
userEvents.purge
method.
Specify the events you want to remove by using a
filter string
. This
supports selectively deleting user events by filtering on the
eventTime
,
eventType
,
visitorID
, and
userID
fields.
Because you cannot undo the delete, test your filter string by conducting a dry
run before deleting user events. The
force
field is set to
false
by
default; this setting will return the number of events to be deleted without
actually deleting them. When you are ready to actually delete the user events,
set the
force
field to
true
.
curl
This example filters for a time range, which must use the
Zulu Time date format
.
The
force
field is set to
false
.
curl
-X
POST
\
-H
"Authorization: Bearer "
$(
gcloud
auth
application-default
print-access-token
)
""
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"filter":"eventTime > \"2019-12-23T18:25:43.511Z\" eventTime < \"2019-12-23T18:30:43.511Z\"",
"force":"false"
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:purge"
You should receive a response object that looks something like this, where
purge-user-events-54321
is the operation ID:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/purge-user-events-54321"
}
This example requests the operation status:
curl
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/
OPERATION_ID
"
Operation status example:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/
OPERATION_ID
"
,
"done"
:
true,
"response"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.PurgeUserEventsResponse"
,
"purgedEventsCount"
:
"1"
}
}
Setting the
force
field to
true
forces the delete to occur.
curl
-X
POST
\
-H
"Authorization: Bearer "
$(
gcloud
auth
application-default
print-access-token
)
""
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"filter":"eventTime > \"2019-12-23T18:25:43.511Z\" eventTime < \"2019-12-23T18:30:43.511Z\"",
"force":"true"
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:purge"
Java
public
static
String
purgeUserEvents
(
String
filter
)
throws
IOException
,
InterruptedException
,
ExecutionException
{
UserEventServiceClient
userEventsClient
=
getUserEventServiceClient
();
PurgeUserEventsRequest
request
=
PurgeUserEventsRequest
.
newBuilder
()
.
setParent
(
DEFAULT_CATALOG_NAME
)
.
setFilter
(
filter
)
.
setForce
(
true
)
.
build
();
String
operationName
=
userEventsClient
.
purgeUserEventsAsync
(
request
).
getName
();
userEventsClient
.
shutdownNow
();
userEventsClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
operationName
;
}
Use the user event filter
You can filter user events to be deleted.
The filter is a string that contains one or more of the following restrictions:
eventTime
Provides a timestamp to bound the events to be deleted. This filter can
be specified once or twice, with a greater-than (>) or less-than (<) symbol.
The bounded time must be a single, contiguous block.
eventType
Restrict the events to be deleted to a single event type.
visitorID
Restrict the events to be deleted to a single visitor ID.
userID
Restrict the events to be deleted to a single user ID.
Only user events that satisfy all of the restrictions are deleted.
To delete all user events of type
add-to-cart
that were logged
on or after February 1, 2019, you would provide the following filter string:
eventTime
>
"2019-02-01T00:00:00Z"
eventType
=
add-to-cart
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/metrics.txt
View analytics  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
View analytics
This page describes metrics that can help you determine how Vertex AI Search for commerce is
affecting your business.
Prerequisites
The analytics dashboards use ingested
user events
as data sources for metrics. You must complete user events integration to be able to see user event analytics. Metrics are refreshed about every six hours, so it can take hours after you create your app to see metrics on the
Analytics
pages.
User events
The following user events are required to view some metrics:
Search events.
Required for any type of metrics.
Detail page view events.
Required for page view metrics.
Add-to-cart events.
Required for add-to-cart rate, conversion rate.
Purchase-complete events.
Required for total revenue, recommender-engaged revenue, average order value, purchase rate, revenue rate, average unit value, purchase order rate, conversion rate.
The following information is also used for analytics:
Product details
. To ensure accurate computation of search-related
metrics, include
UserInfo.productDetails
within
your user events. This information allows Vertex AI Search for commerce
to attribute searches with specific product interactions.
If the
UserInfo.ProductDetail.quantity
field is omitted within user
events, a default value of
1
will be assumed for calculations.
Revenue
. The
UserInfo.PurchaseTransaction.revenue
field is crucial
for generating accurate revenue metrics. Ensure this field is populated
within your user events to enable meaningful revenue-related analysis.
Attribution tokens
. Attribution tokens are unique IDs generated by
Vertex AI Search for commerce and returned with each search request. Make sure
to include that attribution token as
UserEvent.attributionToken
with any
user events resulting from a search. This is needed to identify if a search
is served by Vertex AI Search for commerce.
User agent
. Include
UserInfo.userAgent
with user events resulting
from a search so that you can filter on user event metrics by device type.
View recommendations analytics
To view recommendation analytics:
In the Google Cloud console, go to the
Search for commerce
page.
Go to the Search for commerce console
In the navigation menu, click
Analytics
.
Click the
Recommendation
tab.
Use filters to view your metrics:
If available, enter a custom date range or select a preset range.
You can select a device type on which the recommendation occurred.
To show metrics for a recommendation setting, use all of the following filters. Set none to display aggregated metrics over all recommendation settings.
Serving config ID
Recommendation ID
Context event type with a displayed recommendation
Note:
Metrics displayed might be higher than actual values if only some recommendation setting filters are set while others are not.
View search analytics
If there are no user events, default values are shown for all metrics.
To view search analytics:
In the Google Cloud console, go to the
Search for commerce
page.
Go to the Search for commerce console
In the navigation menu, click
Analytics
.
Click the
Search
tab.
Click a tab to view that metric group:
Per Search
. Metrics are grouped by searches.
Per Visit
. Metrics are grouped by search visits.
To filter your metrics, use the following filters:
Date range
. Select a preset date range or, if available,
enter a custom date range.
Device type
. Select a device type that queries occurred on.
View browse analytics
If there are not yet any user events, default values are shown for all metrics.
To view browse analytics:
In the Google Cloud console, go to the
Search for commerce
page.
Go to the Search for commerce console
In the navigation menu, click
Analytics
.
Click the
Browse
tab.
Click a tab to view that metric group:
Per Browse
. Metrics are grouped by browses.
Per Visit
. Metrics are grouped by browse visits.
To filter your metrics, use the following filters:
Date range
. Select a preset date range or, if available,
enter a custom date range.
Device type
. Select a device type that browsing occurred on.
View serving config analytics
In the Google Cloud console, go to the
Search for commerce
page.
Go to the Search for commerce console
In the navigation menu, click
Serving Configs
.
Click the name of the serving config that you want to view analytics for.
Click the
Analytics
tab.
Select a metric type from the
Metric
drop-down list to see its graph for the last month.
Metrics definitions
These sections provide definitions of the site-wide metrics displayed on the
Analytics
page
:
Recommendations summary metrics
: Metrics
representing user engagement with recommendation results.
search summary metrics:
Text query search summary metrics
: Metrics representing
engagement with text-based query search results.
Browse search summary metrics
: Metrics representing
engagement with category browse search results.
Recommendations summary metrics
The following metrics are displayed for recommendations on the
Recommendations
tab.
Metric
Description
Recommendation count
The total number of recommendations performed across the entire site.
Detail page-view count
The number of times a recommended product was clicked.
Add-to-cart count
The number of times a recommended product was added to a cart.
Purchase count
The number of purchase orders in which at least one product was recommended.
Purchase revenue
The revenue of purchase orders in which at least one product was recommended.
Click-through rate (CTR) per recommendation
The percentage of times a recommended product was clicked out of the total number of times it was recommended.
Add-to-cart rate per recommendation
The percentage of times a recommended product was added to a cart out of the total number of times it was recommended.
Purchase rate per recommendation
The percentage of times an order that included a recommended product was purchased out of the total number of times the product was recommended.
Average order value per recommendation
The revenue of an order that included the recommended product that was purchased out of the total number of times it was recommended.
Text search summary metrics
The following metrics for text searches are displayed on
the
Search
tab.
Metric
Description
Search count
The total number of searches performed site-wide.
No results rate
The number of searches without results divided by the total number
        of searches.
Click-through rate (CTR) per search
The number of clicks from search results divided by the total
        number searches.
Add-to-cart (ATC) rate per search
The number of add-to-cart events occurring from search results divided
        by the total number of searches.
Purchase rate per search
The number of units in purchase-complete events occurring from search
        results divided by the total number of searches.
Revenue rate per search
The amount of revenue generated from purchase-complete events
        divided by the total number of searches.
Average unit value (AUV) per search
The amount of revenue generated from purchase-complete events divided
        by the total unit quantity generated by purchase-complete events.
Calculated based solely on purchase-complete events attributed to
        searches.
Personalization rate
The number of personalized searches divided by the total number of
        searches.
Search visit count
The total number of search visits performed site-wide.
Page view per search visit
The total number of detail-page-view events occurring in the search
        visit divided by the total number of search visits.
Add-to-cart (ATC) rate per search visit
The number of add-to-cart events occurring in the search visit
        divided by the total number of search visits.
Calculated by including all add-to-cart events, regardless of whether
        they can be directly attributed to the search.
Purchase order rate per search visit
The number of purchase-complete events occurring in the search visit
        divided by the total number of search visits.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the search.
Revenue rate per search visit
The amount of revenue generated from purchase-complete events in search
        visit divided by the total number of search visits.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the search.
Average order value (AOV) per search visit
The amount of revenue generated from purchase-complete events in
        the search visit divided by the number of purchase-complete events
        occurring in the search visit.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the search.
Browse search summary metrics
The following metrics for browse searches are displayed
on the
Browse
tab.
Metric
Description
Browse count
The total number of browse searches performed site-wide.
No results rate
The number of browse searches without results divided by the total
        number of browse searches.
Click-through rate (CTR) per browse
The number of clicks from browse results divided by the total number of
        site-wide browse searches
The total number of browse searches includes paginated queries.
Add to cart (ATC) rate per browse
The number of add-to-cart events occurring from browse results
        divided by the total number of browse searches.
Purchase rate per browse
The number of units in purchase-complete events occurring from browse
        results divided by the total number of browse searches.
The total number of browse searches includes paginated queries.
Revenue rate per browse
The amount of revenue generated from purchase-complete events
        divided by the total number of browse searches.
Average unit value (AUV) per browse
The amount of revenue generated from purchase-complete events divided
        by the total unit quantity generated by purchase-complete events.
Calculated based solely on purchase-complete events attributed to
        browse searches.
Personalization rate
The number of personalized browse searches divided by the total number
        of browse searches.
Browse visit count
The total number of browse search visits performed site-wide.
Page view per browse visit
The total number of detail-page-view events occurring in the browse
        search visit divided by the total number of browse search visits.
Add to cart (ATC) rate per browse visit
The number of add-to-cart events occurring in the browse search visit
        divided by the total number of browse search visits.
Calculated by including all add-to-cart events, regardless of whether
        they can be directly attributed to the browse search.
Purchase order rate per browse visit
The number of purchase-complete events occurring in the browse search
        visit divided by the total number of browse search visits.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the browse search.
Revenue rate per browse visit
The amount of revenue generated from purchase-complete events in the
        browse search visit divided by the total number of browse search visits.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the browse search.
Average order value (AOV) per browse visit
The amount of revenue generated from purchase-complete events in
        the browse search visit divided by the number of purchase-complete
        events occurring in the browse search visit.
Calculated by including all purchase-complete events, regardless of
        whether they can be directly attributed to the browse search.
Configuration-specific metrics
Note:
Serving config metrics are only available for
recommendations.
You can see metrics for a specific serving config on the
Serving Configs page
.
For metric graphs, click a serving config name to go to its details page,
then select the
Analytics
tab.
This table provides definitions for configuration-specific metrics.
Metric
Description
Details
Click-through rate (CTR)
The number of product detail views from a serving config's
      recommendation panel, divided by the total number of
predict
queries for this serving config.
For example, if the serving config points to a Frequently Bought Together
      model, then the CTR would be the number of product detail pages viewed
      from the shopping cart recommendation panel divided by the number of
      predict queries on the shopping cart page.
Conversion rate (CVR)
The number of add-to-cart events from a serving config's
      recommendation panel divided by the total number of
predict
queries for this serving config.
Similar to CTR, except that instead of product detail views, conversion
      rate uses add-to-cart events.
Recommender-engaged revenue
The total revenue from the recommendations for this serving config.
Similar to recommender-engaged revenue for summary metrics, but for this
      serving config only.
To track clicks from a serving config, Vertex AI Search for commerce aligns the
results in
predict
and
search
responses with ingested user events. If a
clicked item appears in the responses for the same visitor ID within a
one hour time window, the click or purchase is treated as a result of the
Vertex AI Search for commerce.
This process is fully automatic; you don't need to set anything up. However,
when you configure your prediction and search requests for the first time, you
should confirm that:
Visitor IDs in the request are the same as the visitor IDs you used in event
ingestions.
The timestamp in the response roughly match the timestamp for that event.
When metrics are compared to the ideal expected result, or ground truth, the
values might be lower, but the trends align.
A more direct alternative to this method is to use
attribution tokens
. This requires significant instrumentation and
is only recommended as an advanced tracking use case.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/models-pretrained-llm.txt
Utilizing pretrained LLM  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Utilizing pretrained LLM
This page describes how to use a textual large-language model (LLM) in the custom recommendation models. We train these models for you. You can enable the pretrained features in the
custom recommendation models
.
Recommendations uses the product
description
field to feed to LLMs and put them into your recommendations models.
Note:
Creating and configuring models is only available for
recommendations.
New LLM textual features
While it's possible to get text embeddings by
manually configuring a Vertex AI generative model
, you might want to integrate the new LLM capabilities into your recommendations models to improve performance.
The text embeddings are more descriptive, longer, and are not repetitive, as well as have multilingual interpretation capabilities. This feature is based on an allowlist. Contact support for enabling this feature.
There's no charge for using the text embeddings and they are included in Vertex AI Search
pricing
.
The LLM-pretrained embeddings improve semantic understanding of long form text searches such as descriptions.
See the following resources for more information on how to use embeddings and generative AI alone in your own custom ML training:
Vertex AI generative AI documentation
Machine Learning Crash Course: Embeddings
Model compatibility
The LLM feature is compatible with all ml model types and objectives, including:
OYML
FBT
and more.
For more information on the different types of recommendation models Vertex AI Search for commerce supports, see
About recommendations models
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/models.txt
About recommendation models  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About recommendation models
This page describes the recommendation models
with their default serving configs and optimization objectives,
available customizations, and supported event types.
Note:
Creating and configuring models is only available for
recommendations.
Introduction
When you sign up to use Vertex AI Search for commerce, you work with
Vertex AI Search for commerce Support to determine the best recommendation models and
customizations to use for your site. The models and customizations you use
depend on your business needs, and where you plan to display the resulting
recommendations.
When you request recommendations, you provide
the serving config value to the
placement
resource. (See
About serving
configurations
for details about using the
placement
resource for
serving configs, and about support for placements, which were previously
used to place models.) The serving config
determines which model is used to return your recommendations. You can also
filter your results
.
Recommendation model types
These are the recommendation model types:
Others You May Like
Frequently Bought Together
(shopping cart expansion)
Recommended for You
Buy it Again
On-sale
Recently Viewed
Page-Level Optimization
Others You May Like
The Others You May Like recommendation predicts the next product that a user is most
likely to engage or convert with. The prediction is based on the shopping and
viewing history of the user and the candidate product's relevance to a current
specified product.
Default optimization objective:
click-through rate
Default serving config:
N/A
Available customizations:
Change optimization objective to
conversion rate
or
revenue per session
.
Add
price reranking
.
Add
Result diversification
(supported but not recommended).
Supported pages for model deployment:
Detail page. See
detail-page-view
event.
Add-to-cart page. See
add-to-cart
event.
Frequently Bought Together (shopping cart expansion)
The Frequently Bought Together recommendation predicts items frequently bought together for a
specific product within the same shopping session. If a list of products is
being viewed, then it predicts items frequently bought with that product list.
This recommendation is useful when the user has indicated an intent to purchase
a particular product (or list of products) already, and you are looking to
recommend complements (as opposed to substitutes). This recommendation is
commonly displayed on the
add-to-cart
page, or on the shopping cart or
registry pages (for shopping cart expansion).
Default optimization objective:
revenue per session
Default serving config:
N/A
Available customizations:
Add
Result diversification
(supported but not recommended)
Choose the
context product type
Note:
Boost controls and diversity (rule-based or data-driven) are not compatible with each other. Only specify one of these settings at a time.
Supported pages for model deployment:
Detail page. See
detail-page-view
event.
Add-to-cart page. See
add-to-cart
event.
Shopping cart page. See
shopping-cart-page-view
event
Purchase-complete page. See
purchase-complete
event.
Recommended for You
The Recommended for You recommendation predicts the next product that a user
is most likely to engage with or purchase, based on the shopping or viewing
history of that user and contextual information of requests, such as timestamps.
This recommendation is typically used on the home page.
Recommended for You can also be useful on category pages. 
A category page is similar to a home page, except that you display only items from that category.
You can achieve this using a standard Recommended for You model with filter tags.
For example, you can add customized filter tags (corresponding to each category page) to the items
in your catalog. When you send the prediction request, set the user event object as
category-page-view
and specify a specific category page's tag in the
filter
field. Only recommendation results matching the requested filter tag are
returned. Diversity should be disabled in this use case, because diversity can conflict with
category-based filter tags.
Default optimization objective:
click-through rate
Default serving config:
N/A
Available customizations:
Change optimization objective to
conversion rate
or
revenue per session
.
Add
price reranking
.
Add
Result diversification
.
Supported pages for model deployment:
All
Buy it Again
The Buy it Again model encourages purchasing items again based on previous recurring
purchases. This personalized model predicts products that have been previously
bought at least once and that are typically bought on a regular cadence. The
interval at which a product is suggested depends on the product and site
visitor. Recommendations from this model can be used on any page type.
The Buy it Again model uses purchase-complete user events.
The Buy it Again model cannot be tuned.
We recommend creating only one Buy it Again model per project. Because Buy it Again models
are not customizable, creating multiple Buy it Again models based on the same user
events does not produce different recommendations and can incur unnecessary
costs.
Default optimization objective:
N/A
Default serving config:
N/A
Available customizations:
N/A
Supported pages for model deployment:
All
On-sale
The On-sale model type is a personalized promotions-based model that can
recommend on-sale products. You can use this model type to encourage users to
purchase discounted items.
Typically used on the home page, add-to-cart page, shopping cart page, category
page, and detail page.
Default optimization objective:
Click-through rate
Default serving config:
N/A
Available customizations:
Change optimization objective to
conversion rate
Supported pages for model deployment:
Detail page. See
detail-page-view
event.
Home page. See
home-page-view
event.
Add-to-cart page. See
add-to-cart
event.
Shopping cart page. See
shopping-cart-page-view
event.
Purchase-complete page. See
purchase-complete
event.
Category page. See
category-page-view
event.
Recently Viewed
The Recently Viewed recommendation is not actually a recommendation. It provides the
IDs of products the user or visitor has recently interacted with, with the most
recent products first.
Default optimization objective:
N/A
Default serving config:
recently_viewed_default
Available customizations:
N/A
Supported pages for model deployment:
All
Page-Level Optimization
Page-Level Optimization extends recommendations from optimizing for a single
recommendation panel at a time to optimizing for an entire page with multiple
panels. The Page-Level Optimization model automatically selects the contents for each panel and
determines the panel order on your page.
For example, home pages are typically structured with products organized into
rows of related groups, such as categories, trending items, or recently viewed
products. Using the Page-Level Optimization model on a home page can provide an end user with
a personalized recommendation experience while automating the decision process
for coordinating model combinations and layouts for that page.
To create a Page-Level Optimization model, you must first have existing recommendation serving
configurations that have trained models. When creating a Page-Level Optimization model, you
specify what type of page you'll use the model on, what restrictions you'll
apply to limit serving similar serving configs, what business objective to
optimize for (CTR or CVR), how many recommendation panels to display, and which
serving configs to consider for each panel.
Just as with other models, to use the Page-Level Optimization model you make a prediction call
using a serving config that contains the "Page-Level Optimization" model. Instead of
recommendations, the prediction response contains a sorted list of serving
config IDs representing the serving config to use for each panel. Then, make a
new prediction call for each panel with the corresponding serving config ID that
was returned from the Page-Level Optimization model. The prediction response for each panel
contains the list of recommended items to display in that panel.
Default optimization objective:
N/A
Default serving config:
N/A
Available customizations:
N/A
Supported pages for model deployment:
All
When you enable this feature
Your description information should be explanatory for each product and contain unique information or words separate from the title.
this feature works best when there are at least 10 description words on average.
The percentage of events containing unknown item_ids should be under 10 percent. (The unjoined ratio can be
checked
. Read more about the
definition of unjoined ratio
).
Optimization for business objectives
Machine learning models are created to optimize for a particular business
objective, which determines how the model is built. Each model has a default
optimization objective, but you can request a different optimization objective
to support your business goals by contacting your support representative.
After you have trained a model, you cannot change the optimization objective.
You must train a new model to use a different optimization objective.
Vertex AI Search for commerce supports the following optimization objectives.
Click-through rate (CTR)
Optimizing for CTR emphasizes engagement; you should optimize for CTR when you
want to maximize the likelihood that the user interacts with the recommendation.
CTR is the default optimization objective for the
Others You May Like
and
Recommended for You
recommendation model types.
Revenue per session
The revenue per session optimization objective is available for
"Others You May Like"
,
"Recommended for You"
, and
"Frequently Bought Together"
recommendation
model types. Although objective works differently for each model, the goal is
the same, to increase revenue.
For Others You May Like and Recommended for You.
The objective combines information from clicks,
conversions, and item prices to help the model recommend items that have higher
prices and a higher probability of being purchased.
For Frequently Bought Together.
This objective optimizes for recommending items with a higher
probability of being added to carts, benefiting revenue with by expanding cart
sizes.
Conversion rate (CVR)
Optimizing for conversion rate maximizes the likelihood that the user adds the
recommended item to their cart; if you want to increase the number of items
added to a cart per session, optimize for conversion rate.
Advanced model configuration options
Depending on the model type, there are some other model configuration options
you can use to change the behavior of your model.
Tuning preference
Tuning keeps model training optimal as input data changes over time. Set your
model to automatically tune every three months, or choose to only tune it
manually. The model automatically tunes one time after creation.
Learn more
.
For tuning cost details, see
Pricing
.
Available serving configs and models
Before you can request predictions from your model, you must create at least one
serving config for it. For more information, see
Create serving configs
.
You can see your models listed on the
Models page
. Click a model name to
go to its details page, where you can see serving configs associated with
that model.
Context products
When generating a recommendation, models take into account the products that a
user has previously interacted with in the context of the recommendation panel.
These contextual products are passed into the body of a
predict
request as part of a user event. For example, if there is a
recommendation panel on a shopping cart page, any
shopping-cart-page-view
user event that triggers a
predict
request should include the products that
are in the shopping cart at that time. These products are used as the
context products for that recommendation.
When creating a Frequently Bought Together model, you specify whether that model will generate
recommendations in the context of one or multiple items. Which option you choose
depends on what type of page you plan to use the model.
Multiple context products (default)
: The Frequently Bought Together model can use one or
multiple products as context for its recommendations. This use case is
typically for shopping cart pages that have a variety of contextual products
that can inform the recommendation to be served on that page.
Single context product
: The Frequently Bought Together model can use only one context
product. This use case is typically for pages that have a single product that
would be used as context for recommendations, such as add-to-cart pages and
product detail pages.
Passing more than one product in a
predict
request from a single context
product Frequently Bought Together model does not fail, although it is not recommended because
it might not result in optimal recommendations.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/monitor.txt
Set up Cloud Monitoring alerts  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Set up Cloud Monitoring alerts
This page describes how you can create alerts for Vertex AI Search for commerce,
including examples of creating alerts for user event recording, predictions,
and searches.
For information about data quality alerts, see
Data quality alerts
.
For information about troubleshooting errors and viewing error logs, see
Troubleshooting data upload issues
.
Introduction
Keeping your catalog up to date and recording user events successfully is
important for getting high-quality results. Even if your initial imports
and event recording are successful, monitoring error rates is still needed in
case of unexpected environmental issues, such as network connectivity failures.
You should set up Cloud Monitoring alerts so you can take action promptly in
case any issues arise with user event recording, predictions, and search
results. You can also monitor recent data integration error rates in the
Google Cloud console at any time.
Set up Cloud Monitoring alerts
Cloud Monitoring can be set up to alert on a large number of triggers.
When you set up alerts, Vertex AI Search for commerce suggests
several to set up. If you're unsure which alerts to set up, start with setting
up alerts for
prediction errors
,
search errors
, and
reductions in user event recording
.
Set up an alert for prediction errors
Generally, calling the
predict
method should rarely return an error. This
alert is triggered if the number of errors returned by the predict method causes
the error ratio to stay above the given threshold for more than 5 minutes. You
can adjust the threshold to suit your environment.
To set up alerts from the Search for commerce console:
Go to the
Monitoring
page in the Search for commerce console.
Go to the Monitoring page
Click
add
Recommended Alerts
.
The Recommended Alert Policies panel appears on the right. It displays a list
of recommended alerts to set up for your project.
Enable
High predict error ratio
.
Optionally, adjust the threshold to suit your environment.
The default predict error ratio is 0.03.
Choose a notification channel through which you'll be notified if the alert
is triggered, such as an email address or mobile device.
To set up a new notification channel, select
Notification Channels >
refresh
Manage Notification Channels
.
See
the Cloud Monitoring documentation
for more about creating and editing channels.
Click the
Submit
button to create your alert.
You can also create a custom alert by using Cloud Monitoring. For more
information, see
the Cloud Monitoring documentation
.
Set up an alert for search errors
This alert is triggered if the number of errors returned by the
search
method
causes the error ratio to stay above the given threshold for more than 5
minutes. You can adjust the threshold to suit your environment.
To set up alerts from the Search for commerce console:
Go to the
Monitoring
page in the Search for commerce console.
Go to the Monitoring page
Click
add
Recommended Alerts
.
The Recommended Alert Policies panel appears on the right. It displays a list
of recommended alerts to set up for your project.
Enable
High search error ratio
.
Optionally, adjust the threshold to suit your environment.
The default threshold ratio is 0.03.
Choose a notification channel through which you'll be notified if the alert
is triggered, such as an email address or mobile device.
To set up a new notification channel, select
Notification Channels >
refresh
Manage Notification Channels
.
See
the Cloud Monitoring documentation
for more about creating and editing channels.
Click the
Submit
button to create your alert.
You can also create a custom alert by using Cloud Monitoring. For more
information, see
the Cloud Monitoring documentation
.
Set up an alert for user event recording reduction
If you see a drop in user event recording that lasts for a prolonged period of
time, there could be issues with your user event recording code. This alert
is triggered if you don't record any user events for 10 minutes.
To set up a user event recording reduction alert from the Search for commerce console:
Go to the
Monitoring
page in the Search for commerce console.
Go to the Monitoring page
Click
add
Recommended Alerts
.
The Recommended Alert Policies panel appears on the right. It displays a list
of recommended alerts to set up for your project.
Enable
User events record reduction
.
Choose a notification channel through which you'll be notified if the alert
is triggered, such as an email address or mobile device.
To set up a new notification channel, select
Notification Channels >
refresh
Manage Notification Channels
.
See
the Cloud Monitoring documentation
for more about creating and editing channels.
Click the
Submit
button to create your alert.
If you are using a method other than
WriteUserEvent
, such as
ImportUserEvents
, you can also create a custom alert by using Cloud Monitoring. For more
information, see the
Cloud Monitoring documentation
.
Set up an alert for unjoined user events
This alert is triggered if the ratio of user events that aren't associated with
valid products stays above the given threshold for more than one or twelve
hours. You can choose the time window and adjust the threshold.
To set up a user event recording reduction alert from the Search for commerce console:
Go to the
Monitoring
page in the Search for commerce console.
Go to the Monitoring page
Click
add
Recommended Alerts
.
The Recommended Alert Policies panel appears on the right. It displays a list
of recommended alerts to set up for your project.
Enable
Ratio of unjoined user events ratio is above the threshold for last hour
or
Ratio of unjoined user events increases above threshold for last 12 hours
.
Optionally, adjust the threshold to suit your environment.
The default unjoined events ratio is 0.1. This means that if more than 10% of total events ingested are not joined with a valid product within the specified time window, an alert is triggered.
Choose a notification channel through which you'll be notified if the alert
is triggered, such as an email address or mobile device.
To set up a new notification channel, select
Notification Channels >
refresh
Manage Notification Channels
.
See
the Cloud Monitoring documentation
for more about creating and editing channels.
Click the
Submit
button to create your alert.
What's next
Troubleshoot your errors using Error Reporting
.
Learn more about
Google Cloud Observability alerting
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/movie-rec-tutorial.txt
Create personalized movie recommendations  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Create personalized movie recommendations
In this tutorial, we will use the
Movielens
dataset to demonstrate
how to upload your product catalog and user events into Vertex AI Search for commerce
and train a personalized product recommendation model. The Movielens dataset
contains a catalog of movies (products) and user movie ratings (user events).
We will treat each positive movie rating (rating >= 4) as a product page view
event. We will train a recommendation model of type Others You May Like that
will make movie recommendations based on any user or a seed movie in our
dataset.
Estimated time:
Initial steps to start training the model: ~1.5 hours.
Waiting for the model to train: ~2 days.
Evaluating the model predictions and cleaning up: ~30 minutes.
Objectives
Learn how to import products and user events data from
BigQuery into Vertex AI Search for commerce.
Train and evaluate recommendation models.
Costs
This tutorial uses billable components of Google Cloud, including:
Cloud Storage
BigQuery
Vertex AI Search for commerce
For more information about Cloud Storage costs, see the
Cloud Storage pricing
page.
For more information about BigQuery costs, see the
BigQuery pricing
page.
For more information about Vertex AI Search for commerce costs, see the
Vertex AI Search for commerce pricing
page.
Before you begin
Sign in to your Google Cloud account. If you're new to
        Google Cloud,
create an account
to evaluate how our products perform in
        real-world scenarios. New customers also get $300 in free credits to
        run, test, and deploy workloads.
In the Google Cloud console, on the project selector page,
        select or create a Google Cloud project.
Roles required to select or create a project
Select a project
: Selecting a project doesn't require a specific
      IAM role—you can select any project that you've been
      granted a role on.
Create a project
: To create a project, you need the Project Creator
      (
roles/resourcemanager.projectCreator
), which contains the
resourcemanager.projects.create
permission.
Learn how to grant
      roles
.
Note
: If you don't plan to keep the
    resources that you create in this procedure, create a project instead of
    selecting an existing project. After you finish these steps, you can
    delete the project, removing all resources associated with the project.
Go to project selector
Verify that billing is enabled for your Google Cloud project
.
In the Google Cloud console, on the project selector page,
        select or create a Google Cloud project.
Roles required to select or create a project
Select a project
: Selecting a project doesn't require a specific
      IAM role—you can select any project that you've been
      granted a role on.
Create a project
: To create a project, you need the Project Creator
      (
roles/resourcemanager.projectCreator
), which contains the
resourcemanager.projects.create
permission.
Learn how to grant
      roles
.
Note
: If you don't plan to keep the
    resources that you create in this procedure, create a project instead of
    selecting an existing project. After you finish these steps, you can
    delete the project, removing all resources associated with the project.
Go to project selector
Verify that billing is enabled for your Google Cloud project
.
Prepare the dataset
Open
Google Cloud console
,
select your Google Cloud project. Take note of the project ID in the
Project info
card on the dashboard page. You will need the project ID for the following steps. Next, click the
Activate Cloud Shell
button
at the top of the Console.
A Cloud Shell session opens inside a new frame at the bottom of the Google Cloud console
and displays a command-line prompt.
Import the dataset
Using the Cloud Shell, download and unpack the source dataset:
wget
https://files.grouplens.org/datasets/movielens/ml-latest.zip
unzip
ml-latest.zip
Create a Cloud Storage bucket and upload the data into it:
gcloud
storage
buckets
create
gs://
PROJECT_ID
-movielens-data
gcloud
storage
cp
ml-latest/movies.csv
ml-latest/ratings.csv
\
gs://
PROJECT_ID
-movielens-data
Create a BigQuery dataset:
bq
mk
movielens
Load
movies.csv
into a new movies BigQuery table:
bq
load
--skip_leading_rows
=
1
movielens.movies
\
gs://
PROJECT_ID
-movielens-data/movies.csv
\
movieId:integer,title,genres
Load
ratings.csv
into a new ratings BigQuery table:
bq
load
--skip_leading_rows
=
1
movielens.ratings
\
gs://
PROJECT_ID
-movielens-data/ratings.csv
\
userId:integer,movieId:integer,rating:float,time:timestamp
Create BigQuery views
Create a view that converts the movies table into the
retail product catalog schema
:
bq
mk
--project_id
=
PROJECT_ID
\
--use_legacy_sql
=
false
\
--view
'
SELECT
CAST(movieId AS string) AS id,
SUBSTR(title, 0, 128) AS title,
SPLIT(genres, "|") AS categories
FROM `
PROJECT_ID
.movielens.movies`'
\
movielens.products
Now the new view has the schema that Vertex AI Search for commerce expects.
Then, from the left sidebar, choose
BIG DATA -> BigQuery
. Then, from the
explorer bar on the left, expand your project name and select
movielens ->
products
to open the query page for this view.
Now convert movie ratings into
user events
.
We will:
Ignore negative movie ratings (<4)
Treat every positive rating as a product page view event
(
detail-page-view
)
Rescale the Movielens timeline into the last 90 days. We do this for two
reasons:
Vertex AI Search for commerce requires that user events are no older than 2015. Movielens
ratings go back to 1995.
Vertex AI Search for commerce uses the last 90 days of user events when serving prediction
requests for a user. Every user will appear to have recent events when
we make predictions for any user later on.
Create a BigQuery view. The following command uses a SQL query
that meets conversion requirements previously listed.
bq
mk
--project_id
=
PROJECT_ID
\
--use_legacy_sql
=
false
\
--view
'
WITH t AS (
SELECT
MIN(UNIX_SECONDS(time)) AS old_start,
MAX(UNIX_SECONDS(time)) AS old_end,
UNIX_SECONDS(TIMESTAMP_SUB(
CURRENT_TIMESTAMP(), INTERVAL 90 DAY)) AS new_start,
UNIX_SECONDS(CURRENT_TIMESTAMP()) AS new_end
FROM `
PROJECT_ID
.movielens.ratings`)
SELECT
CAST(userId AS STRING) AS visitorId,
"detail-page-view" AS eventType,
FORMAT_TIMESTAMP(
"%Y-%m-%dT%X%Ez",
TIMESTAMP_SECONDS(CAST(
(t.new_start + (UNIX_SECONDS(time) - t.old_start) *
(t.new_end - t.new_start) / (t.old_end - t.old_start))
AS int64))) AS eventTime,
[STRUCT(STRUCT(movieId AS id) AS product)] AS productDetails,
FROM `
PROJECT_ID
.movielens.ratings`, t
WHERE rating >= 4'
\
movielens.user_events
Import product catalog and user events
We are now ready to import the product catalog and the user event data into
Vertex AI Search for commerce.
Enable the
Vertex AI Search for commerce
API for your Google Cloud project.
ENABLE THE API
Click
Get started
.
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
.
Import product catalog
Fill in the form to import products from the BigQuery view you
created previously:
Select import type:
Product Catalog
.
Select the default branch name.
Select source of data:
BigQuery
.
Select schema of data:
Retail Product Schema
.
Enter the name of the products BigQuery view you created
previously (
PROJECT_ID
.movielens.products
).
Note:
The BigQuery view name is obtained from the view ID by
replacing the colon (
:
) with a period (
.
). You can find the view ID
on the
BIG DATA
->
BigQuery
page by selecting your view from the
left menu and going to the
DETAILS
tab.
Click
Import
.
Note:
It may take a few minutes for Vertex AI Search for commerce API to fully
activate and you may get an error in this step if the activation has
not finished. If that happens, try again a few minutes later.
Wait until all products have been imported, which should take 5–10 minutes.
You can check the import activity for the import operation status. When the
import is complete, the import operation status changes to
Succeeded
.
Import user events
Import the user_events BigQuery view:
Select import type:
User Events
.
Select source of data:
BigQuery
.
Select schema of data:
Retail User Events Schema
.
Enter the name of the
user_events
BigQuery view you created previously.
Click
Import
.
Wait until at least a million events have been imported before proceeding to
the next step, in order to meet the data requirements for training a new
model.
You can check the import activity for the operation status. The process takes
about an hour to complete.
Train and evaluate recommendation models
Follow these instructions on training and evaluating recommendation models.
Create a recommendation model
Go to the
Models
page in the Search for commerce console.
Go to the Models page
Click
Create model
:
Give the model a name.
Select
Others you may like
as the model type.
Choose
Click-through rate (CTR)
as the business objective.
Click
Create
.
Your new model starts training.
Create a serving config
Go to the
Serving Configs
page in the Search for commerce console.
Go to the Serving configs page
Click
Create serving config
:
Select
Recommendation
.
Give the serving config a name.
Select the model you created.
Click
Create
.
Wait for the model to be "Ready to query"
It takes about two days for the model to train and become ready to query.
To view the status, click the created serving config on the
Serving configs page
.
The
Model ready to query
field indicates
Yes
when the process is complete.
Preview recommendations
Once the model is ready to query:
Go to the
Serving Configs
page in the Search for commerce console.
Go to the Serving configs page
Click the serving config name to go to its detail page.
Click the *
Evaluate
tab.
Enter a seed movie ID, such as
4993
for "The Lord of the Rings: The
Fellowship of the Ring (2001)".
Click
Prediction preview
to see the list of recommended items on the right of the page.
Clean up
To avoid incurring charges to your Google Cloud account for the resources used in this
        tutorial, either delete the project that contains the resources, or keep the project and
        delete the individual resources.
Delete the project
Caution
: Deleting a project has the following effects:
Everything in the project is deleted.
If you used an existing project for
      the tasks in this document, when you delete it, you also delete any other work you've
      done in the project.
Custom project IDs are lost.
When you created this project, you might have created a custom project ID that you want to use in
      the future. To preserve the URLs that use the project ID, such as an
appspot.com
URL, delete selected resources inside the project instead of deleting the whole project.
If you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects
    can help you avoid exceeding project quota limits.
In the Google Cloud console, go to the
Manage resources
page.
Go to Manage resources
In the project list, select the project that you
    want to delete, and then click
Delete
.
In the dialog, type the project ID, and then click
Shut down
to delete the project.
Delete individual resources
Go to the
Serving configs
page and delete the serving config you
created.
Go to the
Models
page and delete the model.
Delete the BigQuery dataset in Cloud Shell:
bq
rm
--recursive
--dataset
movielens
Delete the Cloud Storage bucket and its contents:
gcloud
storage
rm
gs://
PROJECT_ID
-movielens-data
--recursive
What's next
Implementing Vertex AI Search for commerce
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/overview.txt
Implement Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Implement Vertex AI Search for commerce
You can implement Vertex AI Search for commerce for your ecommerce application.
When you use recommendations or search, you
ingest user event and catalog data and to
serve predictions or search results on your site.
The same data is used for both
recommendations and search, so if you use both,
you don't need to ingest the same data twice.
Tip:
See the
User event requirements and best practices
for user event
data that recommendations and search use.
If you use recommendations models,
User event data requirements
lists additional requirements
depending on your model type and optimization objective. These requirements help
Vertex AI Search for commerce generate quality results.
The average integration time is in the order of
weeks. Note that for search, the actual duration depends
heavily on the quality and quantity of data to ingest.
Warning:
Never cache personalized results from an end user, and never return personalized
results to a different end user.
Commerce integration overview
Migrate in four phases
Migrating your search engine is a structured, four-phased approach that helps to ensure that every aspect of the migration is addressed to minimize risks and maximize your investment.
Manage the expectations of your merchandising teams and sellers by doing the following:
Keep merchant teams informed
: Proactively communicate the changes that are coming and why the company is moving to an AI-first approach.
Educate teams on the new paradigm
: Explain that the system is based on user behavior and intent detection, which leads to a more dynamic, personalized, and ultimately more profitable ranking. The search results will look different.
Set clear guidelines for business rules
: Emphasize that business rules can be applied only for specific, data-backed business reasons, such as contractual obligations or a clear revenue-driving strategy. The goal is to let the AI do its job.
A/B test new rules
: If a new rule is proposed post-migration, the most data driven way to validate its effectiveness is to run another A/B test, one group with the rule, one group without the rule. Let the data decide whether the rule is promoted to production.
By diligently following this four-phased approach, a typical migration to A/B testing can be achieved in about two to three months, depending on the current search system complexity and speed of execution. This methodology has been designed and proven across numerous customer adoptions.
Note:
Attempting to sprint through or skip steps can cause rework and delays.
Terms of Service
Product usage is under Google Cloud's
Terms and Conditions
or relevant
offline variant. The
Google Cloud Privacy Notice
explains how we collect and process your personal information relating to the
use of Google Cloud and other Google Cloud services.
For quality assurance, a small sample set of search queries and search results
from the logs, which include customer data, are sent for
human rating to third-party vendors
disclosed as Third-Party
Subprocessors
for search.
Additional tests using search queries and search results from Google Search logs
that are publicly collected datasets are sent for human rating to different
third-party vendors for quality assurance. The Google Search logs are
not categorized as customer data.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/performance.txt
Measure performance  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Measure performance
The Search for commerce console provides metrics to help you
determine how incorporating Vertex AI Search for commerce is affecting your
business.
View metrics
You can view summary metrics for your project on the
Analytics
page. This page displays
site-wide metrics about revenue and orders. See
Summary
metrics
for metrics definitions.
For metrics specific to your serving configs, go to the
Serving Configs
page.
Click a serving config name and select the
Analytics
tab to see its
metrics. See
Configuration-specific metrics
for metrics
definitions.
Metrics definitions
This table provides definitions of the summary metrics that
Vertex AI Search for commerce displays on the
Analytics
page.
Metric
Description
Details
Total revenue
The total revenue from all recorded purchase events.
This value includes shipping and tax.
Results-engaged revenue
The revenue for purchase events that include at least one product that was
      selected from a recommendation or search result.
This value includes shipping and tax and any discount applied.
Average order value (AOV)
The average value of orders from all purchase events.
Total revenue divided by the number of orders.
Results-engaged AOV
The average value of orders that include at least one item selected
      from a recommendation or search result.
Results-engaged revenue divided by the number of orders with at least
      one item that was selected from a recommendation or search result.
Configuration-specific metrics
You can see metrics for a specific serving config on the
Serving Configs
page.
For metric graphs, click the configuration name and select the
Analytics
tab.
This table provides definitions for configuration-specific metrics.
Metric
Description
Details
Click-through rate (CTR)
The number of product detail views from a serving config divided by
      the total number of
predict
or
search
queries for this configuration.
For example, if a recommendations serving config
      points to a "Frequently Bought Together" model, then the CTR would be the number of product
      detail pages viewed from the shopping cart recommendation panel divided by
      the number of
predict
queries on the shopping cart page.
Add-to-cart events
The number of add-to-cart events from a serving config
      divided by the total number of predict or search queries for that
      configuration.
Purchase events
The total purchase events from the recommendations or search results from
      this serving config.
To track clicks from a serving config, Vertex AI Search for commerce
aligns the recommendations in
predict
responses and search results in
search
responses with ingested user events. If a clicked item appears in the
predict
or
search
responses for the same visitor ID within a one hour time window, the
click and purchase is treated as a result of the recommendation or search result.
When you configure your recommendations or search requests for the first time, you
should confirm that:
Visitor IDs in the request are the same as the visitor IDs you used in event
ingestions.
The timestamp in the response roughly matches the timestamp for that event.
When Vertex AI Search for commerce metrics are compared to the ideal expected result,
or ground truth, the values might be lower, but the trends align.
Unlike for recommendations, the process of attributing click to search requests is not fully automatic. So for metrics to work for Vertex AI Search for commerce, an
attribution token
is required. However, attribution tokens are not needed for recommendations user events.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/predict.txt
Get recommendations  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Get recommendations
This page describes how to request product recommendations for a specific user
and user event.
After you have uploaded your products and recorded user events, you can request
product recommendations for specific users based on the recorded user
events for that user and their current activity.
It can take up to 48 hours for new products and user events to be
reflected in the recommendation model.
Vertex AI Search for commerce returns a list of ranked product identifiers. You are
responsible for rendering the results on your website with images and text.
Never cache personalized results from an end user, and never return personalized
results to a different end user.
Before You Begin
You must create a Google Cloud
project and set up authentication using the steps in
Before you begin
.
In addition, before you can request predictions from
recommendations, you need a
trained and tuned recommendation (model)
and one or more active
serving configs
.
Evaluate recommendations
Before you update your website code to request recommendations, you can use
preview prediction results to confirm that your model and serving config are
working as you expect.
For more information about serving configs, see
About serving configs
.
You can preview serving config results either from the
Evaluate
page, or by
going to a serving config's
Details
page in the console and clicking its
Evaluate
tab. The following steps show you how to preview from the
Evaluate
page.
To preview recommendations returned by your serving config:
Go to the
Evaluate
page in the Search for commerce console.
Go to the Evaluate page
Click the
Recommendations
tab, if it isn't already selected.
Select the serving config you want to preview.
Optional: Enter a visitor ID to preview recommendations for that user.
If the
Associated items
section is shown, click
Add item
and enter a
product ID to get associated recommendations for that item. You can add
multiple associated items.
Adding items is available only if the selected serving config's model type
requires products as input for recommendations. Recommended for You models don't
require associated items to be entered.
Click
Prediction preview
to see the prediction results.
To see the
Details
page for the serving config you're previewing, click
View serving config
under the
Select serving config
field.
Get a recommendation
The Recommendations API has limits on the number of items returned. However, there are workarounds to increase the number of items returned.
Increase limits
The limit for Vertex AI Search for commerce results is 120.
The Recommendations API supports reranking up to 2,000 items.
Although latency increases, it's possible to increase page size up to 500 or 1,000.
Workarounds
For category pages, you can personalize and rerank them using personal recommendations. To work around the result limit of 120, make multiple simultaneous calls for the first given number of pages, then stitch the results together to look like one large page.
To manually restrict the set of recommendations returned to end users, you can add
filter criteria
in
PredictRequest.params
queries.
Mark your selected attributes as filterable using the API, then refer to them directly in their prediction requests.
For prediction cost details, see
Pricing
.
curl
To get a recommendation, make a
POST
request to the
predict
REST method and provide the appropriate request
body:
The service account you use needs to have role "Retail Viewer" or above.
Replace
SERVING_CONFIG_ID
with the serving config where
you will use the predictions.
Learn more
.
If you imported Google Analytics 360 user events
using BigQuery
,
set
visitorId
to the Google Analytics client ID. See the
Google Analytics documentation
for how to get the
client ID.
If you are running an A/B experiment, set
experimentIds
to the ID for this
experiment group.
Learn more
.
Provide a user event object for the user action that initiated the
recommendation request.
Note that this user event is not recorded; it is only used to provide
context for this recommendation request. You should also record the user
event the same way you record other user events.
Optionally, provide a filter to narrow the potential products returned.
Learn more
.
Note:
If your recommendation is not yet active, or you want to test your method
call, you can call this method with the
validateOnly
flag set to
true
. This
call returns a placeholder result, and does not incur charges. You can see
whether your recommendation is active on the
Dashboard
tab.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"filter": "
FILTER_STRING
",
"validateOnly": false,
"userEvent": {
"eventType": "detail-page-view",
"visitorId": "
VISITOR_ID
",
"userInfo": {
"userId": "
USER_ID
",
"ipAddress": "
IP_ADDRESS
",
"userAgent": "
USER_AGENT
"
},
"experimentIds": "
EXPERIMENT_GROUP
",
"productDetails": [{
"product": {
"id": "
PRODUCT_ID
"
}
}]
}
}'
\
https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/servingConfigs/
SERVING_CONFIG_ID
:predict
You should see results similar to the following:
{
"results"
:
[{
"id"
:
"sample-id-1"
},
{
"id"
:
"sample-id-2"
}],
"attribution_token"
:
"sample-atr-token"
}
Java
public
static
PredictResponse
predictWithNextPageToken
(
UserEvent
userEvent
,
int
pageSize
,
String
nextPageToken
)
throws
IOException
,
InterruptedException
{
PredictionServiceClient
predictionClient
=
getPredictionServiceClient
();
PredictRequest
request
=
PredictRequest
.
newBuilder
()
.
setPlacement
(
HOME_PAGE_PLACEMENT_NAME
)
.
setUserEvent
(
userEvent
)
.
setPageSize
(
pageSize
)
.
setPageToken
(
nextPageToken
)
.
setValidateOnly
(
true
)
.
build
();
PredictResponse
response
=
predictionClient
.
predict
(
request
);
predictionClient
.
shutdownNow
();
predictionClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
response
;
}
Price reranking
Price reranking causes recommended products with a similar recommendation
probability to be ordered by price, with the highest-priced items first.
Relevance is still also used to order items, so enabling price reranking is not
the same as sorting by price.
Price reranking can be set on the serving config level, or per prediction
request.
When you choose a price reranking setting when
creating a serving config
in the Search for commerce
console, that setting applies to all recommendations served by that
configuration, without you having to take further action.
If you need to control the price reranking of a particular recommendation, you
can do so using the
PredictRequest.params
field. This overrides any
configuration-level reranking setting that would otherwise apply to this
recommendation.
Recommendation diversity
Recommendation diversification affects whether results returned from a single prediction
request are from different categories of your product catalog.
Recommendation diversification can be set on the serving config level, or per prediction
request.
When you choose a recommendation diversification setting when
creating a serving config
in the Search for commerce
console, that setting applies by default to all predictions served by that
configuration, without you having to take further action.
If you need to control the diversity of a particular recommendation, you can do
so using the
PredictRequest.params
field. This overrides any
configuration-level diversification setting that would otherwise apply to this
recommendation. See for accepted values.
Use recommendation filters
You can filter the recommendations returned by recommendations
by using the
filter
field in the
predict
method.
For information, see
Filter recommendations
.
Prediction calls with Page-Level Optimization models
Providing recommendations using
Page-Level Optimization
requires an extra prediction call
step.
Make an initial prediction call using a serving config containing the Page-Level Optimization
model. The prediction response returns a sorted list of serving
config IDs representing the model to use for each panel.
Then make a prediction call for each panel using the serving config ID that the
Page-Level Optimization model recommended for it. The prediction response contains the model
name (such as Recommended for You) and list of recommended items to display in that panel.
Price reranking, recommendation diversity, and recommendation filters are not
available for serving configs using the Page-Level Optimization model.
Monitor and troubleshoot recommendations
After setting up your website to get recommendations, we recommend that you set
up alerts. See
Set up an alert for prediction errors
.
To troubleshoot errors, see
Monitor and troubleshoot
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/quotas.txt
Quotas and limits  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All resources
Pricing
Quotas and limits
FAQ
Overview
Conversational features
Search for commerce console
Release notes
Data use terms & conditions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Resources
Send feedback
Quotas and limits
This page provides information about quotas and limits for
Vertex AI Search for commerce.
Important:
These quotas only apply to recommendations within
Vertex AI Search for commerce.
Default quotas
By default, your project has the following quotas for Vertex AI Search for commerce.
To increase or otherwise edit these quotas, see
Edit your quotas
.
Quota
Value
User event writes per minute
60,000
User event imports per minute
100
User event writes per user per minute
240
User event reads per minute
300
Product writes per minute
12,000
Product imports per minute
100
Product reads per minute
300
Predictions per minute
60,000
Predictions per minute for a specific user
60,000
Searches per minute
300
Completion read per minute
1200
Total user events
40,000,000,000
Total products (search not enabled)
40,000,000
Total products (search enabled)
4,000,000
Total tags
(sum of per-product tag counts, not unique tags)
100,000,000
Pending Cloud Storage import long running operations
300
Pending BigQuery import long running operations
100
Pending Merchant Center import long running operations
10
Concurrent active models
10
Total models (active and paused)
20
Total placements
100
Total Controls
100
Check your quotas
To check the current quotas for Vertex AI Search for commerce resources in your
project, go to the
Quotas
page in the Google Cloud console and select
Vertex AI Search for Retail API
in the
Services
dropdown list.
You can see recent quota usage by going to the
API Dashboard
, selecting
Vertex AI Search for Retail API, and opening the
Quotas
tab.
Edit your quotas
As your use of Google Cloud expands over time, you might want to increase
your quotas accordingly. Or you might need to limit certain quotas. If you
expect a notable upcoming increase in usage, make your request to increase
your quotas a few days in advance to ensure that your quotas are adequately
sized.
Note:
To request additional quotas, your user account must have the
serviceusage.quotas.update
permission. This permission is included by default
for the following
predefined roles
: Owner,
Editor, and Quota Administrator.
In the
Quotas
page,
select
Vertex AI Search for Retail API
in the
Services
dropdown list.
Select the quotas you want to change.
Click
EDIT QUOTAS
.
Fill out your name, email, and phone number and click
Next
.
Fill in your quota request and click
Submit request
.
You will receive a response from the Vertex AI Search for commerce team within
48 hours of your request.
Limits
The following limits are enforced:
You can start up to five model operations per minute. Limited model operations
include creation, deletion, pause, and resume.
Your site can have up to 250,000 user event writes per visitor ID or user ID
per week.
Your site can have up to 10,000 product writes per product ID per week and one
product write per product ID per second. Too frequent updates on the same
product are unexpected, and the additional updates might be rejected with
a
RESOURCE_EXHAUSTED
error.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/record-events.txt
Record real-time user events  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Record real-time user events
This page describes how you record real-time user events. Vertex AI Search for commerce
uses real-time user events to generate recommendations and search results.
Recording as many types of user events as possible with valid product
information increases the quality of your results.
The recording procedures on this page apply to both
recommendations and search. After you record
data, both services are able to use those events, so you don't need to upload
the same data twice if you use both services.
Before you begin
Before recording user events, you should have:
A Google Cloud project created, with authentication set up.
A valid API key (for JavaScript Pixel or Tag Manager), or a valid
service account with the Retail Editor Role assigned if using the API to write
directly.
Required components
Attribution token
: Enables
performance metrics
for recorded user events to capture first-time user interactions with a product based on previously provided recommendations or search result. Read more about
including attribution tokens
.
Visitor IDs
: Required when recording user events. For information,
see
About user information
.
General tips for recording user events
Follow
best practices
such as rejoining events, keeping your catalog up to date, and providing as much information as possible.
You can find sample JSON for
user event type examples and schema
in the
About user events
page.
Caution:
Use a secure form of a unique identifier to keep users anonymous to Vertex AI Search for commerce and
protect your users' privacy. You are responsible for redacting PII (personally identifiable
information), such as email or home addresses, from your data.
Best practices for recording user events
Vertex AI Search for commerce requires high-quality data to generate high-quality
results. If your data is incomplete or incorrect, the quality of your
results suffers.
When you record user events, ensure that you implement the following best
practices:
If you record user events before or while importing your catalog,
rejoin any events
recorded before the catalog import
completed.
You can
import the catalog
before, after, or at the same time you record user events. Doing these tasks
in parallel can save time if the catalog is large and there are many user
events. Once the catalog import is complete, you must use the API to
rejoin events that were uploaded before the import completed.
Vertex AI Search for commerce attempts to join recorded user events with
metadata from the product catalog when the user event is created. Only
successfully joined events are used for training, so make sure to rejoin any
events recorded before the catalog was completely imported. If an event
refers to an item that doesn't exist in the catalog, it is discarded or not
associated with the correct products. Similarly, if you import user events
from the past, the catalog must include any products they reference; you can
mark older products as
OUT_OF_STOCK
rather than removing them from the
catalog.
Keep your catalog up to date
.
When you record user events, the product included in the user event
is connected with your current catalog. If you record an event for a
product that is not in the current catalog, it cannot be used for training
your models. This is called an "unjoined" event. If you recorded events before
your catalog was completely imported, you must
rejoin the
events
that were recorded during the import. Having a few
unjoined events is expected. However, if the percentage of unjoined events
reaches 5% or more of your total user events, make sure your catalog is up to
date, rejoin events that were recorded before the catalog was fully updated,
and investigate why the unjoined events are being created.
You can see your unjoined events by using event filtering.
Learn more
.
Provide as much information with your user events as possible.
Each user event type has different information that is required and
accepted. For more information, see
About user events
.
Set up Cloud Monitoring alerts
so that you will know if your
user event recording processes experience any outages.
For a bulk user event import, limit the size of the data you are importing.
A bulk user event import can take up to 24 hours to complete.
The size of each file must be 
2 GB
 or smaller. You
can include at most 
100
 files in a single import request.
One approach is import only the user events for one day at a time.
After a bulk import, review your
error reporting
to ensure
that your data was imported correctly.
When importing user event data, include an accurate timestamp for each user
event and avoid importing sequential user events with identical timestamps.
Provide the timestamp in the
eventTime
field in the
format specified by
RFC 3339
.
If you have imported user events that are incorrect, talk to your
Vertex AI Search for commerce contact about how to correct the problem.
When possible, keep your user event data continuous.
Gaps in user event data can reduce model quality.
Use a secure form of a unique identifier to keep users anonymous to Vertex AI Search for commerce and
protect your users' privacy. You are responsible for redacting PII (personally identifiable
information), such as email or home addresses, from your data.
Write user events tutorial
This tutorial shows how to record user events using the
userEvents.write
method.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Ways to stream user events
You can record a user event in multiple ways:
Use
JavaScript pixel
.
Google Analytics 4 (GA4)
with Tag Manager is recommended.
Send events directly to the API
from your backend server through the
user.Events.write
method.
Tag Manager
, on its own or in conjunction with Google Analytics 4.
With
server-side tagging
, record events by deploying a single server-side container with
many downstream clients.
Note:
Tag Manager is required for Google Analytics 4 to work on the Vertex AI Search for commerce frontend.
Record user events with a JavaScript pixel
The following example records a
detail-page-view
UserEvent
using a JavaScript
pixel.
<
script
type
=
"text/javascript"
>
var
user_event
=
{
"eventType"
:
"detail-page-view"
,
"visitorId"
:
"
visitor-id
"
,
"userInfo"
:
{
"userId"
:
"
user-id
"
},
"experimentIds"
:
"
experiment-id
"
,
"productDetails"
:
[
{
"product"
:
{
"id"
:
"123"
}
}
]
};
var
_gre
=
_gre
||
[];
// Credentials for project.
_gre
.
push
([
'apiKey'
,
'
api-key
'
]);
_gre
.
push
([
'logEvent'
,
user_event
]);
_gre
.
push
([
'projectId'
,
'
project-id
'
]);
_gre
.
push
([
'locationId'
,
'global'
]);
_gre
.
push
([
'catalogId'
,
'default_catalog'
]);
(
function
()
{
var
gre
=
document
.
createElement
(
'script'
);
gre
.
type
=
'text/javascript'
;
gre
.
async
=
true
;
gre
.
src
=
'https://www.gstatic.com/retail/v2_event.js'
;
var
s
=
document
.
getElementsByTagName
(
'script'
)[
0
];
s
.
parentNode
.
insertBefore
(
gre
,
s
);
})();
<
/script>
If you
imported user events with Google Analytics 360
,
set
visitorID
to the Google Analytics client ID. Note that
the Google Analytics client ID is only part of the full _ga cookie
name (for example, client ID
123456789.123456789
is part of _ga cookie
GA1.3.123456789.123456789
).
The following is an abbreviated example that shows the format for setting the
client ID in a user event. Replace "G-XXXXXX" with your
Google Analytics tracking ID
.
<script type="text/javascript">
var tracker = ga.getByName('
G-XXXXXX
');
var user_event = {
      "visitorId": tracker.get('clientId')
};
</script>
Record user events with the
userEvents.write
method
You can use the
userEvents.write
method to send user events directly to the API from your backend server.
To record user events, send a
POST
request to the
userEvents.write
method and provide the appropriate request body.
curl
export
GOOGLE_APPLICATION_CREDENTIALS
=
/tmp/my-key.json
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
"{
'eventType': 'detail-page-view',
'visitorId': 'visitor0',
'eventTime': '2020-01-01T03:33:33.000001Z',
'experimentIds': ['321'],
'attributionToken': 'ABC',
'attributes': {
'example_text_attribute': {
'text': ['text_1', 'text_2']
},
'example_number_attribute': {
'numbers': [3.14, 42, 1.2345]
}
},
'productDetails': [{
'product': {
'id': 'abc'
}
}],
'userInfo': {
'userId': 'abc',
'ipAddress': '8.8.8.8',
'userAgent': 'Mozilla/5.0',
'directUserRequest': true
},
'uri': 'http://example',
'referrerUri': 'http://example',
'pageViewId': 'currentPageUri'
}"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:write"
Java
public
static
UserEvent
writeUserEvents
(
UserEvent
eventToWrite
)
throws
IOException
,
InterruptedException
{
UserEventServiceClient
userEventsClient
=
getUserEventServiceClient
();
WriteUserEventRequest
request
=
WriteUserEventRequest
.
newBuilder
()
.
setParent
(
DEFAULT_CATALOG_NAME
)
.
setUserEvent
(
eventToWrite
)
.
build
();
UserEvent
writtenUserEvent
=
userEventsClient
.
writeUserEvent
(
request
);
userEventsClient
.
shutdownNow
();
userEventsClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
writtenUserEvent
;
}
Record user events with Google Analytics 4
You can record Google Analytics 4 user event data to
Vertex AI Search for commerce.
Check your data source
Make sure that the user event data that you want to import is correctly
formatted.
For a table of Google Analytics 4 fields that Vertex AI Search for commerce
uses and which Vertex AI Search for commerce fields they map to,
see
Google Analytics 4 user event fields
.
For all Google Analytics event parameters, see the
Google Analytics Events reference documentation
.
Check that:
If you're importing purchase events, which some Vertex AI Search for commerce
models require, your event reporting includes currency codes.
See the
purchase
event parameters in the
Google Analytics documentation.
If you plan to import
search
events, your event reporting includes search
queries.
Importing
search
events is supported, but
search
events don't map
from Google Analytics 4 in the same way that other event types do
because Google Analytics 4 doesn't natively support the
Vertex AI Search for commerce
search
event type. During import,
search
events
are constructed from Google Analytics 4 by combining information
from the
view_item_list
and the
search_term
event parameters.
See the
search
event parameters in the
Google Analytics documentation.
Record your Google Analytics 4 events
Record a user event by including URL-encoded raw JSON data for the event in your
call to the
userEvents.collect
method.
For the
prebuilt_rule
parameter, use the value
ga4_bq
.
For readability, the following example of using the
userEvents.collect
call
first sets
GA4_EVENT
as a variable containing the raw JSON data for an example
event. The
userEvents.collect
call in the example then URL-encodes the event
data using the
GA4_EVENT
variable.
For easier URL-encoding later, you can set the
GA4_EVENT
as a variable
containing event data. This example shows an
add-to-cart
event.
GA4_EVENT='{
  "event_timestamp": 1622994083878241,
  "event_name": "add_to_cart",
  "user_pseudo_id": "352499268.1622993559",
  "items": [
    {
      "item_id": "11",
      "price": 29.99,
      "quantity": 3
    }
  ],
  "event_params": [
    {
      "key": "currency",
      "value": {
        "string_value": "CAD"
      }
    }
  ],
  "user_id": "Alice"
}'
Make a
userEvents.collect
call that includes the URL-encoded raw JSON data
of a user event:
curl
\
-G
\
--data-urlencode
"raw_json=
${
GA4_EVENT
}
"
\
-i
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/userEvents:collect?key=EXAMPLEKEY1&prebuilt_rule=ga4_bq'"
Record user events with Google Tag Manager
Tag Manager provides a way to manage and test multiple tags without many
server-side code changes to your site.
Some decisions you make during setup depend on whether you are using
Google Analytics and Google Analytics Ecommerce. Google Analytics Ecommerce can
be implemented using Google Analytics 4 or Enhanced Ecommerce.
The Cloud Retail tag supports both.
Neither Google Analytics nor Google Analytics Ecommerce is required; if you
don't use them, you can either configure
Variable - Ecommerce
(for using
the GA4 ecommerce schema) or
Variable - Cloud Retail
(for using the Vertex AI Search for commerce schema) when creating the Cloud Retail tag, and manually populate your
site's data layer code after creating the tag.
Google Analytics Ecommerce is an additional configuration for
Google Analytics that passes product titles, IDs, prices, transaction
details, and other structured ecommerce data to Google Analytics.
Vertex AI Search for commerce can automatically use the Google Analytics Ecommerce
data layer, so if you have that set up already, configuration can be easier. If
you don't have Google Analytics Ecommerce configured for
Google Analytics but want to use it, see more details and setup
instructions in the
GA4 developer guide
.
Use this one-time procedure to set up a Cloud Retail tag in Tag Manager
for recording user events.
Create a visitor ID variable
The value
visitorId
is for tracking users.
visitorId
is typically a session ID and is required for all events. Set up a
variable that sets session IDs as
visitorId
.
If you're using Google Analytics, you can use the
Google Analytics visitor ID. To configure this, use the following
procedure to override the visitor ID value for the Cloud Retail tag. This maps
the first-party cookie "_ga" to a Tag Manager variable called
"GA visitorId". You can do the same for any session ID cookie; it doesn't have
to be from Google Analytics.
This procedure assumes you are using Google Analytics. If you aren't,
you can use another cookie or variable, or get the visitor ID from the
cloud_retail
data layer.
Note:
Getting the
visitorID
field correct is important. It should be consistent when
recording user events, importing user events, and sending prediction requests. Using inconsistent
visitor IDs does not return an error, but results in an incomplete history of user events, which can
degrade the quality of model personalization.
To set the
visitorID
value to a variable for the Cloud Retail tag:
In
Tag Manager
,
go to the
Variables
tab and click
New
to create a new user-defined
variable.
Give the variable a name at the top of the dialog, such as "GA visitorId".
Enter your variable settings.
You can use the client ID or the cookie ID to set as the source of visitor
IDs. Always use a consistent visitor ID source when ingesting historical and
real-time user events.
Client ID
In Google Analytics 4, this variable maps to the
user_pseudo_id
field in the
Google Analytics 4 BigQuery export schema
.
Set
Variable Type
to
Custom JavaScript
.
Enter the following script in the
Custom JavaScript
field.
Replace "G-XXXXXX" with your
Google Analytics tracking ID
. To find your
tracking ID, see
What happened to my Tracking ID?
.
function
()
{
var
tracker
=
ga
.
getByName
(
'
G-XXXXXX
'
);
return
tracker
.
get
(
'clientID'
);
}
Click
Save
to save the variable.
Cookie ID
Choose
1st Party Cookie
as the variable type.
In the
Cookie Name
field, enter
_ga
.
Click
Format Value
, select
Convert undefined to..
, and enter
""
(an empty string).
Click
Save
to save the variable.
This maps the first party cookie "_ga" to a Tag Manager variable
called "GA visitorId".
Next,
create a Cloud Retail tag
in Tag Manager. This tag will
use the visitor ID variable you just created.
Create a Google Tag Manager tag
Set up a tag in Tag Manager to send user event information to
Vertex AI Search for commerce.
Sign in to
Tag Manager
and select the container for your site.
Go to the
Tags
tab and click
New
to add a new tag.
Give your tag a name at the top of the panel (the placeholder is
Untitled Variable
), such as "Vertex AI Search for commerce".
Click
Tag Configuration
and choose the
Cloud Retail
tag to
open the tag configuration panel.
Enter your API key.
Use the
key you created
when setting up Vertex AI Search for commerce.
Your API keys are available from the
APIs & Services > Credentials
page in Google Cloud console.
Enter the project number of the Google Cloud project where
Vertex AI Search for commerce is enabled.
The project number is available from your Google Cloud console dashboard.
For the
User Event Data Source
field:
Data Layer
(recommended): Select if your implementation will be one of
the following:
You have Google Analytics Ecommerce implemented through
Tag Manager. Reuse the data layer as your events data source
instead of populating a new one. This uses the Google Analytics
4 schema if present. Otherwise, it uses UA Enhanced Ecommerce.

With this data source, you can only record
add-to-cart
,
purchase-complete
,
detail-page-view
, and
search
events.
search
events are recorded using
ecommerce impressions combined with search queries (see
Create a search query variable
).
You are using Google Analytics Ecommerce, and can manually populate data
layer code. See the
Tag Manager Developer Guide
.
Variable, Cloud Retail
: Select to populate a Tag Manager
variable with the required fields for Vertex AI Search for commerce. You might
choose this option if you aren't using Google Analytics Ecommerce, or if
Google Analytics Ecommerce doesn't have the data needed for
Vertex AI Search for commerce.
If you are switching to this source from the legacy Data Layer -
Cloud Retail option, also create a
Data Layer Variable
with key
cloud_retail
and associate it with this
Variable - Cloud Retail
option.
Variable, Ecommerce
: Select if you aren't using
Google Analytics Ecommerce in your data layer, and can't manually
populate the data layer code, but still want to use the
Google Analytics Ecommerce schema. This is also useful if have
Google Analytics Ecommerce implemented, but want to augment or change the
values in the datalayer. You can then pull those values together into a
custom variable in the Google Analytics Ecommerce schema format that can be
used by the Cloud Retail tag.
In the
Read Ecommerce Data from User Variable
field that appears,
choose a variable. This enables Vertex AI Search for commerce to read
Google Analytics Ecommerce user event data from a custom variable
that you create.
The variable should match the format documented in the
GA4 Developer Guide
.
To construct a variable in the correct format, you can use
Enhanced Ecommerce Object Builder
,
a
custom variable template
from the
Tag Manager community template gallery
.
Community templates are not maintained by Google. To use this template,
see the Enhanced Ecommerce Object Builder gallery page for documentation
and other resources.
Click the
+ Overwrite a value on the UserEvent message
button.
For
Field Selector
, select
visitorId
as the field, and for
Field Value
, select the new visitor ID variable you created in
Create a visitor ID variable
.
Click
Save
.
Your Cloud Retail tag is created.
Legacy data source options
Previously,
Data Layer - Ecommerce
and
Data Layer - Cloud Retail
were
available as data source options. These legacy options aren't available in new
tags. If you switch an existing tag to a new data source,
preview it with Tag Manager
to verify it before
deployment. When switching:
If you used
Data Layer - Ecommerce
, you can switch to
Data Layer
. This uses the Google Analytics 4 schema if present.
Otherwise, it uses UA Enhanced Ecommerce.
If you used
Data Layer - Cloud Retail
, switch to option
Variable - Cloud Retail
. Create a
Data Layer Variable
with key
cloud_retail
and associate it with the
Variable - Cloud Retail
option.
Next:
If you're using search,
create a variable for search queries
and attach it to your new
tag.
Create event triggers for your tag
.
Create a search query variable
If you're using search, you can create a variable in
Tag Manager for search queries and attach it to your Cloud Retail tag.
This allows Vertex AI Search for commerce to get search queries from
Analytics.
The types of variables you create depend on your user event data source.
Variable - Ecommerce
, or the data layer with the Google Analytics Ecommerce schema:
Create a URL or DOM element variable
in Tag Manager and
attach it to your Cloud Retail tag. In addition, enable the option for your
tag to use Google Analytics Ecommerce impressions to construct search events.
Variable - Cloud Retail
, or a manually populated data layer:
Create a URL or DOM element variable
in Tag Manager and
attach it to your Cloud Retail tag. In order to
determine if a user event's type is
search
, you must also either:
Create a constant type variable
for the search event
types and attach it to your tag.
Set the search event type in your data layer or Cloud Retail variable.
Create and attach a Tag Manager variable for search queries
If you use search, you can create a URL, DOM element, or custom
JavaScript variable that will be populated with search queries entered on your
site.
As an alternative to this procedure, you can configure the data layer to provide
search query information. However, you might choose to use Tag Manager
variables if you don't have access to the data layer, or prefer not to configure
the data layer.
You can create a URL type variable, a DOM element type variable, or a custom
JavaScript (page) variable. Which one you create and how you configure it,
depends on your site's implementation:
A
URL variable
gets search queries from your site's search result URLs.
Use this variable if your site includes the query string in the URL of its
search results.
A
DOM element
variable gets the search query information from your site's
Document Object Model (DOM). You don't need to edit the DOM to use this
variable. However, you should be able to read and understand the DOM to
configure this variable correctly.
A
Custom JavaScript
variable returns data formatted by a JavaScript
function. This is useful if you have existing data that you want to format in
the Cloud Retail or Ecommerce schema.
First, create a Tag Manager variable of type URL, DOM element, or Custom
JavaScript:
In
Tag Manager
,
go to the
Variables
tab and click
New
to create a new user-defined
variable.
Give the variable a name at the top of the dialog, such as "search_variable".
Enter your variable settings:
URL type
Set
Variable Type
to
URL
.
Set
Component Type
to
Query
.
If you specify a query key, set it to the key that precedes the
search query in your URL.
For example, if the URL is
http://example.com/?q=shoes
, the query
key is
q
. In this example, the variable's value would get set to
shoes
.
DOM element type
Set
Variable Type
to
DOM Element
.
Set
Selection Method
and enter the search query's element ID or
element selector.
This setting depends on whether your site uses an element ID or a
CSS selector to identify the search query.
If you specify an attribute, set it to the attribute that contains
the search query term.
For example, if the search query in your DOM is
<id="search" value="shoes">
, the attribute would be
value
. In
this example, your variable's value would be set to
shoes
.
Custom JavaScript type
Set
Variable Type
to
Custom JavaScript
.
Replace the variables in the following code and paste it into the
Custom JavaScript pane.
In the Custom JavaScript pane, add JavaScript code that returns a
search event in the
Retail Schema
.
The following sample code transforms data in an existing
Ecommerce
Items
variable into the
productDetails array
used
by the Vertex AI Search for commerce schema and returns a complete event. To use this code,
replace
Ecommerce Items
,
Search Query
, and
Search Filter
with
variables in your Tag Manager implementation.
function () {

  var retail;
  var items = [];

  for (var i = 0; i < {{Ecommerce Items}}.length; i++) {
    var item = {'product':
                {
                  'id': {{Ecommerce Items}}[i].item_id
                }
               };

    items.push(item);
  }

  retail = {
    'eventType': 'search',
    'searchQuery': '{{Search Query}}',
    'filter': '{{Search Filter}}',
    'productDetails': items
  }

  return retail;
}
Click
Save
to save the variable.
Next, attach the variable to your Cloud Retail tag:
On the
Tag Manager
,
Tags
page, click your Cloud Retail tag to edit it.
If your tag's user event data source is
Variable - Ecommerce
or you use
the data layer with Google Analytics Ecommerce schema, select the checkbox
Use enhanced ecommerce impressions to construct search events
.
This allows Vertex AI Search for commerce to determine if a user event's type is
search
based on search data it gets from this tag.
In the
User Events Data
section, click the
+ Overwrite a value on the UserEvent message
button.
Select
searchQuery
from
Field Selector
and set your search query
variable as the
Field Value
.
Save your tag.
Next:
If you chose use a Cloud Retail variable or a manually populated data
layer as the user event source for your Cloud Retail tag, see
Create and attach a constant variable
.
Create event triggers for your tag
.
Create and attach a constant variable
You can use this procedure if you chose
Variable - Cloud Retail
or a
manually populated data layer as the user event source for your Cloud Retail
tag.
Creating a constant type variable for search events and setting it as a user
event override on your Cloud Retail tag allows Vertex AI Search for commerce to
determine if a user event's type is
search
.
As an alternative to this procedure, you can specify the
search
user event
type using the data layer or Cloud Retail variable that serves as your
tag's event source. Otherwise, use the following steps to set the event type.
First, create a constant type variable:
In
Tag Manager
,
go to the
Variables
tab and click
New
to create a new user-defined
variable.
Give the variable a name at the top of the dialog, such as "search_constant".
Set
Variable Type
to
Constant
.
Enter
search
in the
Value
field
Click
Save
to save the variable.
Next, attach the variable to your Cloud Retail tag:
On the
Tag Manager
,
Tags
page, click your Cloud Retail tag to edit it.
In the
User Events Data
section, click the
+ Overwrite a value on the UserEvent message
button.
Select
eventType
from
Field Selector
and set your search query
variable as the
Field Value
.
Save your tag.
Next,
create event triggers for your tag
.
Create event triggers for your Tag Manager tag
Create triggers for all user event types your Vertex AI Search for commerce models
will use.
Tag Manager tags must have triggers that control when the tag should be
"fired" on the site. Triggers listen for when events occur (such as a user
viewing the home page or adding an item to their cart) and prompts your tag to
send that user event information to Vertex AI Search for commerce.
Tag Manager provides some standard triggers. For example,
Window Loaded
is a trigger for
detail-page-view
events. For details
about each type, see
Trigger types
in the Tag Manager
documentation.
You'll usually set the tag to trigger when a user views any page that has the
events needed for Vertex AI Search for commerce (such as the home page, product detail
pages, cart pages, or checkout complete page). In these cases, the tag should
fire after the page has loaded, so that cookies are available and all data layer
variables are populated. To accomplish this, set your triggers to fire on
Window Loaded
or
DOM Ready
.
You might need to fire the tag when an action is performed rather than at
page load (such as if a user adding an item to a cart doesn't force a page to
reload). In these cases, you can configure that click action on your site to
simultaneously push updates to the data layer and associate the trigger with
that action.
For example, if you created a trigger for
add-to-cart
events, you could choose
the trigger type to
Click - Just Links
and set it to fire on the click ID
(in this example,
addtocart
). You would then configure the
addtocart
link on
your site to also update the data layer with new values when clicked:
<a id="addtocart" href="javascript:void(0);"
         onclick="dataLayer.push({
                  'cloud_retail': {
                  'eventType': 'add-to-cart',
                  'visitorId': '456',
                  'cartId': 'mobile',
                  'productDetails': [{
                  'product': {
                  'id': '54321'
                  },
                  'quantity': 1
                  }]}});">Add to Cart</a>
For some user events, you must create a custom trigger. Generally, you create
a custom trigger in Tag Manager using the user event name. If you can't
modify your frontend code, you can create a custom trigger using JavaScript
macros. For more information about custom triggers, see
Custom event trigger
.
Use the following procedures to create triggers in Tag Manager:
If you don't have existing triggers configured
:
Create new triggers for your Tag Manager tag
If you've already set up Google Analytics Ecommerce triggers
: You can
reuse the triggers you configured for Google Analytics Ecommerce instead of
creating new ones. See
Reuse Google Analytics Ecommerce triggers
.
Create new triggers for your Tag Manager tag
If you don't use Google Analytics Ecommerce, create new event triggers for any
user events your Vertex AI Search for commerce models need. Then, associate your new
triggers with the Cloud Retail tag you created in Tag Manager.
Before you start the following steps, make sure you have created a Cloud Retail
tag in Tag Manager. See
Create a Tag Manager tag
.
First, create the triggers. Repeat this procedure for all user events your
Vertex AI Search for commerce models require:
On the
Tag Manager
,
Triggers
page, click
New > Trigger Configuration
.
Choose the
trigger type
that applies to
the user event you're creating a trigger for.
Save your trigger.
Next, associate your new triggers with your Cloud Retail tag. This is
a one-time procedure:
On the
Tag Manager
,
Tags
page, click your Cloud Retail tag to edit it.
Click
Triggering
, select your new triggers, and click
Add
.
Save your tag.
Next,
preview your tag
, and
set up monitoring of event recording errors
and other issues to
make sure that data continues to be received successfully.
If you're using
cloud_retail
data layer as your user event source, make sure
to also
set up your data layer
.
Reuse Google Analytics Ecommerce triggers
If you have implemented Google Analytics Ecommerce using Tag Manager,
reuse event triggers from your Google Analytics Ecommerce for
Vertex AI Search for commerce.
With this data source, you can only record
add-to-cart
,
purchase-complete
,
detail-page-view
, and
search
events.
search
events are recorded using
ecommerce impressions combined with search queries (see
Create a search query variable
).
The following table shows how Google Analytics Ecommerce and
Enhanced Ecommerce events map to Vertex AI Search for commerce events.
Google Analytics 4
Enhanced Ecommerce
Vertex AI Search for commerce
add_to_cart
add
add-to-cart
purchase
purchase
purchase-complete
view_item
detail
detail-page-view
view_item_list
or
view_search_results
impressions
search
(if combined with field
searchQuery
)
Before you start these steps, make sure you have first:
Set up a tag in Tag Manager of tag type
Google Analytics - GA4 Event
, and enabled
Enhanced Ecommerce or GA4 on it. See
the Tag Manager documentation
, and the
GA4 Developer Guide
for details.
Configured your Enhanced Ecommerce or GA4 tag in Tag Manager
to trigger on the user events you plan to record for Vertex AI Search for commerce.
Created a Cloud Retail tag in Tag Manager, with
'Data Layer' or 'Variable - Ecommerce' as the user event data source (see
Create a Tag Manager tag
.
To reuse Google Analytics Ecommerce triggers:
On the
Tag Manager
,
Tags
page, click your Google Analytics Ecommerce tag (type
Google Analytics - GA4 Event
) to edit it.
Under
Advanced Settings > Tag Sequencing
, select
Fire a tag after
<
Enhanced Ecommerce or GA4 tag name
> fires
.
Select your Cloud Retail tag as the
Cleanup Tag
.
Select
Don't fire <
Cloud Retail tag name
> if
<
Enhanced Ecommerce or GA4 tag name
> fails or is paused
.
Save your tag.
Next,
preview your tag
, and
set up monitoring of event recording errors
and other issues to
make sure that data continues to be received successfully.
If you're using
cloud_retail
data layer as your user event source, make sure
to also
set up your data layer
.
Use the
cloud_retail
data layer with Tag Manager
If you created your Cloud Retail tag in Tag Manager to use the
cloud_retail
data layer as the user event source, set up the
dataLayer
variable in your source HTML as described in the
Tag Manager Developer Guide
.
About the data layer
Most Tag Manager tags require data that changes depending on the user or
the page (such as user IDs or product IDs). For the Cloud Retail tag, that data
must be exposed in a structured way using a data layer so that Tag Manager
can use it.
The data layer is a JavaScript object that is typically added to a page using
server-side code or, in the frontend, using HTML or a template. If a page
is configured with the data layer, it will contain some code like the following:
dataLayer
=
dataLayer
||
[]
;
dataLayer.push
({
'cloud_retail'
:
{
'eventType'
:
'home-page-view'
,
'visitorId'
:
'visitor_a'
,
'userInfo'
:
{
'userId'
:
'789'
}
,
}
})
;
This code creates a
dataLayer
object and assigns the
cloud_retail
structure
to it as an array element.
Required fields in the
cloud_retail
data layer
About user events
lists all required fields and examples for
event types that should be passed to the
cloud_retail
data layer.
Your server-side code or templates should have the correct script tags on each
page that you want to send events from. After the
dataLayer
object is
populated correctly on each page, you should be able to test the Cloud Retail
tag.
Some fields like
visitorId
are required for the
UserEvent
message, but might not be available when populating the data layer. For example,
visitorId
might be derived from the user's cookie, or
experimentIds
from the
A/B experimentation framework. In this case, use a variable to overwrite the
field on the Tag Manager tag.
You can overwrite the following fields:
visitorId
userInfo.userId
attributionToken
experimentIds
For how to overwrite a
UserEvent
field in Tag Manager, see
Setting the
visitorID
field in Tag Manager
, which walks
through overwriting the
visitorId
field value with a user-defined
variable.
Note:
Getting the
visitorID
field correct is important. It should be consistent when
recording user events, importing user events, and sending prediction requests. Using inconsistent
visitor IDs does not return an error, but results in an incomplete history of user events, which can
degrade the quality of model personalization.
The following example shows the data layer that needs to be included in your
page for a
detail-page-view
UserEvent
using Tag Manager:
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'detail-page-view'
,
'visitorId'
:
'visitor_a'
,
'userInfo'
:
{
// The user and visitor ID fields can typically be
// be populated from a client-side JavaScript
// variable such as a cookie. If you set the user
// and/or visitor ID values from the server,
// populate the `userID`.
'userId'
:
'user_a'
},
// In most cases, the experiment ID field is populated from a
// client side JavaScript variable as defined by the experiment
// manager.
// If you set the experiment ID value from the server,
// populate the `experimentIds` field here.
'productDetails'
:
[
{
'product'
:
{
'id'
:
'123'
}
}
],
// You can use the 'cloud_retail' data layer element along with other
// data layer elements.
'ecommerce'
:
{
...
},
}];
<
/script>
Preview your Tag Manager tag
Tag Manager's preview mode lets you test new tags before publishing
them to your live site.
For more details about preview mode, see the Tag Manager documentation
for
preview mode
.
Use the following procedure to confirm that your tag is firing correctly.
On the Tag Manager overview page, click
Preview
.
Tag Manager preview mode opens in a new browser tab.
Enter your site information and click
Start
to start Tag Assistant.
In the current browser tab, Tag Assistant starts, and your site opens in a
new tab.
On your site, visit any page where the Cloud Retail tag should be triggered.
Confirm that the Tag Assistant lists the Cloud Retail tag in the
Tags
tab under the
Tags Fired
section.
In the Tag Assistant, go to the
Data Layer
tab and check that the correct
values from the
cloud_retail
or ecommerce data layer are displayed.
Check for tag errors
If some fields are incorrect or missing when you preview your tag, the tag
typically also returns an error, unless it isn't firing at all.
You can check the
Monitoring
page in the
Search for commerce console for errors. This page logs most errors except
for syntax errors, which typically only appear in request results.
You can use the following steps to use Chrome DevTools to check for any errors
generated, including syntax errors.
Turn on preview mode in Tag Manager for your site in a Chrome browser
and visit any page where the Cloud Retail tag should be triggered.
With preview mode open, open DevTools and click the
Network
tab.
Reload the page.
In DevTools, search for
userEvent
.
The Network tab displays the
userEvent:collect
event and its status code.
A
200
response indicates your tag is in a good state.
Other responses, such as a
400
error and highlighting the event in red,
indicate that debugging is necessary.
Double-click the event name to execute the request and show a full response
with more error information.
For example, you might see a
400
error containing the message, "'visitorId'
is required, and cannot be empty", indicating that
visitorId
was not set
correctly.
If no
userEvent
is fired, check the DevTools
Console
tab for syntax
errors in the data layer.
Record user events with server-side tagging
Server-side tagging lets you deploy a single server-side container with
many downstream clients. This creates a single source of truth on the client
side, with many server-side consumers. This architecture shifts the load off the
web and into the server, making it desirable for users who want to maximize
performance of their websites.
The other advantage of server-side tagging is that a single server-side tag can
also support many upstream clients—for example, both web and mobile. Learn how to
set up server-side tagging
.
Vertex AI Search for commerce provides its own legacy server-side tag.
The Cloud Retail server-side tag requires and accepts similar parameters as
the Cloud Retail web tag, such as:
Project number
API key (for authentication)
Overrides for key fields like
visitorId
and
searchQuery
The key difference between the server version and the web version of the Cloud
Retail tag is that you cannot define the data source. The data source for
server tags is a data stream sent from the Google tag in the
GA4
schema.
Set up the Cloud Retail tag
View recorded events
View event integration metrics in the
Events
tab on the Search for commerce console
Data
page. This page shows all events written or imported in last year. Metrics can take up
  to 24 hours to appear after successful data ingestion.
Go to the Data page
What's next
Learn more about
user events
.
You can also import historical user events. It can take a considerable amount of
time to record sufficient user event data to train your models. You can
accelerate initial model training by importing user event data from past events
in bulk. See
Import historical user events
.
Rejoin events
if they were recorded before catalog import was completed.
Learn about
importing and managing user events
.
Start getting predictions
.
Monitor
and
troubleshoot
your data upload
processes.
Learn more about
Tag Manager
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/release-notes.txt
Vertex AI Search for commerce release notes  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All resources
Pricing
Quotas and limits
FAQ
Overview
Conversational features
Search for commerce console
Release notes
Data use terms & conditions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Resources
Send feedback
Vertex AI Search for commerce release notes
This page documents production updates to Vertex AI Search for commerce. Check this page for
announcements about new or updated features, bug fixes, known issues, and
deprecated functionality.
You can see the latest product updates for all of Google Cloud on the
Google Cloud
page, browse and filter all release notes in the
Google Cloud console
,
        or programmatically access release notes in
BigQuery
.
To get the latest product updates delivered to you, add the URL of this page to your
feed
          reader
, or add the
feed URL
directly.
September 15, 2025
Feature
Vertex AI Search for commerce: Additional languages added to search (GA)
Additional languages, including Urdu and Serbian (Cyrillic), are supported in Vertex AI Search for commerce.
For a list of the languages supported, see
Supported world languages
.
September 05, 2025
Feature
Vertex AI Search for commerce: Conversational product filtering
As part of Search for commerce's Guided search package,
ConversationalSearchSpec
sits on top of the Vertex AI Search for commerce. When coverage parameters are met, Search for commerce users can enable this feature in the console or by setting the
followup_conversation_requested
flag to
true
in the search service interface. Conversational product filtering uses an LLM-generated question for each catalog attribute where
allowed_in_conversation
field is enabled.
For more information, see
Conversational product filtering
.
September 03, 2025
Feature
Vertex AI Search for commerce: Conversational Commerce agent, GA
The Conversational Commerce agent uses LLM and conversational product filtering to provide users with a real-time, ongoing conversational experience. The conversational product filtering feature functions as part of the Guided Search package, helping narrow down search queries sooner by presenting users with either relevant products, follow-up questions, or both.
The Conversational Commerce agent is generally available (GA). For information, see
Conversational Commerce agent
and
Conversational product filtering
.
March 11, 2025
Feature
Vertex AI Search for commerce: Conversational Commerce agent, private preview
The Conversational Commerce agent uses LLM and conversational product filtering to provide users with a real-time, ongoing conversational experience. The conversational product filtering feature functions as part of the Guided Search package, helping narrow down search queries sooner by presenting users with either relevant products, follow-up questions, or both.
The Conversational Commerce agent is in private preview. For more information, see
Conversational Commerce agent
and
Conversational product filtering
.
February 03, 2025
Feature
Pinning is available for Vertex AI Search for commerce. Pinning is a serving control for that lets you specify an exact position in search results for a certain item to appear.
The pinning control is created by adding a rule to the search or browse condition, which is the action field
pin_action
in the Retail API. A pin value from 1 to 120 can be applied to determine the fixed position for results matching the defined conditions. This feature is not supported for recommendations.
For more about pinning, see
Pinning controls
.
January 31, 2025
Feature
Vertex AI Search for commerce: Merchandising console
Vertex AI Search for commerce has released a new user-friendly Merchandising console for site merchants and business users. Cloud console admins can grant users access as a Creator or Approver to set or define rules, and create and manage controls. The Google Cloud Search for commerce console Controls section has a Merchandising console tab where admins can grant users access and manage user permissions for the Merchandising console.
For more information, see
Console options for creating controls
.
January 10, 2025
Change
Vertex AI Search for commerce: Renamed in the console and documentation
Vertex AI Search for retail is renamed as Vertex AI Search for commerce. The Google Cloud console and the documentation at cloud.google.com have been updated to reflect the rename. In the console, look for
Search for Commerce
.
September 27, 2024
Feature
Vertex AI Search for retail: Conversational search API
As part of Search for retail's Guided search package,
ConversationalSearchSpec
sits on top of the Retail API. When coverage parameters are met, Search for retail users can enable this feature in the console or by setting the
followup_conversation_requested
flag to
true
in the search service interface. Conversational search uses an LLM-generated question for each catalog attribute where
allowed_in_conversation
field is enabled.
For more information, see
Conversational search
.
Feature
Vertex AI Search for retail: Tile navigation
As part of Search for retail's Guided search package, tile navigation allows tiles to appear for each of the most likely to be used dynamic facets across a search page. The objective is to increase filter usage to narrow search faster.
For more information, see
Tile navigation
.
March 29, 2024
Feature
Vertex AI Retail Search: Search analytics v2 improvements
Enhanced dashboard experience: Leverages Looker for a more interactive and informative analysis of your search and browse performance.
Detailed metrics: Gain granular insights with per-search/per-browse metrics, along with metrics tied to search/browse visits.
Full funnel reporting: Analyze page-views, add-to-cart events, purchases, and revenue to understand the entire customer conversion journey.
Flexible analysis: Filter data by date ranges and device types to tailor your analysis.
March 12, 2024
Change
Vertex AI Search for retail: Renamed in the console and documentation
The Google Cloud console has been updated to show the current product name for Vertex AI Search for retail.
You might see the old names (Retail or Retail API) in some places—for example, in the documentation. Google is in the process of updating content to reflect the new branding.
December 15, 2023
Change
Retail API: Export analytics metrics to BigQuery
You can export Retail analytics metrics into BigQuery. Exporting analytics metrics allows you to retain metrics and write SQL for your own analysis.
For more information, see
Export your analytics metrics into BigQuery
.
December 12, 2023
Feature
Retail Search: Retail Search with LLM public preview
Retail Search with LLM is in public preview.
Retail Search with LLM improves ranking by improving AI-driven grading of how relevant each product is for a specific query.
Prior to this upgrade, these relevance grades were generated by an older generation of AI that produced imperfect scoring. This sometimes caused low-relevance products to be highly ranked in search results.
With this upgrade, Retail Search uses state-of-the-art AI techniques to do the following:
Develop a Giant Relevance LLM that can accurately grade product/query relevance in any retail category in any supported language.
Distill a smaller LLM that is specific to one retailer from the Giant Relevance LLM. This smaller LLM contains the knowledge needed to grade query/product relevance for a specific retailer's catalog and their unique query stream.
Use the smaller, retail-specific LLM to accurately grade products in real-time.
Allow downstream AIs in Retail Search that consume these more accurate query/product relevance grades to correctly rank lower-relevance products as lower in search results.
Lead to increases in revenues and visits for retailers by focusing early search results on higher-relevance products.
Who has access to Retail Search with LLM in the public preview phase?
You must meet the access criteria to be considered for the Public Preview. You need to have:
A fully onboarded Retail project. This means the project is:
Fully onboarded onto Retail Search
Has stable usage. It is being used for production, has no sudden ramps up/down, and has no off-label (unsupported) usage
Correctly onboarded with no major data quality issues
Sufficient search volumes:
Have >5M searches/day (counting search only, no browse) served by Retail Search for each of the past 30 days
If you have multiple projects, you can choose only one project to use for the public preview.
November 02, 2023
Feature
Retail API: Configure logging
You can configure which service logs are written to Cloud Logging. Logging configuration provides a way to set the severity levels at which to write logs, turn logging on or off, and override default logging settings for specific services. For information on how to change Logging configurations, see
Configure Logging
.
October 03, 2023
Feature
Retail Search: Facet controls
You can create facet controls that apply to search and browse operations. These help you control facets values without editing your catalog and set the ranking of facet keys.
Numerical facets have been improved: intervals are calculated but they can also be customized.
The facet controls are:
Ignore facet values
Replace facet values
Set numerical intervals
Remove facets
Force return facets
For more information, see
Facets for search
.
August 04, 2023
Feature
Retail API: View search performance tiers and performance upgrade requirements
Text query search and browse search have different performance tiers that increasingly improve your search results. Unlocking performance tiers relies on the user event and catalog data that you upload to Retail. The Retail console provides a
Data Quality
page where you can check if you have met each tier's data requirements.
For documentation about search performance tiers and how to check data requirements, see
Unlock search performance tiers
.
June 26, 2023
Announcement
Retail API: Data export for analytics and other use cases is in GA
Exporting retail data into BigQuery is now generally available (
GA
), allowing you to extract insights from your data. You can use the data to get Key Performance Indicators with our out-of-the-box
Looker dashboard
, and sales forecasts using
Vertex AI
and our step-by-step instructions.
Feature
Entities
are available as a way to subdivide your retail organization into more than one segment.  For example, entities can represent different regions where stores are located or differently branded stores, such as acquisitions. Recommendations, search results, and autocomplete can give results tailored specifically for an entity.
For more information, see
Entities
.
Feature
The
Data quality
page assesses the quality of your product catalog and user event data and shows you which search performance tiers you have unlocked for Retail Search.
For more information, see
Unlock search performance tiers
.
The
Data quality
page
replaces the
Data Quality
panel
which was on the Retail console Data page.
February 06, 2023
Feature
Retail Search catalog support for Korean, Polish, and Turkish is now generally available (GA). For a list of all languages supported by the Retail Search catalog, see the
FAQ
.
January 12, 2023
Feature
Browse search is generally available using Retail Search. Typically, browsing products using site navigation produces results that are all of equal relevance or sorted by best-selling items. Retail Search leverages AI to optimize how browse results are sorted by considering popularity, buyability, and personalization. See
About text search and browse search with Retail Search
.
Feature
Retail Search can now automatically deliver personalized results for your text query searches and browse searches. Results are personalized for each end-user based on their behavior on your site, including each user's history of product views, clicks, additions to carts, and purchases.
You can use the Data Quality panel on the Retail console Data page to get an assessment of whether the data you have imported is sufficient to turn on automatic personalization. See
Personalization
.
Feature
The Page-level Optimization model is now generally available. Page-level Optimization extends Recommendations AI from optimizing for a single recommendation panel at a time to optimizing for an entire page with multiple panels. The Page-level Optimization model selects the contents for each panel and determines the panel order on your page. For more about this feature, see
Page-level Optimization
.
December 22, 2022
Feature
Recommendations AI now provides the On-sale model. The On-sale model is a personalized promotions-based model that can recommend on-sale products. You can use this model type to encourage users to purchase discounted items.
For more information about the On-sale model, see the
About recommendation models
documentation. For how to create this model, see
Create recommendation models
.
October 27, 2022
Feature
Recording Google Analytics 4 user events to the Retail API is available in GA. If you have integrated Google Analytics 4 for your user events, you can record the user event data in Google Analytics 4 format directly to the Retail API.
To use this feature, see the
Record user events with Google Analytics 4
documentation.
Feature
A/B experiment traffic monitoring for Retail Search is available in private preview. See the documentation for
A/B experiment monitoring
.
A/B experiments compare key metrics between the Retail API and your existing search implementation. After setting up an experiment and its traffic splitting, you can monitor experiment traffic using the Retail console. In the console, you create variant arms that map to each experiment group that you created for the A/B experiment. This allows you to check whether the actual traffic matches the intended traffic split of your experiment. Traffic monitoring can help you determine if differences in traffic are due to a quality gap between services or an incorrect experiment setup.
To use A/B experiment traffic monitoring in private preview, contact Retail Support.
October 12, 2022
Feature
Auto-completion for Retail Search is now GA.
Auto-completion predicts the rest of a query a user is typing, which can improve the user search experience and accelerate the shopping process before checkout.
For more about auto-completion for Retail Search, see the
Auto-completion documentation
.
Feature
Recommendations AI now provides a Buy It Again model.
The Buy it Again model encourages purchasing items again based on previous recurring purchases.This personalized model predicts products that have been previously bought at least once and that are typically bought on a regular cadence.
For more information about the Buy It Again model, see the
Buy It Again documentation
. For how to create this model, see
Create models
.
Feature
Recommendations AI now provides a revenue per session optimization objective for the Others You May Like and Frequently Bought Together model types.
This objective works differently for each model type, but always optimizes for revenue by recommending items that have a higher probability of being added to carts.
For more about the revenue per session optimization objective, see the
Revenue per session
documentation.
Feature
Recommendations AI now provides two diversification options when you create serving configs for recommendations.
Ruled-based diversification affects whether results returned from a single prediction request are from different categories of your product catalog.
Data-driven diversification uses machine learning to balance category diversity and relevance in your prediction results.
For more about diversification types, see the
Diversification
documentation.
September 27, 2022
Change
The
Monitoring & Analytics
page has been split into two separate pages. The contents of the old
Monitoring
tab
appear on the new
Monitoring
page
, and the contents for the old
Analytics
tab
appear on the new
Analytics
page
.
September 23, 2022
Feature
Recommendations AI now provides a Page-Level Optimization model. This extends Recommendations AI from optimizing for a single recommendation panel at a time to optimizing for an entire page with multiple panels. When creating a Page-Level Optimization model, you specify existing serving configurations that this model can use as candidates for each recommendation panel. Page-Level Optimization model then automates the decision process for coordinating model combinations and layouts by automatically selecting the contents for each panel and determining the panel order on your page.
For more information about the Page-Level Optimization model, see the
Page-Level Optimization documentation
. For how to create this model, see
Create models
.
September 15, 2022
Feature
Bulk importing of historical Google Analytics 4 user events with BigQuery is generally available. You can use this feature to import user events to the Retail API if you have integrated Google Analytics 4 with BigQuery and use Enhanced Ecommerce.
See the new documentation:
Import Google Analytics 4 user events with BigQuery
August 03, 2022
Feature
Serving controls can now be imported from and exported to files. This allows you to move serving controls between projects and do bulk edits and additions of serving controls within a project. This feature is available in Preview.
See the new documentation:
Export serving controls
Import serving controls
April 05, 2022
Feature
Retail Search is generally available.
For available features, see
Features and capabilities
.
For an overview of the steps to take to implement Retail Search, see
Implementing the Retail API
. To begin setting up Retail Search, go to
Before you begin
.
Change
There are new data use terms for access and use of customer data for Recommendations AI and Retail Search. To view them, go to
Terms for data use
.
The new terms will be rolled out to Cloud Console from April 4 to 8, 2022. You will be required to accept these terms within 90 days to continue using Retail solutions uninterrupted.
To accept the data use terms:
Access the Cloud Console and select your projects using Recommendations AI and/or Retail Search.
The data use terms will appear on this page. If you wish to continue using our Retail solutions, please accept the terms for all projects using Recommendations AI and/or Retail Search.
If you wish to reject the terms, please disable all projects using the Cloud Retail API (Recommendations AI and Retail Search) in the Cloud Console.
We strongly encourage you to accept the terms before July 13, 2022. If you haven't accepted the terms by this date, you will lose API functionality.
For more details, please review our data use practices at
Retail API data use
.
January 21, 2022
Feature
The Retail console is now available to all Recommendations AI users. The Retail Console is a new way to manage both Recommendations AI and Retail Search seamlessly in one project through a unified onboarding and admin console experience.
We recommend
switching to the Retail console
and
using the Retail documentation
, which documents Recommendations AI, the Retail console, and Retail Search.
To switch, go to the new console and click
Enable the Retail API
. You can then view and manage your project from the new console.
January 15, 2021
Announcement
Recommendations AI is now generally available.
This product has migrated to the Retail API from the Recommendations Engine API.
The previous API (service endpoint
https://recommendationengine.googleapis.com
) and its
documentation set
remain available, but they will no longer be updated. If you used the previous API while it was in beta, we recommend migrating your recommendations to the Retail API (service endpoint
https://retail.googleapis.com
).
See the new documentation:
How-to documentation for Recommendations AI
Reference documentation for the Retail API
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/resources.txt
Resources  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All resources
Pricing
Quotas and limits
FAQ
Overview
Conversational features
Search for commerce console
Release notes
Data use terms & conditions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Resources
Send feedback
Resources
Resources
Pricing
Understand how you are charged for using Vertex AI Search for commerce.
Quotas and limits
Understand the quotas and limits applied to your project.
FAQ
Frequently asked questions.
Release notes
New features, releases, and known issues.
Vertex AI Search for Industry terms for data
    use
The legal terms for data use for
    Vertex AI Search, including Vertex AI Search for commerce.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/result-size.txt
Query expansion  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Query expansion
Query expansion is the incremental loosening of query constraints to include more results when none or too few are initially found. This leads to an adjustment of the result size per query.
When there are no relevant documents at all for a query, Query expansion will return less relevant documents to ensure that query does not return zero search results.
Query expansion tutorial
This tutorial shows you how to enable the query expansion feature. When a shopper uses an ambiguous or a multi-word search phrase, they can get an empty response. After turning on query expansion, the request is analyzed and the expanded list of products based on the parsed search query gets returned.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Example dataset
This page uses the following dataset as an example. Expand it to view the fields within the sample product description dataset.
Example product dataset
ID
title
brands
categories
price_info.price
"nest_mini_2nd_gen"
"Nest Mini (2nd gen)"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"nest_audio"
"Nest Audio"
["Google", "Nest"]
["Nest > speakers and displays"]
99.99
"nest_hub_max"
"Nest Hub Max"
["Google", "Nest"]
["Nest > speakers and displays"]
229.00
"nest_hub"
"Nest Hub"
["Google", "Nest"]
["Nest > speakers and displays"]
88.99
"google_home_max"
"Google Home Max"
["Google", "Nest"]
["Nest > speakers and displays"]
299.00
"google_home_mini"
"Google Home Mini"
["Google", "Nest"]
["Nest > speakers and displays"]
49.00
"google_pixel_5"
"Google Pixel 5"
["Google", "Pixel"]
["Pixel > phones"]
699.00
"google_pixel_4a_with_5g"
"Google Pixel 4a with 5G"
["Google", "Pixel"]
["Pixel > phones"]
499.00
"google_pixel_4a"
"Google Pixel 4a Phones"
["Google", "Pixel"]
["Pixel > phones"]
349.00
"google_pixel_stand"
"Google Pixel Stand"
["Google", "Pixel"]
["Pixel > featured accessories"]
79.00
"google_pixel_buds"
"Google Pixel Buds"
["Google", "Pixel"]
["Pixel > featured accessories"]
179.00
"google_pixel_5_case"
"Google Pixel 5 Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_5g_case"
"Google Pixel 4a (5G) Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
"google_pixel_4a_case"
"Google Pixel 4a Case"
["Google", "Pixel"]
["Pixel > featured accessories"]
40.00
Query expansion
Query expansion increases the recall for query terms with few results,
especially long tail queries.
This search feature is driven by a
specification
determining query-expansion conditions. It includes a
pinUnexpandedResults
option that's off by default. When set to
true
, it displays unexpanded products at the top of search results. The top is followed by the expanded results.
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchRequest
.
QueryExpansionSpec
;
import
com.google.cloud.retail.v2.
SearchRequest
.
QueryExpansionSpec
.
Condition
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchProductsWithQueryExpansion
(
String
query
,
int
pageSize
,
Condition
condition
)
throws
IOException
,
InterruptedException
{
QueryExpansionSpec
queryExpansionSpec
=
QueryExpansionSpec
.
newBuilder
()
.
setCondition
(
condition
)
.
build
();
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setQueryExpansionSpec
(
queryExpansionSpec
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
For example, if you search for
Google Pixel 5
without query expansion, the
result will be restricted to
google_pixel_5
IDs. However, with query
expansion, you might also get
google_pixel_4a_with_5g
,
google_pixel_4a
, and
google_pixel_5_case
IDs in the
example product description dataset
as well.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/retail-api-tutorials-troubleshooting.txt
Troubleshoot tutorial issues  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Technology areas
Guides
Troubleshoot tutorial issues
If you run into problems configuring your tutorial, this page lists issues that you might encounter and provides suggestions for how to fix each issue.
The cloudshell_open folder is missing
If you can't see the cloudshell_open folder in your home directory by running
ls ~
, the folder and its files are lost.
This issue occurs when you use Cloud Shell in Ephemeral mode and lose your Internet connection or refresh the page.
To resolve this issue,  rerun the tutorial from the beginning. To avoid the loss of your files in the future, consider switching to Default mode.
Unable to detect a project ID in the current environment
The following error occurs when you attempt to run a code sample:
ERROR Unable to detect a Project Id in the current environment.
This issue occurs when your Google Cloud project isn't set.
To resolve this issue, set the project by running the following command:
gcloud
config
set
project
<YOUR-PROJECT-ID>
key.json errors when running code samples
One of the following errors occurs when you run code samples:
File /home/user/key.json is not a valid json file
no JSON input found
The file at /home/user/key.json does not exist, or it is not a file
Could not find file '/home/user/key.json'
Error reading credential file from location /home/user/key.json: Value cannot be null
This issue occurs when the key.json file, which is used to authenticate a service account, is empty or missing. You can check if that's the case by running the following command:
cat
~/key.json
This prints either the file's contents or the
No such file or directory
message. An empty file means that the error occurred during key creation. A missing file means that the error occurred before that.
To resolve this issue, follow the "Prepare your work environment" tutorial step.
Vertex AI Search for commerce has not been used in project before or it is disabled
This following error occurs when you attempt to run a tutorial:
PERMISSION_DENIED
:
Vertex
AI
Search
for
commerce
API
has
not
been
used
in
project
<
YOUR
-
PROJECT
-
ID
>
before
or
it
is
disabled
To resolve this issue, enable the Vertex AI Search for commerce on the
API/Services Details
page of the Google Cloud console, or run the following command:
gcloud
services
enable
\
retail.googleapis.com
\
--project
=
<YOUR-PROJECT-ID>
Service account does not have permission to access project instance
The following error occurs when you assign roles to the service account:
User
[
USER@YOUR-PROJECT-ID.
]
does
not
have
permission
to
access
projects
instance
[
YOUR-PROJECT-ID:setIamPolicy
]
(
or
it
may
not
exist
)
:
Policy
update
access
denied
.
To resolve this issue, check that you have the right account active by running the
gcloud auth list
command in the Terminal. Ensure that the active account is the service account. Go to the
IAM
page in the Google Cloud console to check that the service account is an owner of your Google Cloud project.
Invalid authentication using end user credentials
The following error occurs when you run code samples:
PERMISSION_DENIED
:
Your
application
has
been
authenticated
using
end
user
credentials
from
the
Google
Cloud
SDK
or
Google
Cloud
Shell
which
are
not
supported
by
the
retail
.
googleapis
.
com
.
This issue occurs when end user credentials are used instead of a service account. This issue can also occur when a service account isn't active or the required environment variables aren't set. You might see this error after restarting Cloud Shell or opening a new Terminal window.
To resolve this issue:
Follow the "Prepare your work environment" tutorial steps and make sure you have a service account active by running
gcloud auth list
.
Set the environment variables:
For all languages, run the command:
export
GOOGLE_APPLICATION_CREDENTIALS
=
~/key.json
Additionally for .NET,  run the command:
export
GOOGLE_PROJECT_ID
=
<YOUR-PROJECT-ID>
Permissions error when service account doesn't have needed roles
The following error occurs when you run code samples:
google.api_core.exceptions.PermissionDenied: 403 Permission 'retail.<YOUR-REQUEST>' denied on resource '//retail.googleapis.com/projects/<YOUR-PROJECT-ID>/locations/<YOUR-LOCATION>' (or it may not exist). [reason: "IAM_PERMISSION_DENIED"
This issue occurs when your service account doesn't have the required roles: retail.admin and editor.
To resolve this issue, set up your work environment by following the "Prepare your work environment" tutorial steps.
The search operation returned no matching results
This issue occurs when no products in the catalog match your search query or the product catalog is empty.
To resolve this issue, check to see if you have products in your catalog on the
Catalog
page of the Google Cloud console. If you do not, import catalog data by following the "Import catalog data" tutorial step.
There are still problems
Try resetting
Cloud Shell
and run tutorials from the beginning.
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/retail-api-tutorials.txt
Interactive tutorials  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Interactive tutorials
This page lists a set of interactive tutorials for Vertex AI Search for commerce. These
tutorials include actions that can be run in the Google Cloud Shell Editor.
With this tool you can write, build, test, run, and debug cloud native
applications directly from your browser.
Overview
Try different tutorials depending on what you'd like to learn:
If you're starting a project, try the
Import catalog information
tutorials. Here, you learn how to import products into the catalog so you can
try out, for example, different search functionalities. Next, see the
Import historical user events
tutorials. Vertex AI Search for commerce uses user events to generate initial
recommendations and search results. Then try the
Record real-time user events
tutorials. Real-time user events provide high quality and
relevant results.
If you're interested in how search works in general, try the
Search tutorials
.
If you want to learn how to configure search with serving configs and controls,
try the following tutorials:
Filtering
Ordering
Query expansion
Pagination
Boosting
Redirect control
If you need to update your catalog information, see the
Manage catalog information
tutorials.
If you want to learn how to update inventory, see the
Update inventory for search
tutorials.
If you want to learn how to record, view, or remove real-time user events, see
the
Record real-time user events
tutorials.
If you plan to use recommendations, see the tutorials for importing and managing catalogs and user events.
Import catalog information
These tutorials describe how to import your catalog information
and keep it up to date.
Import catalog data from BigQuery
This tutorial shows you how to use a BigQuery table to import
large amounts of catalog data with no limits.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Import catalog data from Cloud Storage
This tutorial shows you how to import a large number of items to a catalog.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Import catalog data inline
This tutorial shows how to import products into a catalog inline.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Manage catalog information
These tutorials describe how to manage your product information after you have
imported a catalog. You can read, write, and
delete products in your catalog.
Learn how to call the API with your language of choice.
Create/Get/Update/Delete product tutorial
This tutorial shows you how to use API
methods, which perform the following actions:
Create a product
Get a product
Update a product
Delete a product
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Create product tutorial
This tutorial shows you how to create a single product.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Get product tutorial
This tutorial shows you how to retrieve a product item.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Update product tutorial
This tutorial shows you how to update a product in a catalog.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Delete product tutorial
This tutorial shows you how to delete a product from a catalog.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Import historical user events
These tutorials describe how to import user event data from past events in bulk.
Models require user event data for training.
Import events from Cloud Storage tutorial
This tutorial shows how to import user events from Cloud Storage.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Import events from BigQuery tutorial
This tutorial shows how to import user events from BigQuery.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Import events inline tutorial
This tutorial shows how to import user events data inline.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Record real-time user events
These tutorials describe how to record, view or remove real-time user events.
Vertex AI Search for commerce uses real-time user events to generate recommendations
and search results. Recording as many types of user events as possible with
valid product information increases the quality of your results.
Write user events tutorial
This tutorial shows how to record user events using the
userEvents.write
method.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Rejoin user events tutorial
This tutorial shows how to rejoin user events by making a
POST
request to the
userEvents:rejoin
endpoint.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Remove user events tutorial
This tutorial shows how to purge user events.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Search Tutorials
The
search()
method is used to search over the catalog according to the search query and other parameters, such as filter, facet, or order_by.
By default, the search response contains a reasonable number of results ordered by relevance.
Querying tutorial
This tutorial shows you how to send a simple search query and analyze the response.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Pagination tutorial
This tutorial shows how to control pagination in the search request. When a shopper looks for products in a shop, they can improve their navigation through search results. For example, they can limit the number of items in the search response by using the page size feature or jump to their preferred page by using the offset feature.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Query expansion tutorial
This tutorial shows you how to enable the query expansion feature. When a shopper uses an ambiguous or a multi-word search phrase, they can get an empty response. After turning on query expansion, the request is analyzed and what's returned is the expanded list of products based on the parsed search query.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Filtering tutorial
This tutorial demonstrates the filtering feature. It lets you fine-tune search requests according to your or your customer's needs. You can filter by single or multiple fields, filter by text or numeric fields, or both. You can use an expression language to construct a predicate for each field or combine different expressions using logical operators. For example, a shopper looking for shoes can use filters to narrow their search to their preferred brand and color.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Ordering tutorial
This tutorial shows how to order items in a search response. When a shopper looks for a product on your site, you can show results ordered by multiple fields. For example, a shopper is searching for a dress with the best price and discount. Price and discount are multiple fields here. The shopper is shown dresses ordered by price, and for the dresses with the same price, ordered by discount.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Boosting tutorial
This tutorial shows some examples of product boosting in search results. With boosting, you can apply a boost to a product to prioritize or deprioritize it in the search results.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Redirect control tutorial
This tutorial shows you how to use the redirect control. The redirect control lets you specify a URL to which you can redirect users when they use a specific search query. For example, if a user requests "sustainable manufacturing products", you can redirect them to a page containing the environmental brands that you are working with.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Update inventory for search
While the
Product
create, read, update, and delete (CRUD) methods are used to
broadly modify a
Product
's attributes, there is a set of
Product
methods
that can be used for updating inventory-specific fields with varying levels of
granularity. The following
Product
fields are considered inventory fields:
Product.price_info
Product.availability
Product.available_quantity
Product.fulfillment_info
Add fulfillment tutorial
This tutorial shows how to update product fulfillment information using the
AddFulfillmentPlaces
method. In this way, search can show updates where products are available and orders can be fulfilled. For example, a shopper is looking for blue jeans in a shop but they're out of stock. The moment the jeans are in stock again at this shop or any other shop, the shopper sees the updates and can proceed with their order.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Remove fulfillment tutorial
This tutorial shows how to update product fulfillment information using
the
RemoveFulfillmentPlaces
method. In this way, search can show updates where products aren't available and orders can't be fulfilled. For example, a shopper is looking for blue jeans in a shop. If the jeans become out of stock in this shop, the shopper sees this and can't proceed with their order.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Set inventory tutorial
This tutorial shows how to push inventory updates using the
SetInventory
method instead of updating the entire product.
To follow step-by-step guidance for this task directly in the Cloud Shell Editor,
  click
Guide me
:
Guide me
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/sayt.txt
Search as you type  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Search as you type
The modern ecommerce search bar is far more than just an input field. It's an interactive, dynamic assistant that guides your users to the right products before they even finish entering text. This search-as-you-type (SAYT) experience, which displays query suggestions, popular brands, relevant categories, and even top product results in real-time, drives user engagement and increases the likelihood of conversion.
While Vertex AI Search for commerce provides distinct APIs for query autocompletion and product search, it intentionally leaves the final implementation of a SAYT user experience open-ended.
This guide to building with Vertex AI Search for commerce explores two primary design patterns for implementing a robust SAYT widget using the Vertex AI Search for commerce APIs, detailing the trade-offs of each approach.
Understand the core components
To build a comprehensive SAYT feature, you need to understand the two fundamental APIs provided by Vertex AI Search for commerce:
CompleteQuery
API
: This is the brains behind your autocomplete suggestions.
Function
: For a given input string, such as
lipst,
it returns a list of suggested query completions, including
lipstick
and
lip gloss,
associated popular brands, and relevant categories.
Cost
: This API is included in the Vertex AI Search for commerce package pricing.
Performance
: It's a high-throughput API designed for the rapid, low-latency responses required for a keystroke-by-keystroke experience. It leverages auto-learning features, including spell correction and suggestions that are designed to yield results, all trained on your store's daily search events.
Search
API
:This is your core product discovery engine.
Function
:For a given query, it returns a ranked list of relevant product results.
Cost
:This is a paid API, and its usage directly impacts your operational costs.
Events
: For model training and analytics, each
Search
API call should ideally be paired with a search event to track user behavior and improve the relevance models over time.
To create the SAYT experience, you must write a wrapper API or frontend logic that calls both these APIs and combines their results into a single, cohesive user interface.
Implementation pattern 1: Direct but costlier approach
This is the most straightforward method to implement. The logic is for every keystroke, you make parallel calls to both the
CompleteQuery
and
Search
APIs.
Flow
The flow follows this sequential path:
A user enters a character, such as
l.
Your application sends
l
to the
CompleteQuery
API.
Simultaneously, your application sends
l
to the
Search
API.
The results are combined and displayed.
The user enters another character (
l,
making the query
li).
The process repeats for the new query
li.
Advantages
The advantages include fast implementation, allowing you to quickly write and deploy the log.
Disadvantages
High
Search
API volume
: This approach dramatically inflates the number of
Search
API calls. A query like
lipstick
would trigger eight separate search requests, leading to a significant increase in volume.
Increased cost
: Since the
Search
API is a paid service, this high volume directly translates to higher operational costs, making it difficult to achieve a positive return on investment (ROI).
Event management complexity
: Every
Search
API call should be logged with a corresponding search event for accurate model training and measurement. The high volume of calls makes it challenging to ensure every event is captured, potentially leading to data loss and skewed analytics.
Potentially lower quality results
: Searches for one or two characters, such as
l, li
can return noisy or overly broad results, leading to a less relevant initial experience.
Implementation pattern 2: The optimized and recommended approach
This pattern optimizes for cost, performance, and relevance by using the
CompleteQuery
API to intelligently decide when to call the
Search
API.
Flow
The flow follows this sequential path:
A user enters a partial text query, such as
lip.
Your application sends
lip
to the
CompleteQuery
API.
The API returns a list of suggestions, with
lipstick
likely being the first result.
Your application takes the first suggestion
(lipstick)
and makes a single call to the
Search
API with that term.
The autocomplete suggestions and the product results for
lipstick
are displayed.
As the user continues to type
lips, lipst, ...
you can add logic to only make a new search call if the first autocomplete suggestion changes.
Advantages
Significant cost reduction
: By drastically reducing the number of
Search
API calls, this method keeps costs under control.
Controlled API and event volume
: API and event volumes are manageable and predictable, ensuring more reliable data for model training and analytics.
Higher relevance
: You are searching for more complete and probable terms, which provides higher-quality product results in the SAYT widget.
Better ROI
: Lower costs and a better user experience contribute to a stronger return on investment.
Handling edge cases
This approach is superior but requires handling a few corner cases:
No suggestions
: If the
CompleteQuery
API returns no suggestions, your logic should fall back to calling the
Search
API with the user's raw input.
Partial vs. suggested query
: In rare cases, a user might want to see results for their partial term, such as
eye
rather than the top suggestion,
eye shadow.
While this is a minor trade-off, the optimized approach prioritizes the most likely user intent.
Measure success with experiment IDs
Regardless of the implementation you choose, it's important to measure the performance of your SAYT widget independently from your main search results page. If you use the same tracking for both, you'll be unable to determine if the SAYT feature is truly improving click-through rates and conversions.
The solution to measuring click-through and conversation rates of the SAYT widget specifically is to use distinct
experimentIds
in your search events that differentiate these metrics from those of the main search events.
SAYT events
: Assign a specific ID, such as
"experimentId": "sayt-widget"
, to all search events originating from the search-as-you-type capability.
Main search events
: Use a different ID (or no ID) for searches initiated when a user presses
Enter
or clicks
Search
to go to the main search results page.
By segmenting your events this way, you can use the analytics dashboards in the Vertex AI console to filter and compare the performance of your SAYT widget against the standard search experience, giving you clear, actionable insights.
Conclusion
Vertex AI Search for commerce provides the components for creating a search-as-you-type experience. By acting as the architect who designs the interaction between the
CompleteQuery
and
Search
APIs, you can build a search capability that builds the bridge between user experience and performance. For most use cases, the optimized approach delivers a user-relevant experience while avoiding compute-heavy operations.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español – América Latina
Français
Português – Brasil
中文 – 简体
日本語
한국어

# Source: cloud.google.com/retail/docs/search-basic.txt
Get search results  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Get search results
This page describes basic querying with search, including text
query searches, browse searches, pagination, optimization, and
personalized results.
Never cache personalized results from an end user, and never return personalized
results to a different end user.
Relevance in Vertex AI Search for retail
Relevance is different from matching. Matching is finding candidate products in the index that correspond to
the user's search query. Relevance, on the other hand, is a degree of matching. It involves
ranking those products in a way that best satisfies the user's intent and needs.
Vertex AI Search for retail uses techniques to improve matching and
relevance for a better overall search experience for users that meets retailers' need.
Non-default search
Vertex AI Search for commerce defaults to relevance in search. However, search is tuned to also surface marginally relevant items higher up in the search results to provide retailers more targeted search results to increase the conversion potential of user events.
These added search features optimize the default relevance algorithm, providing non-default features tuned to each retailer's utilization profile, including:
Options to sort results such as by price, top-rated, or best-selling items. Non-default search is customized to return specific search results with the correct product
variants
. For example, to show the cheapest or most expensive variant when sorting by price.
Auto-application of a tighter relevance filter for non-default user events.
Enabling adjustable strength boost/bury  controls to fine-tune search results.
Note:
Expected behavior is fewer products appearing in non-default search scenarios, because less relevant items are filtered out. Given the limited scope of non-default searches, occasional lower-than-expected product counts in search results don't negatively impact revenue growth.
Text search and browse search
Search provides both text query search and browse
search capabilities.
In the text query search use case, a shopper might enter a text-based query on
your site. Search returns a search response containing products
that fit within the parameters of controls you have set up, sorted by relevance
and revenue maximization.
In the browse use case, a shopper might go to your site menu and
navigate to a specific product category. Search automatically
chooses the most revenue-maximizing sort order by learning from user behavior
and trends. Browse results can be further refined by the controls you have set
up.
Both text search and browse search requests use the
servingConfigs.search
method.
Note:
The wildcard (*) is not supported and its usage may lead to inconsistent results.
Text query searches
When a user enters a text query to search on your site, search
sorts potential search results based on relevance, popularity, buyability, and
personalization.
Search considers a
servingConfigs.search
request as a
text-based search request if it has a non-empty
query
field.
When uploading user event, send text query search events generated by
search as
search
user events. If the event has a non-empty
userEvent.searchQuery
field and an empty
userEvent.pageCategories
field,
search considers it a text-based search event.
Browse searches
Browse uses site navigation to produce search results
of equal relevance sorted by best-selling items. Search leverages AI to optimize how browse results are sorted by considering popularity, buyability, and personalization.
Important:
For browse searches to work, the
SearchRequest.pageCategories
field cannot be empty. It must always be populated for optimal browse results.
To get the correct browse search results, consider the following:
The
pageCategories
and
filter
values in your search requests must exactly match the
pageCategories
and
filter
values in your uploaded user events. If the parameters in the requests do not match parameters in the events, the click-based reranking model learned from the events won't perform very well for this specific query and will negatively
impact result quality.
Vertex AI Search for commerce categorizes a
search
user event as a browse-based event
if it has an empty
userEvent.searchQuery
field and a non-empty
userEvent.pageCategories
field. This is why you need to make sure you send browse events generated by Vertex AI Search for commerce as
search
user events when uploading them.
A browse filter must be valid and indicate for each browse query which products belong to the product category the user is browsing in. To achieve this setup, the category ID needs to be defined in both the
filter
and the
page_category
fields. Take, for example, if you want the search results to be targeted to Home & Garden. First off, having only one
filter
value of
"in-stock"
does not refine the search enough to provide optimal browse results. To provide search results restricted to Home & Garden, you not only need to set
"Home \& Garden"
in the page category, but also in the filter with
categories: ANY("Home & Garden")
. If you neglect to define the category in the filter part, browse results could likely be too broad and include many non-Home & Garden items.
Serving requests and events with an empty query field and filled
page_categories
fields are considered browse requests and user events. The
page_categories
field specifies the browse page itself. When the
servingConfigs.search
method sends a request, search
considers it a browse search request if the
query
field is empty.
When that is the case, the results are based on the
filter
and
pageCategories
fields and, if available, more optimization and personalization.
You can set the category in both as in this example:
JSON
page_ca
te
gory
:
"Home & Garden"
f
il
ter
:
"(availability: ANY("
IN_STOCK
")) AND (categories: ANY("
Home
&
Garde
n
"))"
Otherwise, because browse works with empty string queries, the products in a given category won't automatically be displayed in the results for a given page category. In other words, if the end user browses without specifying anything using a text query, the search return may not yield effectively targeted results, even if the user navigates to a category page.
Use search requests
Use search requests to get results for both text searches and browse searches.
To make a search request, use the
servingConfigs.search
method.
All search requests require
placement
, which identifies the full resource name
of the serving config that will be used. The serving config determines which
settings and associated controls affect the search results.
Text query search requests require a non-empty
query
field.
Browse search requests require a non-empty
pageCategories
field.
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchProducts
(
String
query
)
throws
IOException
,
InterruptedException
{
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
By default, a reasonable number of results ordered by relevance is returned.
To get product attributes returned with the search response, make sure to
provide attribute values when you import your catalog data.
Product
has predefined system attributes such as brand, color,
and size that you can provide values for. You can also include custom attributes
that you define with
Product.attributes
.
Querying tutorial
This tutorial shows you how to send a text-based search query to the
Vertex AI Search for commerce service and analyze the response.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Pagination
Use pagination to decrease lookup time and the size of responses being sent.
Pagination tutorial
This tutorial shows how to control pagination in a text-based search request.
When a shopper looks for products in a shop, they can improve their navigation
through the search results. For example, they can limit the number of items in
the search response by using the page size feature or jump to their preferred
page by using the offset feature.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Paginate
To jump from one page to another, use either
page_token
or
offset
, according
to your use case.
To jump to the next page, you could use
page_token
. For example, suppose you
send the following
SearchRequest
.
JSON
{
placement:
'projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/placements/default_search'
visitor_id:
'
VISITOR_ID
'
query:
'shoes'
page_size:
5
}
From
SearchResponse
, you can get the resulting products with top 5
relevance, along with a
next_page_token
.
JSON
{
results:
[
products
{
...
}
,
products
{
...
}
,
products
{
...
}
,
products
{
...
}
,
products
{
...
}
]
next_page_token:
"wY4ETNkBDOlVjZ0YWLzUmM40SMhVjMtADMwATL5UGN5MGZlVDJaIQ5LaYsQUw9fC6lIwgE1EgC"
total_size:
100
search_token:
"NtQKDAiXt4_3BRDCg_jnARABGiQ1ZWRjOTRlOC0wMDAwLTI1YTEtODJlMy1mNGY1ZTgwZDUxOGM"
}
To get the result products with the next 5 relevance (6th to 10th), you would
set
page_token
using the same
placement
,
visitor_id
, and
query
as
next_page_token
from the previous
SearchResponse
.
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchProducts_withNextPageToken
(
String
query
,
int
pageSize
)
throws
IOException
,
InterruptedException
{
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchRequest
firstRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
build
();
SearchResponse
firstResponse
=
searchClient
.
search
(
firstRequest
).
getPage
()
.
getResponse
();
System
.
out
.
println
(
"First search response: "
+
firstResponse
);
SearchRequest
secondRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setPageToken
(
firstResponse
.
getNextPageToken
())
.
build
();
SearchResponse
secondResponse
=
searchClient
.
search
(
secondRequest
).
getPage
()
.
getResponse
();
System
.
out
.
println
(
"Second search response: "
+
secondResponse
);
}
}
In this example,
SearchRequest
looks like this:
JSON
{
placement:
'projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/placements/default_search'
visitor_id:
'
VISITOR_ID
'
query:
'shoes'
page_size:
5
page_token:
"wY4ETNkBDOlVjZ0YWLzUmM40SMhVjMtADMwATL5UGN5MGZlVDJaIQ5LaYsQUw9fC6lIwgE1EgC"
}
In some other cases, instead of navigating from page to page or getting results
with top relevance, you could directly jump to a particular position with
offset
.
Java
import
com.google.cloud.retail.v2.
SearchRequest
;
import
com.google.cloud.retail.v2.
SearchResponse
;
import
com.google.cloud.retail.v2.
SearchServiceClient
;
public
static
void
searchProducts_withOffset
(
String
query
,
int
pageSize
,
int
offset
)
throws
IOException
,
InterruptedException
{
SearchRequest
searchRequest
=
SearchRequest
.
newBuilder
()
.
setPlacement
(
DEFAULT_SEARCH_PLACEMENT_NAME
)
.
setBranch
(
DEFAULT_BRANCH_NAME
)
.
setVisitorId
(
VISITOR_ID
)
.
setQuery
(
query
)
.
setPageSize
(
pageSize
)
.
setOffset
(
offset
)
.
build
();
try
(
SearchServiceClient
searchClient
=
SearchServiceClient
.
create
())
{
SearchResponse
response
=
searchClient
.
search
(
searchRequest
).
getPage
().
getResponse
();
System
.
out
.
println
(
"Search response: "
+
searchResponse
);
}
}
For example, if you want the tenth page of the results when the page size is 5,
then you could set the
offset
to be 45, which is calculated by (10 - 1) * 5.
JSON
{
placement:
'projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/placements/default_search'
visitor_id:
'
VISITOR_ID
'
query:
'shoes'
page_size:
5
offset:
45
}
Search performance tiers
Search offers several search performance tiers that increasingly
improve your results. For example, for text query search use cases, results
might be based solely on relevance. As you unlock more advanced performance
tiers, search can return results that are based on relevance,
popularity, revenue optimization, and personalization.
Search automatically unlocks higher performance tiers when you
upload catalog and user event data that meets the minimum requirements of each
tier.
For more information about using this
page to view data quality and search performance tiers, see
Unlock search
performance tiers
. The
Data quality
page on
the Search for commerce console provides an assessment of which
requirements you have met for each tier.
Evaluate text search and browse results
Before you update your website code to request text search or browse search
results, you can preview the results to confirm that your serving config is
working as you expect.
For more information about serving configs, see
About serving configs
.
You can preview serving config results either from the
Evaluate
page, or by
going to a serving config's
Details
page in the console and clicking its
Evaluate
tab. The following steps show you how to preview from the
Evaluate
page.
To preview the results returned by your serving configuration:
Text search
Go to the
Evaluate
page in the Search for commerce console.
Go to the Evaluate page
Click the
Search
tab.
Note:
The
Search
tab is available only if you have
search turned on. For instructions to turn it on, go to
Before you begin
.
Select the serving config that you want to preview.
Select the catalog branch that contains the catalog you want to preview.
Optional: Enter a visitor ID to preview search results for that user.
Optional: Enter a user ID to preview search results for that user.
Optional: Enter a search time to preview search results that would appear
at the specified time.
For example, if you have promoted certain products for a special sale, you
can see results as they would appear on that day.
Optional: Select facets to display alongside the search results and click
OK
to apply them.
The facets you select are used to generate a list of facet filters that
appear under
Add facets
after you perform the initial search. These
facet filters can include facets other than those you select in this step,
such as dynamic facets.
Enter a text-based search query to preview search results for that query.
Click
Search preview
or press enter in any input field to see the
results.
Search results are displayed with their available thumbnail images.
If your search triggers a redirect control, a notice appears that displays
the redirect URI.
Optional: Click the
Grid
icon or the
List
icon to switch how your
search results are displayed in preview.
Optional: If you selected facets to appear alongside your results, select
one or more facet values from the facets list to filter results by those
values. The results are automatically updated upon selection.
When you select multiple values of the same facet, they are applied as an
OR operator would be, and values across different facets are applied as
an AND operator would be. For example, after selecting the facets
color
and values "blue" and "gold", and the
material
values "cotton" and
"polyester". Your search results results must have either "blue" or "gold"
as an attribute, and must also have either "cotton" or "polyester" as an
attribute.
Browse
Go to the
Evaluate
page in the Search for commerce console.
Go to the Evaluate page
Click the
Browse
tab.
Note:
The
Browse
tab is available only if you have
search turned on. For instructions to turn it on, go to
Before you begin
.
Select the serving configuration that you want to preview.
Select the catalog branch that contains the catalog you want to preview.
Optional: Enter a visitor ID to preview results for that user.
Optional: Enter a user ID to preview results for that user.
To preview how results would look with a specific filter added,
enter a filter string. Use the filter expression syntax specified in the
Filter
documentation.
Optional: Enter a browse time to preview results that would appear
at the specified time.
For example, if you have promoted certain products for a peak sale event, you
can see results as they would appear on that day.
Enter the page category that you are testing browse results for.
Optional: Select facets to display alongside the results and click
OK
to apply them.
The facets you select are used to generate a list of facet filters that
appear under
Add facets
after you perform the initial search. These
facet filters can include facets other than those you select in this step,
such as dynamic facets.
Click
Browse preview
or press enter in any input field to see the
results.
Results are displayed with their available thumbnail images.
Optional: Click the
Grid
icon or the
List
icon to switch how your
results are displayed in preview.
Optional: If you selected facets to appear alongside your results, select
one or more facet values from the facets list to filter results by those
values. The results are automatically updated upon selection.
When you select multiple values of the same facet, they are applied as an
OR operator would be, and values across different facets are applied as
an AND operator would be. For example, after selecting the facets
color
and
material
, you might then filter your search results by selecting the
color values "blue" and "gold", and the material values "cotton" and
"polyester". Your results must have either "blue" or "gold" as an
attribute, and must also have either "cotton" or "polyester" as an
attribute.
To see the
Details
page for the serving config you're previewing, click
View serving config
under the
Select serving config
field.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/serving-control-rules.txt
About serving controls  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About serving controls
You can apply serving controls to
serving configs
to customize how
search treats search queries and returns results. A serving
control is a rule consisting of a condition-action pair, where the condition
dictates when the serving control will execute, and the action specifies what
behavior the serving control will enact.
You can create a serving control by using the API
Control.create
method.
If you don't want to use the API, you can choose
console
for creating serving controls in Vertex AI Search for commerce.
Available serving controls
The following serving controls are available:
Boost/bury
: Affects result ranking and order in the
returned result list. Available for search and
recommendations.
Filter
: Removes results that don't pass the filter from the
returned result list. Available for search only.
Redirect
: Redirects your users to a specific page depending
on the search query. Available for search only.
Pinning
: Exact position in the results is specified for a
certain product.
Linguistic
: Customizes search query linguistics. Available
for search only. Several types of linguistic controls are
available:
Synonym
: Expands considered synonyms for a search query.
One-way synonym
: Expands considered synonyms
unidirectionally for specific terms.
Ignore
: Prevents a term from being used in searches.
Do not associate
: Prevent terms from
being used in searches when specific terms appear.
Replacement
: Replaces terms in the search query.
Control conditions
Control conditions dictate when a serving control will execute.
Control condition fields can be query terms, time ranges, or both. Some control
types allow multiple condition fields, or don't allow any.
The condition fields available:
Query terms
: Triggered when the term appears in the search query.
A full match requires the entire search query to match the query term.
Multiple query terms can be specified. Triggers as long as one of the query
terms appears in the search query.
Active time range
: Triggered when the date of the search query is in the
time range.
Multiple time ranges can be specified. Triggers as long as date of query is
within the time range (inclusive).
The condition fields that you specify determine whether the control will be
applied.
Multiple condition fields
are combined using AND. This means
that if you specify both time range and query terms, both condition fields
need to be triggered for the control to apply.
Multiple condition sub-fields
are combined using OR. This means that if
you have multiple query terms the query terms will be triggered if any one
query term matches. If you have multiple time ranges, any one time range that
matches will trigger the control.
No condition fields
specified mean the control always applies. However,
some controls require a field to be defined.
For more about condition settings, see the
Controls.condition
API reference
.
Control actions
A control action specifies what behavior the serving control will enact if the
conditions are met during a search.
What kind of action you can specify depends on the type of serving control you
create. For example, the action for a boost/bury control is to apply a
boost/bury value to products that the filter you specify, while the action for a
one-way synonym control is to apply an associated term that you specify.
Boost/bury controls
Boost/bury controls enable you to show certain search results as
higher or lower in ranking.
You can create a boost/bury control for search or
recommendations. Boost/bury for recommendations is
in Public Preview.
When creating a boost/bury control, you can use filter expressions to specify
the conditions based on
Product
fields.
For search filters, use the filter expression syntax
documented in
Filter and order results
.
For recommendations filters, use the filter expression syntax
documented in
Filter recommendations
.
You can then apply a
boost
value between -1.0 and 1.0 to indicate how much to
boost or bury product results matching those conditions. A positive value boosts
the results, and a negative value buries them.
Setting a high boost strength gives the item a large promotion, but doesn't
necessarily mean that the boosted item will be the top result at all times.
Results that are significantly more relevant to the search query can still trump
heavily favored but irrelevant items. Likewise, setting the boost strength to
-1.0 would give the item a large demotion, but results that are deeply relevant
might still be shown.
As an example of using boost/bury, you could prioritize cheaper products and
deprioritize the expensive ones.
Control conditions differ between search and
recommendations boost/bury controls:
Search: You can set query terms and applicable time ranges
as the control conditions.
Recommendations: Control conditions aren't available. The
control always applies.
As a control action, specify a filter for products to boost or bury, and set the
boost/bury value.
To create a boost/bury control, see
Create a new serving control
.
For more about boost/bury control settings, see the
Controls.BoostAction
API reference
.
Filter controls
With filter controls, you can dynamically add predefined filters based on a
specific search request.
You can use filter expressions based on
Product
fields. See
Filter and order results
for the filter expression syntax.
You can set query terms and applicable time ranges as the control conditions. As
a control action, specify a filter to apply at query time.
For example, given the query
blue shoes
, you can use a filter control to automatically filter search results on the color blue. You can also use filter
controls to prevent certain results from being returned to shoppers.
To create a filter control, see
Create a new serving control
.
For more about filter control settings, see the
Controls.FilterAction
API reference
.
Redirect controls
You can use a redirect control to redirect your shoppers to different pages
based on their intent, instead of only showing them search results.
You can set query terms and applicable time ranges as the control conditions. As
a control action, specify a redirect URI to redirect to if the conditions are
matched.
For example, you could create a redirect control so that during a promotion for
a the product
gShoe
, queries with
running shoes
or
sports
shoes redirects to the gShoe product page. Another case for using redirect controls would be to redirect shoppers to a specific page if they search for a term that is not relevant to your site, such as a search for
FAQ
redirecting the user to the actual Frequently Asked Questions page on your site instead of showing search results.
To create a redirect control, see
Create a new serving control
.
For more about redirect control settings, see the
Controls.RedirectAction
API reference
.
Pinning controls
Pinning controls let you specify an exact position in the results you want a certain product to appear.
You can create a pinning control for search or browse. It is not supported for recommendations.
When creating a pinning control, you can use filter expressions to specify
the conditions based on
Product
fields.
As a control action, add a
Rule
to your search or browse
Condition
which will be the action field
pin_action.
You can then apply a
pin
value between [1,120]  to indicate the fixed position to pin the results to matching those conditions given.
Rule Condition
: Must specify non-empty
[Condition.query_terms][]
(for search only) or
[Condition.page_categories][]
(for browse only), but not both.
Action Input
:
[pin_position, product_id]
pairs are mapped (the input position can be a value from 1 to 120). The maximum size is the maximum request page size. 10 is the number of allowed pairs in the pin map.
Action Result
: Pin products with matching IDs to the position specified in the final result order.
To name an example, suppose the query is
shoes
, the
[Condition.query_terms][]
is
"shoes"
and the
pin_map
has
{1
,
pid1}
. The product with
pid1
is pinned to the top position in the final results.
Note:
A query with an active pin experiences 100ms of added latency.
Enabling pins and applied rules
When a pinning control is enabled:
Products with product IDs which match a pin appear in the final response in the exact position specified by the control.
Pins to the second page or later (higher page number) are not allowed, that is, any pin that is set to a position higher than the request
page_size
is ignored.
A maximum of 10 products can be pinned with one control.
The
product_id
must be the ID of an existing product in the catalog.
The product is always recalled in every search and appears on the page unless:
Filters and sorting are applied. These prevent pins from appearing.
The sort order (such as having the search results sorted by price) is not the default.
Pin behavior
If a product is pinned, it will ignore any
boosts or buries
from the request or from other controls.
If a product is pinned to multiple positions, the most recently updated control takes precedence.
Two products cannot be pinned to the same position inside the same pinning control (pin map).
If multiple controls match the same query and each of those have a different pin for the same product ID, the
[pin_pos, p_id]
pair from the most recently updated control takes precedence.
Caution:
Adding pinning controls to many common queries can adversely impact your total latency. Use sparingly and only when necessary.
Linguistic controls
You can create additions or overrides to how words are treated for certain queries.
Synonym controls
Setting two words as synonyms is a linguistic control that associates two words.
Synonym controls add additional context to a search query. They don't force a
result to be included in the search results, but they can help the system
include additional products in the search results, making it more likely that a
given result is included. In other words, synonym controls can encourage the
search result to consider more options, but ultimately the search result will be
dependent on scoring.
For example, if you want search results for
running shoes
to also include
sport shoes
, create a linguistic synonym control. The condition is that
running shoes
is entered as the search term. The action is to include the synonym
sport shoes
with that search. So when a shopper on your site searches
running shoes
, search finds that match in the linguistic control you created, expanding it to include
sport shoes
when it returns search results to the shopper.
To create a synonym control, see
Create a new serving control
.
Two-way synonym controls
Use two-way synonym controls to link several terms together so that
search treats them the same during searches.
You can set query terms and applicable time ranges as the control conditions.
You don't need to set a separate control action; if a term you specified is
used as a query, the control action is to use other terms you specified as the
synonyms.
For example, you could set a two-way synonym control that associates the terms
dish towel
and
kitchen towel
as synonyms. When a shopper on your site enters
kitchen towel
as a query, search can then expand the query to
include results for
dish towel
and
kitchen towel
.
To create a synonym control, see
Create a new serving control
.
Synonyms don't change the original query. For example, if queries A and B are a two-way synonym, expect the following effect:
Query A results returned
: Set A (with no synonym rule applied) and some of set B. However, the results might be less than the combination of A and B.
Query B results returned
: Set B and some of A, but possibly less than the sum of result sets A and B.
For more about two-way synonym control settings, see the
Controls.TwowaySynonymsAction
API reference.
One-way synonym controls
One-way synonym controls expand query terms to link terms together unidirectionally.
You can set query terms and applicable time ranges as the control conditions. As
a control action, specify the terms to use as one-way synonyms.
For example, you could set a one-way synonym control that expands searches for
the term
rose
to include the term
pink
. Because it is a one-way synonym,
searches for the term
pink
don't expand to include the term
rose
.
To create a one-way synonym control, see
Create a new serving control
.
Note that just as with two-way synonyms, the original query is executed and the synonyms are provided as hints to that query. Synonyms for entirely different words may only result in small numbers of the synonym terms being included in the results. The preceding example returns pink items with an emphasis on pink roses, but a synonym rule expanding searches for the term
dog
to include
cat
returns mostly items with dogs, plus some with cats.
For more about one-way synonym control settings, see the
Controls.OnewaySynonymsAction
API reference
.
Synonyms don't provide identical results
Search results for two synonyms aren't always identical.
For example, if you set
laptop bags
and
luggage
as two-way synonyms,
the system might already associate
suitcase
with
luggage
. So, when a user
searches for
luggage
, Vertex AI Search for commerce returns results about
luggage
,
suitcase
, and
laptop bags
. However, when you search for
laptop bags
,
Vertex AI Search for commerce only adds
luggage
to the synonyms. So the results
might not contain
suitcase
.
Ignore controls
Ignore controls prevent search from using certain query terms
during searches. They mark ignored terms in a query as not important, but does not exclude them from the query entirely.
To completely remove a search term from a query, use a
replacement
control
. While a
filter control
affects which results
are shown, a replacement control is a more robust way to prevent
Vertex AI Search for commerce from returning results for a specific term.
An ignore control doesn't guarantee that results for the ignored term won't be returned in a Vertex AI Search for commerce results. For example, an ignore control for the word
oil
could still return oil paints for a query of
oil paints.
The query will be passed as
paints,
and there may be many oil paints matched, but the result set will be larger as the search is for
paints.
This type of control might be useful if
oil paints
were a popular query on your site and you sell many different types of paints, but not many oil-based paints.
You can set query terms and applicable time ranges as the control conditions.
You don't need to set a separate control action; if a term you specified is
used as a query, the control action is to ignore that term.
For example, you could create a control that ignores query terms that use
offensive language.
To create an ignore control, see
Create a new serving control
.
For more about ignore control settings, see the
Controls.IgnoreAction
API reference
.
Do-not-associate controls
Do-not-associate controls suppress certain search terms from being associated with other specified ones. This won't necessarily affect the search results, but it can.
Use a given query term and applicable time ranges for your control conditions.
As a control action, specify which terms
shouldn't
be associated with the
query terms.
Example: You create a control that prevents a brand name (such as
gShoe
) from grouping with
cheap
and
poor quality
in a
query. A shopper searches for
poor quality cheap gShoe
. Search removes the query terms
cheap
and
poor quality
from the initial query, with the resulting query term being
gShoe.
However, this does not guarantee that it is entirely removed from the search results.
If a relevant query term also contains a term specified as do-not-associate, that relevant result might still be returned. To prevent this
from happening entirely, use a
filter
control.
To create a do-not-associate control, see
Create a new serving control
.
For more about do-not-associate control settings, see the
Controls.DoNotAssociateAction
API reference
.
Replacement controls
Replacement controls replace one or more given query terms with a different term
that you specify. You can specify multiple terms that can be mapped to single
term (but not vice versa).
You can set query terms and applicable time ranges as the control conditions. As
a control action, specify the term that should be used as a replacement.
For example, you could create a control that replaces nicknames for a brand with
the full brand name that is more commonly used in product descriptions.
To create a replacement control in the Search for commerce console, see
Create a new serving control
.
For more about replacement control settings, see the
Controls.ReplacementAction
API reference
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/setting-up.txt
Setup prerequisites  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Setup prerequisites
Before you can set up Vertex AI Search for commerce for a new project, you must:
Create
a new project or
set up
your existing project
Enable
Vertex AI Search for commerce
Import
your product catalog and user events
Create a Google Cloud project
On the
Manage resources
page in the Google Cloud console, select or
create a Google Cloud project
.
Go to the Manage Resources page
Make sure that billing is enabled for your Cloud project. Learn how to
check if billing is enabled on a project
.
Set up Vertex AI Search for commerce
To use Vertex AI Search for commerce, take the following steps. Also, if you enable
Vertex AI Search for commerce and use recommendations, know that costs are based on the
number of queries. For more information on Vertex AI Search for commerce pricing, see
Vertex AI Search for commerce charges
.
Important:
You must accept the Vertex AI Search for Industry terms for every project that you want to use Vertex AI Search for commerce with.
For your new project
To set up Vertex AI Search for commerce:
Go to the
Vertex AI Search for commerce
page in the Google Cloud console.
Go to the Search for commerce page
On the
Set up Vertex AI Search for commerce
page, click
Turn on API
.
When
Vertex AI Search for commerce
and
Recommendations AI
display as
On
, click
Continue
.
Read the
Vertex AI Search for Industry terms for data use
for data use and click
Accept
if you agree to the data use terms. You will receive confirmation from the Google Cloud console once the terms have been accepted for search.
If you want to use the project with recommendations only, click
Get Started
.
To turn on search in addition to
recommendations, do the following:
Click
Continue
and then click
Turn on
on the
Turn on
search (Optional)
page.
Click
Get Started
.
The Google Cloud console displays the Vertex AI Search for commerce components that you have turned on. You can now
configure your project's initial settings
.
For an existing project
To continue on an existing project, complete these steps:
Go to the
Search for commerce
page in the Google Cloud console for your project.
Go to the Search for commerce page
On the
Data use terms
page, read the Discovery Solutions data use terms and click
Accept
if you agree to the terms.
If you want to use the project with recommendations only, click
Get Started
.
If you want to turn on search in addition to recommendations, do the following:
Click
Continue
and then click
Turn on
on the
Turn on
search (Optional)
page.
Click
Get Started
.
Important:
Ensure you have the Retail Admin or Owner role for your project before accepting the data use terms.
Turn off search features
If you no longer want to use search, you can turn it off by
submitting a support ticket.
To set your ticket to the correct component, select the following fields:
Category
: Machine Learning
Component
: Vertex AI Search for commerce: search & browse
Subcomponent
: Account Administration & Billing
For more information on creating a support ticket,
see
Getting support
.
Turn off Vertex AI Search for commerce
You can turn off Vertex AI Search for commerce at any time by disabling it.
This turns off both recommendations and search.
To turn off Vertex AI Search for commerce, complete the following steps:
Go to the
Vertex AI Search for Retail API/Service Details
page in the
Google Cloud console.
Go to Vertex AI Search for commerce API Service Details page
Click
Disable API
.
In the
Disable Vertex AI Search for commerce API?
box, click
Disable
.
Note:
When you disable the Vertex AI Search for commerce API, it takes several hours for the
Vertex AI Search for Industry terms for data use to be disabled for the project.
Get started with Vertex AI Search for commerce
When you set up Vertex AI Search for commerce for a new project, the
Google Cloud console displays the following three panels to help you configure your
Vertex AI Search for commerce project:
Data
>
Catalog
: displays your product catalog and a link to import
your catalog.
Data
>
Events
: displays your user events and a link to import
historical user events.
Serving configs
: contains details on your serving config and a
link to create a new serving config.
You can use these panels to import your data and to create an initial
configuration for your Vertex AI Search for commerce project.
Import your product catalog
To import your product catalog, complete the set of steps for your data source.
For more information on product catalogs, see
Importing catalog information
.
Deprecated:
The Merchant Center connector is deprecated and only
available to current users. New users must use the Catalog API or BigQuery to
import catalogs.
Merchant Center Sync
Click
Import product catalog
to open the
Import Data
panel.
Choose
Product catalog
.
Select
Merchant Center Sync
as your data source.
Select your Merchant Center account. Check
User Access
if you don't see your account.
Optional: Select
Merchant Center feeds filter
to import only offers from selected feeds.
If not specified, offers from all feeds are imported (including future feeds).
Optional: To import only offers targeted to certain countries or languages, expand
Show Advanced Options
and select Merchant Center countries of sale and languages to filter for.
Select the branch you will upload your catalog to.
Click
Import
.
Cloud Storage
Click
Import product catalog
to open the
Import Data
panel.
Choose
Product catalog
as your data source.
Select the branch you will upload your catalog to.
Choose
Retail Product Catalogs Schema
as the schema.
Enter the Cloud Storage location of your data.
If you do not have search enabled, select the product levels.
You must
  select the product levels if this is the first time you are importing your catalog or you are
  re-importing the catalog after purging it.
Learn more
about product levels.
Changing
  product levels
after you have imported any data requires a significant effort.
Important:
You can't turn on search for projects with a
  product catalog that has been ingested as variants.
Click
Import
.
BigQuery
Click
Import product catalog
to open the
Import Data
panel.
Choose
Product catalog
.
Select
BigQuery
as your data source.
Select the branch you will upload your catalog to.
Choose one of the following schemas:
Retail Product Catalogs Schema
: the
Product schema for Vertex AI Search for commerce
Merchant Center
: the schema used to
bulk import from Merchant Center
Enter the BigQuery table where your data is located.
Optional: Under
Show advanced options
, enter the location of a
  Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
  Cloud Storage bucket have to be in the same region.
If you do not have search enabled and you are using
  the Merchant Center schema, select the product level.
You must
  select the product level if this is the first time you are importing your catalog or you are
  re-importing the catalog after purging it.
Learn more
about product levels.
Changing
  product levels
after you have imported any data requires a significant effort.
Important:
You can't turn on search for projects with a
  product catalog that has been ingested as variants.
Click
Import
.
Import your historical user events
To import your historical user events, complete the set of steps for your data source.
For more information on historical user events, see
Importing historical user events
.
Note:
You can also record real-time user events to generate recommendations and
search results. For more information, see
Recording real-time user events
.
Cloud Storage
Click
Import user events
to open the
Import Data
panel.
Choose
User events
.
Select
Google Cloud Storage
as the data source.
Choose
Retail User Events Schema
as the schema.
Enter the Cloud Storage location of your data.
Click
Import
.
BigQuery
Click
Import user events
to open the
Import Data
panel.
Choose
User events
.
Select
BigQuery
as the data source.
Select the data schema.
Google Analytics 4
: Use for Google Analytics 4 events.
Google Analytics 360
: Use for Google Analytics
        360 events, unless you are
importing events only home-page-views from Google Analytics 360
(in that case, use
Retail User Events Schema
).
Retail User Events Schema
: Use for importing events from sources other
        than Google Analytics and for
importing events only home-page-views from Google Analytics 360
.
Enter the BigQuery table where your data is located.
Optional: Enter the location of a Cloud Storage bucket in
   your project as a temporary location for your data.
If not specified, a default location is
   used. If specified, the BigQuery and Cloud Storage bucket have to be
   in the same region.
Optional: Under
Show advanced options
, enter the location of a
   Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
   Cloud Storage bucket have to be in the same region.
Click
Import
.
Create a serving config
A
serving config
is a serving entity that associates a model or a set of
controls that are used to generate your search or recommendation results.
Note:
Vertex AI Search for commerce creates a default serving config so this
procedure is optional if you want to create a custom serving config.
To create a serving config, complete the following steps:
In the
Serving configs
panel, click
Create serving config
.
On the
Create Serving Config
page, choose
Search
as the product the serving configuration
will be used for.
Provide a name for your serving configuration.
The name must be
1024 characters or less, and can contain only alphanumeric characters,
underscores, hyphens, and spaces.
Optional: If needed, update the ID.
The ID is generated from the
name you provide, and must be unique across your project. It must be 50
characters or less, and cannot contain spaces.
Click
Continue
.
Choose whether to enable dynamic faceting for this serving configuration.
Choose or create serving controls to optimize your searches with.
For more
information on controls, see
Creating and managing controls.
Manage resources and monitor activity
When you have completed your initial configuration of your project, the
Google Cloud console dashboard displays the system state of your
Vertex AI Search for commerce project. The console dashboard lets you manage resources and
monitor activity.
Go to the Search for commerce console
Create an API key
An API key is required if you use a JavaScript pixel or a Tag Manager tag
to capture user events from users' browsers. For more information about ways to
capture user events, see
Record real-time user events
.
To create an API key for calls to the
userEvents.Collect
method, complete the following steps:
Go to the
 Google Cloud console
Credentials
page.
In the project drop-down at the top of the Google Cloud console page, select
 your project (the project may already be selected).
Click
Create credentials
and then select
API key
.
Do not add any website application restrictions
. Some user privacy
 settings are known to
not
pass the referrer URL.
Take note of the generated API key, which you use when calling
  user event logging.
For increased security, add an
API restriction
to your API Key to restrict access to the Vertex AI Search for commerce service
 at
https://retail.googleapis.com/*
.
Note:
The API key is only for authenticating the
userEvents.Collect
method.
Other API methods require OAuth 2.0 through a service account or a
user account.
What's next
Restrict API keys
Authenticate to Vertex AI Search for commerce
Identity and Access Management (IAM)
Implementing Vertex AI Search for commerce
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-27 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/support.txt
Support  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Vertex AI search for commerce
All support
Get support
Billing questions
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Support
Send feedback
Support
Support
Get support
Where to find support when using Vertex AI Search for commerce.
Billing questions
Learn about resources for common billing questions.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/supported-languages.txt
Supported world languages  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Supported world languages
Search and recommendations both support the following world languages.
Search for commerce
Supported languages
Albanian
Korean
Arabic
Latvian
Armenian
Lithuanian
Assamesse
Macedonian
Azerbaijani
Malay
Basque
Marathi
Bengali (Bangla)
Mongolian
Bulgarian
Nepali
Burmese
Norwegian
Catalan
Odia
Chinese (simplified)
Persian
Chinese (traditional)
Polish
Croatian
Portuguese (Europe)
Czech
Portuguese (Brazil)
Danish
Punjabi
Dutch
Romanian
English
Russian
Estonian
Serbian
Finnish
Serbian (Cyrillic)
French (Europe)
Sinhala
French (Canada)
Slovak
Georgian
Slovenian
German
Spanish (Europe)
Greek
Spanish (Latin America)
Gujarati
Swahili
Hebrew
Swedish
Hindi
Tamil
Hungarian
Telugu
Icelandic
Thai
Indonesian
Turkish
Italian
Ukrainian
Japanese
Urdu (India)
Kannada
Urdu (Pakistan)
Kazakh
Uzbek
Khmer
Vietnamese
You set the language when you upload your catalog for your Vertex AI Search for commerce project. The catalog should be in one language only and search queries should be sent in the same language. Having multiple languages in the catalog degrades LLM performance.
Note:
If you already have a mixed language catalog for search, you can improve results by adding synonyms for search query terms. For example, add both Spanish and English synonyms. For information about synonyms, see
OnewaySynonymsAction
and
TwowaySynonymsAction
.
Recommendations
Most languages are supported. The model automatically detects the text language.
Language Name
Script Name
Afrikaans
Latin
Amharic
Ethiopic
Arabic
Arabic
Bulgarian
Cyrillic
Bulgarian
Latin
Bangla
Bangla
Bosnian
Latin
Catalan
Latin
Cebuano
Latin
Corsican
Latin
Czech
Latin
Welsh
Latin
Danish
Latin
German
Latin
Greek
Greek
Greek
Latin
English
Latin
Esperanto
Latin
Spanish
Latin
Estonian
Latin
Basque
Latin
Persian
Arabic
Finnish
Latin
Filipino
Latin
French
Latin
Western Frisian
Latin
Irish
Latin
Scottish Gaelic
Latin
Galician
Latin
Gujarati
Gujarati
Hausa
Latin
Hawaiian
Latin
Hindi
Devanagari
Hindi
Latin
Hmong
Latin
Croatian
Latin
Haitian Creole
Latin
Hungarian
Latin
Armenian
Armenian
Indonesian
Latin
Igbo
Latin
Icelandic
Latin
Italian
Latin
Hebrew
Hebrew
Japanese
Japanese
Japanese
Latin
Javanese
Latin
Georgian
Georgian
Kazakh
Cyrillic
Khmer
Khmer
Kannada
Kannada
Korean
Korean
Kurdish
Latin
Kyrgyz
Cyrillic
Latin
Latin
Luxembourgish
Latin
Lao
Lao
Lithuanian
Latin
Latvian
Latin
Malagasy
Latin
Maori
Latin
Macedonian
Cyrillic
Malayalam
Malayalam
Mongolian
Cyrillic
Marathi
Devanagari
Malay
Latin
Maltese
Latin
Burmese
Myanmar
Nepali
Devanagari
Dutch
Latin
Norwegian
Latin
Nyanja
Latin
Punjabi
Gurmukhi
Polish
Latin
Pashto
Arabic
Portuguese
Latin
Romanian
Latin
Russian
Cyrillic
Russian
English
Sindhi
Arabic
Sinhala
Sinhala
Slovak
Latin
Slovenian
Latin
Samoan
Latin
Shona
Latin
Somali
Latin
Albanian
Latin
Serbian
Cyrillic
Southern Sotho
Latin
Sundanese
Latin
Swedish
Latin
Swahili
Latin
Tamil
Tamil
Telugu
Telugu
Tajik
Cyrillic
Thai
Thai
Turkish
Latin
Ukrainian
Cyrillic
Urdu
Arabic
Uzbek
Latin
Vietnamese
Latin
Xhosa
Latin
Yiddish
Hebrew
Yoruba
Latin
Chinese
Han (including Simplified and Traditional)
Chinese
Latin
Zulu
Latin
For a list of all languages that can be automatically detected, see the Compact Language Detector
GitHub README
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/tiles.txt
Tile navigation  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Tile navigation
This page introduces the tile navigation feature of Vertex AI Search for commerce.
Why tiles?
As a visual representation of attribute value pairs, tiles are a different way to present the same information as dynamic facets, showing only the attributes that are most frequently engaged for a particular query independent of dynamic facet families that are not always intuitive for the shopper. The goal of this is to increase filter usage, which in turn increases revenue per user. Tile navigation makes filter usage on strong HEAD queries more relevant, facilitating more accurate revenue prediction (through regression).
Tile navigation functions as part of the Guided Search package, benefiting the customer by narrowing user queries faster and with greater relevance to the end user. The tile navigation feature was designed to solve the real estate problem of dynamic facets to allow the user to find what is likely more relevant to them more quickly. Tile navigation also prevents the shopper from having to forage through all the facet families in a left or right navigation pane to find exactly which product they are looking for before still having to confirm their narrowed search selection in a second click of a submit button.
Tile navigation complements dynamic facets
Dynamic facets
are provided in the Search for commerce console by uploading the catalog of products. They are filters that narrow queries by changing the order of filters shown so that the correct filters are on top and make the search return more relevant with each search turn.
Dynamic facets sort families of filters such as Style, Sleeve for a query dress for fashion retailers, or Volume, Variety, or Container for milk for grocery retailers. Often, these dynamic facet families are arranged in a way that is not always intuitive to the user. Additionally, a fly-out pane for dynamic facet selection takes up a lot of real estate on the product site and are likewise not always mobile friendly.
So a need emerged to reduce real estate on merchandise websites and drive up user revenue per search conversion.
How do tiles work?
Tile navigation gets the user to a narrower search faster to increase search engagement and revenue per search. Tiles can be displayed horizontally across the product site independent of facet families. The tiles feature controls search filters in such a way as to put the most likely engaged filters individually across the top of the page, breaking the search results out of their dynamic facet families to provide immediate visualization. This way, tile navigation offers users a more accessible arrangement of dynamic facets content.
Shopper journey
When a shopper performs a search on a retailer's website with tile navigation enabled, they will see up to 20 tiles displaying individual filter values that are most likely to be engaged. These tiles are sorted by likelihood of usage, independent of product attribute family. Each tile can include an image representing a typical product with the filter applied. If a customer clicks on a tile, it acts as if the corresponding facet-value has been applied. This updates the product list to match the query and filter, and the applied facet is shown. Additionally, the displayed tiles refresh to reflect the new expected engagement rate, excluding any filters that have already been applied.
Retailer journey
The retailer sends a query to Vertex AI Search for commerce and receives a standard query reply that includes a sorted list of tile values ranked across product attribute families and a way to generate a tile image. The retailer then renders the tiles with or without images. If a potential customer clicks on a tile or facet value, the retailer sends a new query to Google with the filter corresponding to the tile or facet added to the filter field. The retailer site also sends Google an event for the second query with the filter added. The Vertex AI Search for commerce response, the query sent to Google, and the events sent to Google are the same for both "user clicked on filter" and "user clicked on tile."
Filters shown in tiles
Filters can be eligible for tiling based on preferences retailers can set in the Search for commerce console or the Vertex AI Search for commerce API for content, product counts, and related to quantitative queries.
Based on content
Filters cannot have been applied in a previous search.
Only tiles that correspond to attribute values in catalog attributes marked as dynamically facetable.
The search return (the Vertex AI Search for commerce response) must have at least one product.
No tiles corresponding to system filters such as "instock = yes" or "available for sale = yes" are shown.
Tiles are sorted by likelihood of engagement.
Based on product counts
What if there are < 20 rankable tiles?
If there are between >= 2 and < 20, return as many tiles as possible.
If there are < 2 tiles available, return no tiles.
If > 20 rankable tiles, return the top 20 based on the likelihood of engagement.
Based on quantitative queries
Tiles support both "categorical" (color = red) and numerical (weight = "1lb - 2lb").
Bucketing of numeric tiles:
The bucketing configured using controls for specific attributes is honored. For example, if a facet is manually bucketed into weights of 0-1, 1-3 lbs, and 3-6 lbs, those buckets are used in the tiles. More details can be found in
Dynamic facet and tile controls
.
If a facet is auto-bucketed, the same buckets should be used in tiles.
What's new for tile navigation in the Retail API?
There is no new API for the tiles feature. However, new fields have been added to the already existing Vertex AI main (query) API.
Request tileNavigationSpec
Query
{
"tile_navigation_requested"
:
boolea
n
,
"applied_tiles"
:
repea
te
d
}
Fields (request)
tile_navigation_requested
This boolean field specifies whether the customer would like to request tile navigation.
applied_tiles
This repeated field specifies the tiles which are already clicked.
First, set the
tileNavigationSpec
field. Call the object
productAttributeValue
which contains the attribute name and value, such as
name=color
and
value=red
. Leave all other fields the same.
Response tileNavigationResult
The API then returns up to 20 tiles in the
tileNavigationResult
field, sorted by likelihood of use. The response displays the tiles according to their attribute values and a corresponding representative image:
Response
...
"tileNavigationResult"
:
{
"tiles"
:
[
{
"productAttributeValue"
:
{
"name"
:
"sizes"
,
"value"
:
"large"
},
"representativeProductId"
:
"xxxx"
},
{
"productAttributeValue"
:
{
"name"
:
"attributes.weight"
,
"value"
:
"light"
},
"representativeProductId"
:
"xxxx"
},
{
"productAttributeValue"
:
{
"name"
:
"colors"
,
"value"
:
"black"
},
"representativeProductId"
:
"xxxx"
}
]
}
...
Fields (response)
tiles
This repeated field drives the tiles that are shown to the user on the client side. The field contains a list of tiles, where each tile is an object which contains the
productAttributeValue
and the
representativeProductId
.
No changes are needed to the existing API, and new client libraries are available at GA time and are published in the
public library documentation
.
What retailers should do with tiles search results
Showing tiles:
Show the returned tiles in the order provided, with the first tile in the response being the first tile shown.
ProductAttributeValue
is a key-value pair which contains the attribute value, so that you know which tiles to show. In the subsequent search requests, the
ProductAttributeValue
should be set in the
appliedTiles
field and also it should be set in the
filter
field (e.g.,
filter = "attributes.weight:ANY(\"large\")"
). The response will then have filtered products and a new set of tiles to show.
Showing images:
These images can be obtained by referencing the
representativeProductId
field in the response, which provides the product ID of a typical product that matches the applied filter. Retailers then look up this representative product ID on their end and select an appropriate image to display in the tile. It's important to use the representative product ID, rather than the primary product ID, to ensure the image accurately reflects the filtered attribute (e.g., displaying a red variant for the
color = "red"
filter).
Configure tile behavior in the console
The selection of tiles to appear across the search screen are directly driven by the catalog attributes, which in turn are extracted from the information the retailer uploads to the product catalog. The candidate tiles are all values within the attributes of all the "dynamically facetable attributes" in the product catalog.
Enable dynamic facets and tiling
Facets are controlled by product attributes, which originate from the Catalog and User Events. Dynamic faceting and tiling is set up to allow end user queries to match product attributes.
To control which attributes are eligible for dynamic facets and tiles:
Set your tile controls under the
Attribute Controls
tab in the Controls page in the Search for commerce console.
Go to the Controls page
To modify the attribute controls, click
edit
Modify controls
next to
Attributes
, then set the controls for each attribute to
True
or
False
.
The third and fourth columns (
Indexable
and
Dynamic faceting
) are key in controlling the tiles. For each attribute row, both of these columns must be marked
True
for tiles to work.
Indexable
enables Vertex AI Search for commerce to filter using the attribute. With
Dynamic faceting
enabled, Vertex AI Search for commerce can automatically use an attribute as a dynamic facet based on past user behavior such as facet clicks and views.
To see how to do this in the API, refer to
Tile control in the API
section.
Individual tile controls
Facet controls let you manage the behavior of your facets without changing your catalog and impact search behavior across your site.
The
Remove facets
control removes an entire facet from the results for dynamic facets for certain queries. It also removes member tiles of this facet from being returnable as tiles.
The following facet
value
controls flagged with
Dynamic faceting & tiling
at the catalog level likewise impact tiles:
Ignore facet values
: Suppresses the tile from appearing as well as removes the dynamic facet in the search results.
Replace facet values
: Lets the retailer change the facet value (for example, for the attribute
color
, change
navy blue
to
blue
) for specific queries in both tiles and dynamic facets.
Set numerical intervals
: Allows the retailer to specify bucket sizes to output a search response in a given dynamic range, both in dynamic facets and tiles.
The last three dynamic facet control types in the scroll-down menu of facet control types controls don't impact tiles:
Force return facets
Rerank dynamic facets
Merge facets
For more information on controlling specific facet value and tile behavior on each control, refer to
Facet controls
.
Tile control in the API
This section describes how to control tile behavior in the Vertex AI Search for commerce API.
Attribute controls
For search and recommendations, you'll find the API at the catalog level under the REST resource Resource: projects.locations.catalogs.attributesConfig. This API provides methods to add, remove, and replace attributes at both the catalog and product level. The field
catalogAttributes
can be mapped to indexable, searchable, and
dynamicFacetable
.
dynamicFacetable
applies to tile behavior if the facets are
eligible for tiling
.
AttributesConfig
Catalog level attribute config.
Tile-relevant field
catalogAttributes
map
Enables attributes config at the catalog level, which contains information about whether it is searchable, dynamically facetable, and more, by mapping the name of an attribute to a value, which is a callable object,
CatalogAttribute
.
CatalogAttribute
The
attributesConfig
resource provides
CatalogAttribute
, a catalog-level object. Two of this object's fields generate controls over which attributes show up as tiles. This means that any attributes in all the "facetable attributes" of the product catalog can be candidates for tiling:
Tile-relevant fields
DynamicFacetableOption
enum
global control field that must be specified as enabled or disabled. This turns dynamic facets on or off, which in turn drives tiles. This one is set under Attribute controls in the Google Cloud console.
facetConfig
object which contains options for individual facet values. This field is a facet control.
Facet controls
FacetConfig
An object that contains facet options for making individual facet values dynamic and thus potentially tileable. It is a field from the catalog level
CatalogAttribute
config.
The object contains already existing fields whose impact now extends to tiles:
JSON Example
"facetIntervals"
:
[
{
objec
t
(I
nter
val)
}
],
"ignoredFacetValues"
:
[
{
objec
t
(Ig
n
oredFace
t
Values)
}
]
Tile-relevant fields
ignoredFacetValues
This message field in the
FacetConfig
contains facet values to ignore for the current attribute name for a given time range and only in the facet without affecting the product descriptions in the catalog.
facetIntervals
This allows the retailer to specify bucket sizes for a numerical input. This should work the same way for tiles- if a retailer sets specific numerical intervals for a dynamic facet, it should use the same numerical intervals for tiles.
removeFacetValue
Removes facet values for specific facet keys. These are mapped to attribute values.
See how to
create these individual controls in the console
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/upload-catalog.txt
Import catalog information  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
Import catalog information
This page describes how to import your catalog information and keep it up to
date.
The import procedures on this page apply to both recommendations
and search. After you import data,
both services are able to use that data, so you don't need to import the same
data twice if you use both services.
You can import your product data from
BigQuery
or
specify the data inline
in the request
. Each of these procedures are one-time imports with
the exception of
linking Merchant Center
. Schedule
regular catalog imports (ideally, daily) to verify that your catalog is current.
See
Keep your catalog up to date
.
You can also import individual product items. For more information, see
Upload a product
.
Deprecated:
The Merchant Center connector is deprecated and only
available to current users. New users must use the Catalog API or BigQuery to
import catalogs.
Before you begin
Before you begin importing your catalog, you must:
Set up your project.
Create a service account.
Add the service account to your local environment.
Refer to
Setup prerequisites
for more information.
Important:
You must also have the Retail Admin IAM role to perform the import.
Catalog import considerations
This section describes the methods that can be used for batch importing of your
catalog data, when you might use each method, and some of their
limitations.
BigQuery
Description
Import data from a previously loaded BigQuery table that
      uses the Vertex AI Search for commerce schema. Can be performed using the
      Google Cloud console or curl.
When to use
If you have product catalogs with many attributes. BigQuery
      import uses the Vertex AI Search for commerce schema, which has more product
      attributes than other import options, including key/value custom
      attributes.
If you have large volumes of data. BigQuery import does not
      have a data limit.
If you already use BigQuery.
Limitations
Requires the extra step of creating a BigQuery table that
      maps to the Vertex AI Search for commerce schema.
Cloud Storage
Description
Import data in a JSON format from files loaded in a Cloud Storage
      bucket. Each file must be 2 GB or smaller and up to 100 files at a time
      can be imported. The import can be done using the Google Cloud console
      or curl. Uses the
Product
JSON data format, which allows
      custom attributes.
When to use
If you need to load a large amount of data in a single step.
Limitations
Not ideal for catalogs with frequent inventory and pricing updates
      because changes are not reflected immediately.
Inline import
Description
Import using a call to the
Product.import
method. Uses
      the
ProductInlineSource
object, which has fewer product
      catalog attributes than the Vertex AI Search for commerce schema, but supports custom
      attributes.
When to use
If you have flat, non-relational catalog data or a high frequency of
      quantity or price updates.
Limitations
No more than 100 catalog items can be imported at a time. However, many
      load steps can be performed; there is no item limit.
Tutorials
This section explores different catalog import methods with a video and shell tutorials.
Video tutorial
Watch this video to learn how to import a catalog using the Retail API.
Import catalog from BigQuery tutorial
This tutorial shows you how to use a BigQuery table to import
large amounts of catalog data with no limits.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Import catalog from Cloud Storage tutorial
This tutorial shows you how to to import a large number of items to a catalog.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Import catalog data inline tutorial
This tutorial shows how to to import products into a catalog inline.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
Catalog import best practices
High-quality data is needed to generate high-quality results. If your data is
missing fields or has placeholder values instead of actual values, the quality
of your predictions and search results suffers.
When you import catalog data, make sure that you implement the following best
practices:
Make sure to carefully distinguish primary from variant products. Before you upload any data,
see
Product levels
.
Change product level configuration
after expending any significant effort importing data. Primary — not variant — items are returned as search results or recommendations.
Example: If the primary SKU group is
V-neck shirt,
then the
recommendation model returns a V-neck and, perhaps, crew- and
scoop-neck shirts. However, if variants aren't used
and each SKU is a primary, then every color or size combination of V-neck shirt
is returned as a distinct item on the recommendation panel:
Brown V-neck
shirt, size XL, Brown V-neck shirt, size L,
to
White V-neck
shirt, size M, White V-neck shirt, size S.
Collections can be recognized together as long variant IDs are included along with the primary product IDs in
collectionMemberIds[]
. This causes a product collection, from which a user can have purchased one or more products in the set, to be captured in the user event, crediting the whole set to the purchase. This facilitates serving the same user other products in a given collection in a future related query.
Example: A user previously purchased a duvet cover, so matching products in a bedsheet collection, such as pillowcases, are returned.
Observe the product item import limits.
For bulk import from Cloud Storage, the size of each file must be

2 GB
 or smaller. You can include up to

100
 files at a time in a single bulk import request.
For inline import, import no more than 5,000 product items at a time.
Make sure that
required catalog information
is
included and correct. Don't use placeholder values.
Include as much optional catalog information as possible.
Make sure your events all use a single currency, especially if you plan to use
Google Cloud console to get revenue metrics. The Vertex AI Search for commerce API does not support using
multiple currencies per catalog.
Keep your catalog up to date, ideally every day. Scheduling periodic catalog
imports prevents model quality from going down over time. You can schedule
automatic, recurring imports when you import your catalog using the
Search for commerce console. Alternatively, you can use
Google Cloud Scheduler
to automate imports.
Don't record user events for product items that have not been imported yet.
After importing catalog information, review the
error reporting and logging
information
for your project. If you find more than a few
errors, review them, fixing any process issues that led to the errors.
The
Vertex AI Search for commerce
data ingestion pipeline encompasses both product catalog and user event data. This data stream provides the foundation for robust model training and continuous evaluation through feedback mechanisms. Accurate and complete data ingestion is not just a prerequisite, it's an ongoing process essential for maintaining the adaptability of the underlying models. This, in turn, directly influences the quality and relevance of search results, offering significant returns on investment.
Consider these data ingestion best practices when architecting your commerce search solution.
Bulk import, real-time streaming, or both?
Vertex AI Search for commerce offers two primary methods for catalog ingestion:
Bulk import
Real-time streaming
This dual approach accommodates the diverse architectural needs of various customer backends. There's no requirement to exclusively choose one method; a hybrid ingestion mode can be employed, using both bulk import and streaming updates based on specific requirements.
Bulk imports are ideal when dealing with large-scale additions, deletions or updates to thousands of products at once. In contrast, real-time streaming excels when continuous updates are needed for a relatively smaller volume of products. The choice between these methods hinges on the nature of your product catalog, the frequency of updates, and the overall architecture of your backend systems.
The
bulk import functionality
supports three distinct data sources:
BigQuery
: BigQuery facilitates fast modification of catalog data, enables the specification of partition dates during import, and allows for efficient data transformation through SQL queries.
Google Cloud Storage
: Cloud Storage necessitates adherence to specific formats, such as JSON, and file restrictions. Users are responsible for managing bucket structures, file chunking, and other aspects of the import process. Furthermore, directly editing the catalog within Cloud Storage can be cumbersome, and while potentially cost-effective, it lacks the flexibility of other methods.
Inline data
: For extensive catalogs, inline imports may not be the most scalable option due to size limitations. Reserve their use for minor updates or experimental testing.
For scenarios involving a high volume of product catalog updates (thousands of product changes, additions, or deletions) within a short timeframe and at regular intervals, a combined approach of bulk imports and real-time streaming can be highly effective. Stage the updates in BigQuery or Cloud Storage and perform incremental bulk imports at regular intervals, such as every hour or two. This method efficiently manages large-scale updates while minimizing disruptions.
For smaller, less frequent updates or those requiring immediate reflection in the catalog, use the real-time streaming API. In the hybrid approach, real-time streaming can fill the gaps between bulk imports, ensuring your catalog remains current. This strategy strikes a balance between making individual REST API calls (for patching products) and performing bulk changes, optimizing both efficiency and responsiveness in your Vertex AI Search for commerce catalog management.
Branching strategies for catalog management
Maintain a unified catalog within a single branch rather than having disparate catalogs across multiple branches. This practice streamlines catalog updates and reduces the risk of inconsistencies during branch switching.
The following common branching strategies are effective for catalog management.
Single branch updates
Designate a live branch as the default and continuously update it as catalog changes occur. For bulk updates, use the import functionality during periods of low traffic to minimize disruptions. Utilize streaming APIs for smaller, incremental updates or batch them into larger chunks for regular imports.
Branch switching
There are a couple of choices to manage different branches:
Use branches for staging and verification:
Some commerce site engineers opt for a branch switching approach, where the catalog is updated within a non-live branch and then made the default (live) branch when ready for production. This enables preparation of the next day's catalog in advance. Updates can be made using bulk import or streaming to the non-live branch, ensuring a seamless transition during low traffic times.
The choice between these strategies depends on your specific requirements, update frequency, and infrastructure setup. However, regardless of the chosen strategy, maintaining a unified catalog within a single branch is crucial for optimal performance and consistent search results in Vertex AI Search for commerce.
Use branches for backups:
A single live branch focuses on continuous ingestion and processing of product updates to keep the Vertex AI Search for commerce index up-to-date in near real-time.
Another branch focuses on creating a daily snapshot of the transformed data in Retail Search, acting as a robust fallback mechanism in case of data corruption or issues with branch 0.
A third branch focuses on creating a weekly snapshot of the transformed date. This way the customer can have a day old backup and a week old backup in different branches.
Purge catalog branches
If you're importing new catalog data to an existing branch, it's important
that the catalog branch is empty for the integrity of data imported to
the branch. When the branch is empty, you can import new catalog data, and
link the branch to a merchant account.
If you are serving live predict or search traffic and plan to purge your default
branch, consider first specifying another branch as the default before purging.
Because the default branch will serve empty results after being purged, purging
a live default branch can cause an outage.
To purge data from a catalog branch, complete the following steps:
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Select a catalog branch from the
Branch name
field.
From the three-dot menu beside the
Branch name
field, choose
Purge
branch
.
A message is displayed warning you that you are about to delete all data in
the branch as well as any attributes created for the branch.
Note:
You can't undo a catalog branch data purge.
Enter the branch and click
Confirm
to purge the catalog data from the
branch.
A long-running operation is started to purge data from the catalog branch.
When the purge operation is complete, the status of the purge is displayed in
the
Product catalog
list in the
Activity status
window.
Note:
The list of the branch's catalog data is not automatically refreshed after
the purge completes. You must refresh the page to see an updated list
for the branch.
Inventory updates in Vertex AI Search for commerce
This section describes how to optimize Vertex AI Search for commerce performance by performing regular inventory updates.
Real-time streaming
For dynamic data such as inventory information (price, availability) and store-level details, including fulfillment status and store-specific pricing, real-time streaming is the sole option within Vertex AI Search for commerce.
This distinction arises due to the high-frequency nature of inventory fluctuations compared to the relatively static product catalog data. Product availability can change multiple times daily, while descriptions or attributes remain relatively constant.
The frequency of store-level updates further amplifies with the number of retail locations.
Asynchronous updates
To accommodate this rapid pace of change, Vertex AI Search for commerce employs asynchronous inventory updates using APIs that return a job ID.
The update process is not considered complete until the job status is polled and confirmed, potentially introducing a minor delay ranging from seconds to minutes.
Out of order updates
A notable feature of this system is the ability to update inventory information before the corresponding product is ingested into the catalog. This addresses the common scenario where inventory and product data pipelines operate independently within retailers, sometimes leading to inventory information becoming available before the product catalog is updated. When updating the inventory use the
allowMissing
option to handle out of order updates of inventory versus product.
By allowing inventory updates to precede catalog ingestion, Vertex AI Search for commerce accommodates these pipeline discrepancies, ensuring accurate inventory data is available even for newly introduced products.
However, inventory information for a product is retained for 24 hours and will be purged if a matching product is not ingested within that window. This mechanism ensures data consistency and prevents outdated inventory information from persisting in the system.
Product catalog prechecks for robust A/B testing in Vertex AI Search for commerce
This section covers how to run prechecks on the product catalog data.
Ensure consistent catalog updates parity
In preparation for an
A/B test
within Vertex AI Search for commerce, maintaining strict parity between the legacy (control) catalog and the Vertex AI Search for commerce (test) catalog is crucial. Any imbalances between the two can negatively impact the
A/B test
, leading to skewed observations and potentially invalid results. For example, inconsistencies in product availability, pricing, or even minor attribute discrepancies can introduce unintended biases into the test data.
To mitigate this risk, it's imperative to design a parallel update process for both the control and test catalogs, avoiding sequential updates whenever feasible. The goal is to maximize the time during which both catalogs are in sync. Serial updates, on the other hand, can introduce delays in one lane or the other. These delays can result in temporary catalog mismatches, where a product may be in stock in one catalog but not the other. Or, a newly added product appears in one catalog sooner than the other. Such disparities can significantly influence user behavior, clicks, and purchases, ultimately leading to an unfair comparison and inaccurate A/B test outcomes.
By prioritizing parallel updates and striving for consistent catalog parity, retailers can ensure a level playing field for A/B testing within Vertex AI Search for commerce. This approach enables unbiased and fair analysis of the test results, leading to more reliable insights and informed decision-making.
Achieve catalog data parity
The depth and accuracy of an ecommerce search model's product comprehension hinges on the richness and quality of its underlying product catalog information. The more comprehensive the product data within the catalog, the better equipped the model is to understand and classify products effectively.
So in preparation for A/B testing, it's imperative to ensure that the product data uploaded to both the legacy (control) catalog and the Vertex AI Search for commerce (test) catalog are identical. Any discrepancies in product information between these two environments can significantly bias the A/B test results.
For example, if the legacy search engine benefits from a richer or more extensive catalog compared to Vertex AI Search for commerce, this creates an unfair advantage. Missing information in the Vertex AI Search for commerce catalog could be critical for product understanding and classification, potentially leading to inaccurate search results and misleading performance comparisons. Detecting such disparities can be challenging with external tools and often requires meticulous manual inspection of both catalogs.
By diligently ensuring that both catalogs contain the same product data with the same level of detail, retailers can create a level playing field for A/B testing in Vertex AI Search for commerce. This approach fosters a fair and unbiased comparison of the two search engines, facilitating accurate evaluation of their respective performance and capabilities.
Disaster recovery planning
A well-prepared disaster recovery plan ensures that your commerce search capabilities remain operational and responsive, minimizing the impact on customer experience and revenue generation. This plan should enable swift restoration of the catalog to address the potential failure of catalog and user event ingestion pipelines, regardless of the underlying cause.
Using BigQuery for data staging offers a distinct advantage in disaster recovery. If the current catalog or user event data within Vertex AI Search for commerce is not significantly different from the most recent snapshot stored in BigQuery, calling the import API can initiate a rapid restoration. This approach minimizes downtime and ensures the search functionality remains operational.
Conversely, if BigQuery is not integrated into your data pipeline, alternative mechanisms must be in place to expeditiously reload the catalog from a known good state. These mechanisms might involve backup systems, data replication, or other failover strategies.
By incorporating these disaster recovery considerations into your Vertex AI Search for commerce architecture, you can bolster the system's robustness and maintain business continuity even in the face of unexpected disruptions.
Plan for high availability
When you upload your product catalog to Vertex AI Search, it's important to consider how different Google Cloud services handle regionality to design a resilient data ingestion pipeline.
To build a disaster recovery-capable ingestion pipeline using Dataflow, deploy your jobs in multiple regions using one of the following designs:
Active/active:
Dataflow instances in multiple regions actively process data concurrently.
Active/passive:
A Dataflow instance in one region is active, while instances in other regions remain on standby.
Here's how to implement these designs with Pub/Sub and Dataflow:
Global services:
Some services, such as
Pub/Sub
, operate globally. Google Cloud manages their availability according to their specific Service Level Agreements (SLAs).
Regional services:
Other services, like
Dataflow
, which you might use to transform and ingest data into Vertex AI Search, are regional. You are responsible for configuring these components for high availability and disaster recovery.
For example, when leveraging BigQuery for persisting data, it can be configured to be multi-regional so that data redundancy and availability is automatically handled by Google Cloud. Similarly when using Cloud Storage, it can be configured to be multi-regional.
Active/active design
Active/active design uses Pub/Sub message attributes and subscription filters to ensure each message is processed exactly once by an active Dataflow job in a specific region.
Add message attributes
: When publishing messages to the Pub/Sub topic, such as product updates, include an attribute indicating the target region. For example:
region
:
us-central1
region
:
us-east1
Configure subscription filters
: For each regional Dataflow pipeline, configure its Pub/Sub subscription to pull only messages matching its region using
message filters
. For example, the subscription for the
us-central1
Dataflow job would have a filter like
attributes.region = "us-central1"
.
Failover
: If a region becomes unavailable, update your upstream publishing system to tag all new messages with an attribute for a healthy region. This reroutes message processing to the Dataflow instance in the failover region.
Multiple components used in the architecture can be configured to be multi regional by default. For example, when leveraging BigQuery for persisting data, it can be configured to be multi-regional so that data redundancy and availability is automatically handled by Cloud Storage, Similarly when using Cloud Storage, it can be configured to be multi-regional.
Active/passive design
This design involves having only one regional Dataflow pipeline actively pulling messages from Pub/Sub at any time.
Attach one subscription
: Ensure only the Pub/Sub subscription for the
active
region's Dataflow job is attached and pulling messages. Subscriptions for Dataflow jobs in passive regions should be created but remain detached.
Failover
: If the active region experiences a failure, manually or programmatically:
Detach the Pub/Sub subscription associated with the failed region's Dataflow job.
Attach the Pub/Sub subscription associated with a Dataflow job in one of the passive (standby) regions.
This transfers the message processing load to the newly activated region.
Resilience and forensics
Using BigQuery in the design for the data ingestion can result in handling resiliency and creating capability for forensics and debugging. Products and inventory ingested directly with the
patch
and
addLocalInventory
API implies that when the data is sent to Vertex AI Search for commerce, there isn't any trail left of the product and inventory update. Your user might want to know why a product is not showing up as they expect it to. Having a staging area built with BigQuery with a complete history of data facilitates this kind of investigation and debugging.
Reference architecture
In this architecture, the data ingestion would typically have raw, curated and consumption stages all built on BigQuery. The system would move data in between the stages using Dataflow and orchestrate to automate all of this using cloud workflows:
The system would take raw data as it is and time tag it to maintain history. This data is unchanged so customers would consider it as a true source.
Then the system would transform the data into a curated stage and time tag it again. This way customers would know when it transformed and if anything failed.
Finally the system would create views in the consumption stage on the curated data using the time the system tagged the data with earlier. This way customer would know exactly which transformed data is supposed to be finally ingested into Vertex AI Search for commerce.
Branch 0 and branch 1 and branch 2 serve as live and day old backup and a week old back branches. Data ingested directly into branch 0 gets aggregated and indexed into branch 1 daily and branch 2 weekly. This way any corruption of data can be rolled back thereby enhancing the business continuity and system resilience.
Furthermore, analysis and debugging can be achieved as the entire history and lineage of the data is maintained in global BigQuery datasets.
Plan for corner cases with catalog ingestion
As soon as the core mechanisms for catalog ingestion in Vertex AI Search for commerce are established, a proactive approach involves assessing their resilience against various corner cases. While some of these scenarios might not be immediately relevant to your specific business requirements, factoring them into your backend design can provide invaluable future-proofing.
This preparatory step entails reviewing your data pipeline's ability to handle unexpected or edge-case scenarios, ensuring its robustness and adaptability to evolving demands. By anticipating potential challenges and addressing them proactively, you can mitigate future disruptions and maintain the seamless flow of product data into your retail search system.
To achieve this, the Dataflow logic should be built such that it:
Validates each item of the raw data to match a proper schema.
The contract of the raw data should be determined upfront and every data element should be always matched against the contract. In case of validation failure, the raw data element should be time tagged and persisted in the BigQuery failed raw tables with actual errors that are meant for forensics.
Examples of such failure could be:
A certain attribute that is not part of the contract all of a sudden, appears in the raw data element.
A certain mandatory attribute is not present in the raw data element.
Validates each item of the raw data for transformation into Vertex AI Search for commerce format.
There are some mandatory fields required by the Vertex AI Search for commerce for product ingestion. Every element of the raw data should now be checked again if it can be successfully transformed into Vertex AI Search for commerce schema format. In case of transformation failure, the raw data element should be time tagged and persisted in the BigQuery failed curated tables with actual error messages that can assist with forensics.
Examples of such failure could be:
A certain attribute like price cannot be formatted into a number because raw data element has it is as alphanumeric.
The product name is completely missing.
This example shows a sample BigQuery table schema to persist all failures for debugging:
View sample BigQuery table schema
[
{
"mode"
:
"REQUIRED"
,
"name"
:
"ingestedTimestamp"
,
"type"
:
"TIMESTAMP"
},
{
"mode"
:
"REQUIRED"
,
"name"
:
"payloadString"
,
"type"
:
"STRING"
},
{
"mode"
:
"REQUIRED"
,
"name"
:
"payloadBytes"
,
"type"
:
"BYTES"
},
{
"fields"
:
[
{
"mode"
:
"NULLABLE"
,
"name"
:
"key"
,
"type"
:
"STRING"
},
{
"mode"
:
"NULLABLE"
,
"name"
:
"value"
,
"type"
:
"STRING"
}
],
"mode"
:
"REPEATED"
,
"name"
:
"attributes"
,
"type"
:
"RECORD"
},
{
"mode"
:
"NULLABLE"
,
"name"
:
"errorMessage"
,
"type"
:
"STRING"
},
{
"mode"
:
"NULLABLE"
,
"name"
:
"stacktrace"
,
"type"
:
"STRING"
}
]
Stress testing and scalability
Prepare for high-volume events and growth with stress testing and scalability.
High-traffic events
High-traffic events like holidays pose a significant challenge to data ingestion pipelines. The surge in inventory updates, including stock levels and prices, and potential changes to product attributes demand robust infrastructure. It's important to assess whether your ingestion system can handle this increased load. Simulated load testing, replicating peak traffic patterns, identifies bottlenecks and ensure smooth operation during these critical periods.
Flash sales
Flash sales introduce a unique challenge due to their short duration and rapid inventory fluctuations. Ensuring real-time inventory synchronization is paramount to prevent discrepancies between search results and actual availability. Failure to do so can lead to negative customer experiences, such as popular products appearing as in-stock when they're actually sold out, or the other way around. Additionally, price changes during flash sales can significantly impact product ranking, highlighting the need for accurate and timely price updates in the search index.
Catalog expansion
Business growth or product line expansions can result in a dramatic increase, such as 5x or 10x, in the number of products within your catalog. Your ingestion architecture must be scalable to accommodate this growth seamlessly. This can necessitate revisiting the entire ETL (extract, transform, load) pipeline, particularly if new data sources or product information formats are introduced.
By proactively addressing these potential scenarios, you can ensure that your Vertex AI Search for commerce ingestion pipeline remains robust, scalable, and responsive, even in the face of sudden traffic spikes, flash sales, or significant catalog growth. This proactive approach safeguards the accuracy and reliability of your search results, contributing to a positive user experience and driving business success.
The data ingestion pipeline performance should be evaluated and a baseline should be formed for the following metrics:
How long does it take to publish and ingest the entire catalog and inventory data? This may be required on an ad hoc basis during BFCM when prices can changes significantly for the entire catalog.
How long will a single product update will take to get reflected?
What is the highest rate of product and inventory updates that the system can churn?
Bottlenecks
Evaluate and find out whether the pipelines are able to scale up and down correctly.
Determine whether the max ceiling for the numbers of instances is too high or too low.
Determine whether the system is getting rate limited by Vertex AI Search for commerce by checking for HTTP Code 429.
Confirm whether certain API quotes need to be increased to reduce the rate limits.
Product data structure for catalog ingestion
This section describes how to prepare your product data for catalog ingestion.
Primary products
Primary products serve as containers for grouping variant products and as entries in the search grid. Have only common attributes shared across variants specified for primary products. These include:
Primary product ID
Product ID (identical to primary product ID)
Title
Description
Refer to
About product attributes
for more information.
Variant products
Variant products inherit common attributes from the primary product, but can also specify unique values.
Required attributes include:
All attributes specified for primary products (title, description). Price, title, and description can be different from the primary product.
Specific variant attributes (color, size, and other relevant product variations).
Refer to
About product attributes
for more information.
Attribute retrieval
The retrieval process considers all searchable attributes for both primary and variant products.
Relevance scoring
Relevance scoring is based solely on the title and description fields. To safeguard proper differentiation, slightly modify variant from primary product titles (for example,
Product Name + Color
).
Variant matching in search results
Variant matching (for example,
blue dress
) filters results based on predefined variant attributes like color and size. The search results return up to five matching variants for each primary product.
Sync Merchant Center to Vertex AI Search for commerce
Deprecated:
The Merchant Center connector is deprecated and only
available to current users. New users must use the Catalog API or BigQuery to
import catalogs.
Merchant Center
is a tool you can use to make your
store and product data available for Shopping ads and other Google services.
For continuous synchronization between Merchant Center and
Vertex AI Search for commerce, you can link your Merchant Center account
to Vertex AI Search for commerce.
When you set up a Merchant Center sync for Vertex AI Search for commerce, you must have the
Admin
IAM role assigned in Merchant Center. Although a Standard access role will permit you to read the Merchant Center feeds, when you try to sync Merchant Center to Vertex AI Search for commerce, you get an error message. So before you can successfully sync your Merchant Center to Vertex AI Search for commerce, upgrade your role.
Link your Merchant Center account
While Vertex AI Search for commerce is linked to the Merchant Center
account, changes to your product data in the Merchant Center
account are automatically updated within minutes in Vertex AI Search for commerce.
If you want to prevent Merchant Center changes from being synced
to Vertex AI Search for commerce, you can unlink your
Merchant Center account.
Unlinking your Merchant Center account
doesn't delete
products in Vertex AI Search for commerce. To delete imported products, see
Delete product information
.
To sync your Merchant Center account, complete the following
steps.
Sync your Merchant Center account
Cloud console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
Product catalog
.
Select
Merchant Center Sync
as your data source.
Select your Merchant Center account. Check
User Access
if you don't see your account.
Optional: Select
Merchant Center feeds filter
to import only offers from selected feeds.
If not specified, offers from all feeds are imported (including future feeds).
Optional: To import only offers targeted to certain countries or languages, expand
Show Advanced Options
and select Merchant Center countries of sale and languages to filter for.
Select the branch you will upload your catalog to.
Click
Import
.
curl
Check that the
service account in your local environment
has access to both the Merchant Center account and
Vertex AI Search for commerce. To check which accounts have access to your
Merchant Center account, see
User access for Merchant Center
.
Use the
MerchantCenterAccountLink.create
method to establish the link.
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"merchantCenterAccountId":
MERCHANT_CENTER_ID
,
"branchId": "
BRANCH_ID
",
"feedFilters": [
{"dataSourceId":
DATA_SOURCE_ID_1
}
{"dataSourceId":
DATA_SOURCE_ID_2
}
],
"languageCode": "
LANGUAGE_CODE
",
"feedLabel": "
FEED_LABEL
",
}'
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/merchantCenterAccountLinks"
MERCHANT_CENTER_ID
: The ID of the
Merchant Center account.
BRANCH_ID
: The ID of the branch to establish the link
with. Accepts values '0', '1', or '2'.
LANGUAGE_CODE
: (OPTIONAL) The two-letter language code of
the products you want to import. As seen in
Merchant Center under
Language
column of the
product. If not set, all languages are imported.
FEED_LABEL
: (OPTIONAL) The
feed label
of the products you want to import. You can see the feed label in
Merchant Center in the product's
Feed Label
column product. If not set, all feed labels are imported.
FEED_FILTERS
: (OPTIONAL) List of
primary feeds
from which products will be
imported. Not selecting feeds means that all
Merchant Center account feeds are shared. The IDs
can be found in
Content API datafeeds resource
or by
visiting Merchant Center, selecting a feed and
getting the feed ID from the
afmDataSourceId
parameter in
the site URL. For example,
mc/products/sources/detail?a=
MERCHANT_CENTER_ID
&afmDataSourceId=
DATA_SOURCE_ID
.
To view your linked Merchant Center, go to the
Search for commerce console
Data
page and click the
Merchant Center
button on the top right of the page. This opens the
Linked Merchant Center
Accounts
panel. You can also add additional Merchant Center
accounts from this panel.
See
View aggregated information about your catalog
for
instructions on how to view the products that have been imported.
List your Merchant Center account links
Cloud console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click the
Merchant Center
button on the top right of the page to open
a list of your linked Merchant Center accounts.
curl
Use the
MerchantCenterAccountLink.list
method
to list the links resource.
curl
-X
GET
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/merchantCenterAccountLinks"
Unlink your Merchant Center account
Unlinking your Merchant Center account stops that account from
syncing catalog data to Vertex AI Search for commerce. This procedure does not
delete any products in Vertex AI Search for commerce that have already been
uploaded.
Cloud console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click the
Merchant Center
button on the top right of the page to open
a list of your linked Merchant Center accounts.
Click
Unlink
next to the Merchant Center account you're
unlinking, and confirm your choice in the dialog that appears.
curl
Use the
MerchantCenterAccountLink.delete
method to remove the
MerchantCenterAccountLink
resource.
curl
-X
DELETE
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
"https://retail.googleapis.com/v2alpha/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/merchantCenterAccountLinks/
BRANCH_ID
_
MERCHANT_CENTER_ID
"
Limitations on linking to Merchant Center
A Merchant Center account can be linked to any number of
catalog branches, but a single catalog branch can only be linked to one
Merchant Center account.
A Merchant Center account cannot be a
multi-client account (MCA)
. However, you can link individual
sub-accounts.
The first import after linking your Merchant Center account can
take hours to finish. The amount of time depends on the number of offers in the
Merchant Center account.
Any product modifications using API methods are
disabled for branches linked to a Merchant Center account.
Any changes to the product catalog data in those branches have to be made using
Merchant Center. Those changes are then automatically synced
to Vertex AI Search for commerce.
The collection product type isn't supported for branches that use
Merchant Center linking.
Your Merchant Center account can only be linked to empty catalog
branches for data accuracy. To delete products from a catalog
branch, see
Delete product information
.
Import catalog data from BigQuery
To import catalog data in the correct format from BigQuery, use
the
Vertex AI Search for commerce schema
to
create a BigQuery table
with the correct format and
load the empty table
with your catalog data. Then, upload your data
to Vertex AI Search for commerce.
For more help with BigQuery tables, see
Introduction to tables
.
For help with BigQuery queries, see
Overview of querying BigQuery data
.
To follow step-by-step guidance for this task directly in the
  Cloud Shell Editor, click
Guide me
:
Guide me
To import your catalog:
If your BigQuery dataset is in another project, configure the
required permissions so that Vertex AI Search for commerce can access the
BigQuery dataset.
Learn more
.
Import your catalog data to Vertex AI Search for commerce.
Cloud console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
Product catalog
.
Select
BigQuery
as your data source.
Select the branch you will upload your catalog to.
Choose
Retail Product Catalogs Schema
. This is the
Product schema for Vertex AI Search for commerce
.
Enter the BigQuery table where your data is located.
Optional: Under
Show advanced options
, enter the location of a
  Cloud Storage bucket in your project as a temporary location for your data.
If not specified, a default location is used. If specified, the BigQuery and
  Cloud Storage bucket have to be in the same region.
If you do not have search enabled and you are using
  the Merchant Center schema, select the product level.
You must
  select the product level if this is the first time you are importing your catalog or you are
  re-importing the catalog after purging it.
Learn more
about product levels.
Changing
  product levels
after you have imported any data requires a significant effort.
Important:
You can't turn on search for projects with a
  product catalog that has been ingested as variants.
Click
Import
.
curl
If this is the first time you are uploading your catalog, or you are
re-importing the catalog after purging it, set your
product levels
by using the
Catalog.patch
method. This operation requires the
Retail Admin role.
ingestionProductType
: Supports the values
primary
(default) and
variant
.
merchantCenterProductIdField
: Supports the
values
offerId
and
itemGroupId
. If you don't use
Merchant Center, you don't need to set this field.
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"productLevelConfig": {
"ingestionProductType": "
PRODUCT_TYPE
",
"merchantCenterProductIdField": "
PRODUCT_ID_FIELD
"
}
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog"
Create a data file for the input parameters for the import.
Use the
BigQuerySource
object to point to your
BigQuery dataset.
DATASET_ID
: The ID of the BigQuery
dataset.
TABLE_ID
: The ID of the BigQuery table
holding your data.
PROJECT_ID
: The project ID that the BigQuery
source is in. If not specified, the project ID is inherited from the
parent request.
STAGING_DIRECTORY
: Optional. A Cloud Storage
directory that is used as an interim location for your data before
it is imported into BigQuery. Leave this field empty
to automatically create a temporary
directory (recommended).
ERROR_DIRECTORY
: Optional. A Cloud Storage
directory for error information about the import. Leave this field
empty to automatically create a
temporary directory (recommended).
dataSchema
: For the
dataSchema
property, use value
product
(default). You'll use the
Vertex AI Search for commerce schema
.
We recommend you don't specify staging or error directories, that way, a
Cloud Storage bucket with new staging and error directories can be
automatically created. These directories are created in the same
region as the BigQuery dataset, and are unique to each import
(which prevents multiple import jobs from staging data to the same directory,
and potentially re-importing the same data). After three days, the bucket and
directories are automatically deleted to reduce storage costs.
An automatically created bucket name includes the project ID, bucket region, and
data schema name, separated by underscores (for example,
4321_us_catalog_retail
). The automatically created directories are
called
staging
or
errors
, appended by a number (for example,
staging2345
or
errors5678
).
If you specify directories, the Cloud Storage bucket must be in the
same region as the BigQuery dataset, or the import will fail.
Provide the staging and error directories in the format
gs://<bucket>/<folder>/
; they should be different.
{
"inputConfig"
:{
"bigQuerySource"
:
{
"projectId"
:
"
PROJECT_ID
"
,
"datasetId"
:
"
DATASET_ID
"
,
"tableId"
:
"
TABLE_ID
"
,
"dataSchema"
:
"product"
}
}
}
Import your catalog information by
making a
POST
request to the
Products:import
REST method, providing the name of the data file (here, shown as
input.json
).
curl -X POST \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" -d @./input.json \
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products:import"
You can check the status programmatically using the API.
You should receive a response object that looks something like this:
{
"name": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/import-products-123456",
"done": false
}
The name field is the ID of the
operation object
. To
request the status of this object, replace the name field with the
value returned by the
import
method, until the
done
field
returns as
true
:
curl
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/import-products-123456"
When the operation completes, the returned object has a
done
value of
true
, and includes a Status object similar to the following example:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/import-products-123456"
,
"metadata"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.ImportMetadata"
,
"createTime"
:
"2020-01-01T03:33:33.000001Z"
,
"updateTime"
:
"2020-01-01T03:34:33.000001Z"
,
"successCount"
:
"2"
,
"failureCount"
:
"1"
},
"done"
:
true
,
"response"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.ImportProductsResponse"
,
},
"errorsConfig"
:
{
"gcsPrefix"
:
"gs://error-bucket/error-directory"
}
}
You can inspect the files in the error directory in
Cloud Storage to see if errors occurred during the import.
Set up access to your BigQuery dataset
To set up access when your BigQuery dataset is in a different
project than your Vertex AI Search for commerce service, complete the following steps.
Open the IAM page in the Google Cloud console.
Open
the IAM page
Select your Vertex AI Search for commerce project.
Find the service account with the name
Retail Service Account
.
If you haven't previously initiated an import operation, this service
account might not be listed. If you don't see this service account, return to
the import task and initiate the import. When it fails due to permission
errors, return here and complete this task.
Copy the identifier for the service account, which looks like an email
address (for example,
service-525@gcp-sa-retail.iam.gserviceaccount.com
).
Switch to your BigQuery project (on the same
IAM & Admin
page) and click
person_add
Grant Access
.
For
New principals
, enter the identifier for the Vertex AI Search for commerce
service account and select the
BigQuery > BigQuery User
role.
Click
Add another role
and select
BigQuery > BigQuery Data Editor
.
If you don't want to provide the Data Editor role to the entire
project, you can add this role directly to the dataset.
Learn more
.
Click
Save
.
Product schema
When importing a catalog from BigQuery, use the following
Vertex AI Search for commerce product schema to create a BigQuery table
with the correct format and load it with your catalog data. Then,
import the catalog
.
View Vertex AI Search for commerce product schema
[
{
"name"
:
"name"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"type"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"primaryProductId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"collectionMemberIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"gtin"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"categories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"title"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"brands"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"description"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"languageCode"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"attributes"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"key"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"value"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"text"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"numbers"
,
"type"
:
"FLOAT"
,
"mode"
:
"REPEATED"
}
]
}
]
},
{
"name"
:
"tags"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"priceInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"price"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"originalPrice"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"priceEffectiveTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"priceExpireTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"rating"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"ratingCount"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"averageRating"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ratingHistogram"
,
"type"
:
"INTEGER"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"expireTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ttl"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"seconds"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"nanos"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"availableTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"availability"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"availableQuantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"fulfillmentInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"type"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"placeIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"images"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"height"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"width"
,
"type"
:
"INTEGER"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"audience"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"genders"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"ageGroups"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"colorInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"colorFamilies"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"colors"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
}
]
},
{
"name"
:
"sizes"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"materials"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"patterns"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"conditions"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"publishTime"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"promotions"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"promotionId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
}
]
Import catalog data from Cloud Storage
To import catalog data in JSON format, you create one or more JSON files that
contain the catalog data you want to import, and upload it to
Cloud Storage. From there, you can import it to Vertex AI Search for commerce.
For an example of the JSON product item format, see
Product item JSON data format
.
For help with uploading files to Cloud Storage, see
Upload objects
.
Make sure the Vertex AI Search for commerce service account has
permission to read and write to the bucket
.
The Vertex AI Search for commerce service account is listed on the
IAM page
in the Google Cloud console with the name
Retail Service Account
. Use
the service account's identifier, which looks like an email address (for
example,
service-525@gcp-sa-retail.iam.gserviceaccount.com
), when
adding the account to your bucket permissions.
Import your catalog data.
Cloud console
Go to the
Data
> page in the Search for commerce console.
Go to the Data page
Click
Import
to open the
Import Data
panel.
Choose
Product catalog
as your data source.
Select the branch you will upload your catalog to.
Choose
Retail Product Catalogs Schema
as the schema.
Enter the Cloud Storage location of your data.
If you do not have search enabled, select the product levels.
You must
  select the product levels if this is the first time you are importing your catalog or you are
  re-importing the catalog after purging it.
Learn more
about product levels.
Changing
  product levels
after you have imported any data requires a significant effort.
Important:
You can't turn on search for projects with a
  product catalog that has been ingested as variants.
Click
Import
.
curl
If this is the first time you are uploading your catalog, or you are
re-importing the catalog after purging it, set your
product levels by using the
Catalog.patch
method.
Learn more
about product levels.
ingestionProductType
: Supports the values
primary
(default) and
variant
.
merchantCenterProductIdField
: Supports the values
offerId
and
itemGroupId
. If you don't use
Merchant Center, you don't need to set this field.
curl
-X
PATCH
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
'{
"productLevelConfig": {
"ingestionProductType": "
PRODUCT_TYPE
",
"merchantCenterProductIdField": "
PRODUCT_ID_FIELD
"
}
}'
\
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog"
Create a data file for the input parameters for the import. Use the
GcsSource
object to point to your
Cloud Storage bucket.
You can provide multiple files, or just one; this example uses two
files.
INPUT_FILE
: A file or files in Cloud Storage
containing your catalog data.
ERROR_DIRECTORY
: A Cloud Storage directory for
error information about the import.
The input file fields must be in the format
gs://<bucket>/<path-to-file>/
.
The error directory must be in the format
gs://<bucket>/<folder>/
.
If the error directory does not exist, it gets created.
The bucket must already exist.
{
"inputConfig"
:{
"gcsSource"
:
{
"inputUris"
:
[
"
INPUT_FILE_1
"
,
"
INPUT_FILE_2
"
]
}
},
"errorsConfig"
:{
"gcsPrefix"
:
"
ERROR_DIRECTORY
"
}
}
Import your catalog information by making
a
POST
request to the
Products:import
REST
method, providing the name of the data file (here, shown as
input.json
).
curl -X POST \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json; charset=utf-8" -d @./input.json \
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products:import"
The easiest way to check the status of your import operation is to
use the Google Cloud console. For more information, see
See status for a specific integration operation
.
You can also check the status programmatically using the API.
You should receive a response object that looks something like this:
{
"name": "projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/import-products-123456",
"done": false
}
The name field is the ID of the
operation object
. You
request the status of this object, replacing the name field with the
value returned by the import method, until the
done
field returns
as
true
:
curl -H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
"https://retail.googleapis.com/v2/projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/[OPERATION_NAME]"
When the operation completes, the returned object has a
done
value
of
true
, and includes a Status object similar to the following
example:
{
"name"
:
"projects/
PROJECT_ID
/locations/global/catalogs/default_catalog/operations/import-products-123456"
,
"metadata"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.ImportMetadata"
,
"createTime"
:
"2020-01-01T03:33:33.000001Z"
,
"updateTime"
:
"2020-01-01T03:34:33.000001Z"
,
"successCount"
:
"2"
,
"failureCount"
:
"1"
},
"done"
:
true
,
"response"
:
{
"@type"
:
"type.googleapis.com/google.cloud.retail.v2.ImportProductsResponse"
},
"errorsConfig"
:
{
"gcsPrefix"
:
"gs://error-bucket/error-directory"
}
}
You can inspect the files in the error directory in
Cloud Storage to see what kind of errors occurred during
the import.
Import catalog data inline
curl
You import your catalog information inline by
making a
POST
request to the
Products:import
REST method,
using the
productInlineSource
object to specify your catalog
data.
Provide an entire product on a single line. Each product should be on its own
line.
For an example of the JSON product item format, see
Product item JSON data format
.
Create the JSON file for your product and call it
./data.json
:
{
"inputConfig": {
"productInlineSource": {
    "products": [
      {
PRODUCT_1
}
      {
PRODUCT_2
}
    ]
  }
}
}
Call the POST method:
curl
-X
POST
\
-H
"Authorization: Bearer
$(
gcloud
auth
application-default
print-access-token
)
"
\
-H
"Content-Type: application/json; charset=utf-8"
\
--data
@./data.json
\
"https://retail.googleapis.com/v2/projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products:import"
Java
public
static
String
importProductsFromInlineSource
(
List<Product>
productsToImport
)
throws
IOException
,
InterruptedException
,
ExecutionException
{
ProductServiceClient
productClient
=
getProductServiceClient
();
ProductInlineSource
inlineSource
=
ProductInlineSource
.
newBuilder
()
.
addAllProducts
(
productsToImport
)
.
build
();
ProductInputConfig
inputConfig
=
ProductInputConfig
.
newBuilder
()
.
setProductInlineSource
(
inlineSource
)
.
build
();
ImportProductsRequest
importRequest
=
ImportProductsRequest
.
newBuilder
()
.
setParent
(
IMPORT_PARENT
)
.
setRequestId
(
REQUEST_ID
)
.
setReconciliationMode
(
ReconciliationMode
.
INCREMENTAL
)
.
setInputConfig
(
inputConfig
)
.
build
();
String
operationName
=
productClient
.
importProductsAsync
(
importRequest
).
getName
();
productClient
.
shutdownNow
();
productClient
.
awaitTermination
(
2
,
TimeUnit
.
SECONDS
);
return
operationName
;
}
Product item JSON data format
The
Product
entries in your JSON file should look like the following examples.
Provide an entire product on a single line. Each product should be on its own
line.
Important:
The line breaks in this example are for readability. Except for line
breaks between products, don't include line breaks in your JSON data.
Minimum required fields:
{
        "id": "1234",
        "categories": "Apparel & Accessories > Shoes",
        "title": "ABC sneakers"
      }
      {
        "id": "5839",
        "categories": "casual attire > t-shirts",
        "title": "Crew t-shirt"
      }
View complete object
{
"name"
:
"projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/1234"
,
"id"
:
"1234"
,
"categories"
:
"Apparel & Accessories > Shoes"
,
"title"
:
"ABC sneakers"
,
"description"
:
"Sneakers for the rest of us"
,
"attributes"
:
{
"vendor"
:
{
"text"
:
[
"vendor123"
,
"vendor456"
]}
},
"language_code"
:
"en"
,
"tags"
:
[
"black-friday"
],
"priceInfo"
:
{
"currencyCode"
:
"USD"
,
"price"
:
100
,
"originalPrice"
:
200
,
"cost"
:
50
},
"availableTime"
:
"2020-01-01T03:33:33.000001Z"
,
"availableQuantity"
:
"1"
,
"uri"
:
"http://example.com"
,
"images"
:
[
{
"uri"
:
"http://example.com/img1"
,
"height"
:
320
,
"width"
:
320
}
]
}
{
"name"
:
"projects/
PROJECT_NUMBER
/locations/global/catalogs/default_catalog/branches/0/products/4567"
,
"id"
:
"4567"
,
"categories"
:
"casual attire > t-shirts"
,
"title"
:
"Crew t-shirt"
,
"description"
:
"A casual shirt for a casual day"
,
"attributes"
:
{
"vendor"
:
{
"text"
:
[
"vendor789"
,
"vendor321"
]}
},
"language_code"
:
"en"
,
"tags"
:
[
"black-friday"
],
"priceInfo"
:
{
"currencyCode"
:
"USD"
,
"price"
:
50
,
"originalPrice"
:
60
,
"cost"
:
40
},
"availableTime"
:
"2020-02-01T04:44:44.000001Z"
,
"availableQuantity"
:
"2"
,
"uri"
:
"http://example.com"
,
"images"
:
[
{
"uri"
:
"http://example.com/img2"
,
"height"
:
320
,
"width"
:
320
}
]
}
Historical catalog data
Vertex AI Search for commerce supports importing and managing historical
catalog data. Historical catalog data can be helpful when you use historical
user events for model training. Past product information can be used to enrich
historical user event data and improve model accuracy.
Historical products are stored as expired products. They are not returned in
search responses, but are visible to the
Update
,
List
, and
Delete
API
calls.
Import historical catalog data
When a product's
expireTime
field is set to a past
timestamp, this product is considered as a historical product. Set the product
availability
to
OUT_OF_STOCK
to avoid impacting
recommendations.
We recommend using the following methods for importing historical catalog data:
Calling the
Product.Create
method
.
Inline importing expired products
.
Importing expired products from BigQuery
.
Call the
Product.Create
method
Use the
Product.Create
method to create a
Product
entry
with the
expireTime
field set to a past timestamp.
Inline import expired products
The steps are identical to
inline import
, except that the products
should have the
expireTime
fields set to a past
timestamp.
Provide an entire product on a single line. Each product should be on its own
line.
Important:
The line breaks in this example are for readability. Except for line
breaks between products, don't include line breaks in your JSON data.
An example of the
./data.json
used in the inline import request:
View this example used in the inline import request
{
"inputConfig": {
  "productInlineSource": {
      "products": [
          {
            "id": "historical_product_001",
            "categories": "Apparel & Accessories > Shoes",
            "title": "ABC sneakers",
            "expire_time": {
              "second": "2021-10-02T15:01:23Z"  // a past timestamp
            }
          },
          {
            "id": "historical product 002",
            "categories": "casual attire > t-shirts",
            "title": "Crew t-shirt",
            "expire_time": {
              "second": "2021-10-02T15:01:24Z"  // a past timestamp
            }
          }
      ]
    }
  }
}
Import expired products from BigQuery or Cloud Storage
Use the same procedures documented for
importing catalog data from BigQuery
or
importing catalog data from Cloud Storage
. However, make sure to set
the
expireTime
field to a past timestamp.
Keep your catalog up to date
For best results, your catalog must contain current information.
We recommend that you import your
catalog on a daily basis to make sure that your catalog is current. You can use
Google Cloud Scheduler
to schedule imports, or choose an
automatic scheduling option when you import data using the
Google Cloud console.
You can update only new or changed product items, or you can import the entire
catalog. If you import products that are already in your catalog, they are
not added again. Any item that has changed is updated.
Note:
If an item is no longer current, set its status to
OUT_OF_STOCK
rather
than deleting it, so that previous user events that reference it are not
invalidated.
To update a single item, see
Update product information
.
Batch update
You can use the import method to batch update your catalog. You do this
the same way you do the initial import; follow the steps in
Import catalog data
.
Monitor import health
To monitor catalog ingestion and health:
View aggregated information about your catalog and preview uploaded
products on the
Catalog
tab of the Search for commerce
Data
page.
Go to the Data page
Assess if you need to update catalog data to improve the quality of
search results and unlock search performance tiers on the
Data quality
page.
For more about how to check search data quality and view search performance
tiers, see
Unlock search performance tiers
. For a summary of
available catalog metrics on this page, see
Catalog quality metrics
.
Go to the Data quality page
To create alerts that let you know if something goes wrong with your data
uploads, follow the procedures in
Set up Cloud Monitoring alerts
.
Keeping your catalog up to date is important for getting high-quality
results. Use alerts to monitor the import error rates and take action if
needed.
What's next
Start
recording user events
.
View aggregated information
about your catalog.
Set up data upload alerts
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/user-events.txt
About user events  |  Vertex AI Search for commerce  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
About user events
This page describes the user event object, including listing potential
user event types, and provides sample data for all user event types.
Vertex AI Search for commerce uses real-time user events to generate recommendations and
search results. When you upload data, both
recommendations and search are able to use that
data, so you don't need to upload the same events twice if you use both
services.
Configure and
implement your user events
.
Learn more about
user event types
.
Learn more about
attribution tokens
.
How search attribution works
User event types
There are several user event types that you can record as users browse your
retail site:
User event name
User action
Google Analytics 4
event_name
home-page-view
Views homepage.
view_homepage
search
(Search and browse)
Searches the catalog.
view_item_list
+ [
searchQuery
OR
pageCategories
+
filter
]
category-page-view
(Recommendations only)
Views special pages, such as sale or promotion pages.
view_item_list
+
pageCategories
detail-page-view
Views product detail page.
view_item
add-to-cart
Adds product to cart.
add_to_cart
shopping-cart-page-view
Views shopping cart.
begin_checkout
purchase-complete
Completes checkout.
purchase
For an extensive list of GA4 event fields, see
Google Analytics 4 user event fields
.
For detailed information about the
UserEvent
object, see
UserEvent
.
Event type priority
For the highest quality results, we recommend that you record user events for
all event types. The following table describes the priority of the different
user event types. You must log the highest priority user events to achieve
quality data models.
Priority
User event types
Required for initial live experimentation for recommendations
(event types depend on the
recommendation model type
)
detail-page-view
add-to-cart
purchase-complete
home-page-view
Additional event required for search live experiment
search
User event requirements and best practices
The following tables list requirements and best practices for user event types
that recommendations and search use. Check that
your user events fulfill these requirements so that Vertex AI Search for commerce
can generate quality results.
This section lists:
Requirements for user events
: General user event
requirements. These requirements apply whether
you use recommendations and search.
Recommendations-specific requirements
:
User event requirements for recommendations.
Search-specific requirements
:
User event requirements for search.
If you use recommendations models, also see
Model type data requirements
, which lists additional requirements
depending on the recommendation model type and optimization objective you plan
to use.
You can view data quality metrics for search on the
Data quality
page in the
Search for commerce console. These metrics show the
percentages of products and user events that fulfill recommended standards of
data quality. For information about how to view search data quality, see
Unlock search performance tiers
.
General user event requirements
Make sure your user events meet the following requirements so that the
Vertex AI Search for commerce can generate quality results. These apply to both
recommendations and search.
Event type
Requirement
Impact
All events
Don't include synthetic data or duplicate events.
Synthetic or duplicate events negatively impact model quality and often prevent successful model training.
          Duplicate events can cause incorrect metrics values.
Include at least 100 unique visitor IDs for each type of event
          ingested.
This verifies that Vertex AI Search for commerce has enough data to generate
          quality results.
Visitor IDs must be formatted exactly the same across event import
          or event recording and in API requests.
Using a consistent format for visitor IDs helps
          correctly identify visitor patterns and provide better-quality results
          based on user behavior.
Products included in the events should exist in your catalog of
          products.
The unjoined events ratio should be kept as low as possible. A high
          ratio can negatively impact the quality of recommendation or search
          results.
Unjoined event data is not used to train models. However, unjoined
          events can be joined later, after the associated products have been
          ingested. For more information, see
Rejoin user events
.
Some user events should have the same visitor ID.
To construct valid behavior sequence histories, Vertex AI Search for commerce
          must be able to see multiple events with the same visitor ID.
For example,
visitor123
has viewed five product detail
          pages, added three products to their cart, then bought two of the
          original five products. If these events all provide the same
          consistently formatted visitor ID, Vertex AI Search for commerce can
          consider that behavior sequence in its models.
detail-page-view
Include exactly one product per event.
The event can't be used if no product exists. If multiple products are
          included, the event is malformed and can't be used.
add-to-cart
Include exactly one product per event.
If multiple products are included, the event is malformed and can't be
          used.
purchase-complete
Include
purchase_transaction.revenue
.
purchase-complete
events that are missing the
revenue
field are not used to train models.
Include exactly one
purchase_transaction.currency_code
across all purchase events.
There is no default currency code; a code must be supplied.
Purchase events without this field result in incorrect revenue
          metrics.
Check that some purchase events include multiple products.
Having some purchase events with multiple products helps the model learn co-purchase patterns.
Recommendations-specific requirements
If you are using recommendations, make sure your user events meet
the following requirements.
If you use recommendations models, also see
Model type data requirements
, which lists additional requirements
depending on the recommendation model type and optimization objective you plan
to use.
Event type
Requirement
Impact
purchase-complete
Don't flatten multi-item baskets into multiple purchase events. They
        should remain as single purchase events that include multiple products.
This verifies that valid co-purchase patterns are generated.
Search-specific requirements
If you are using search, make sure your user events meet
the following minimum requirements to get results.
Event type
Requirement
Impact
search
searchQuery
must exist for search events, and
pageCategories
must exist for browsing events.
Not including this field can have a severe negative impact on search
        result quality and metrics.
The visitor ID in search requests should match the visitor ID sent in
        events related to that search request.
If they don't match, the events are malformed and metrics could be
        incorrect.
The list of product IDs in search events must match the list of products
        shown to the user in its entirety.
If they don't match, the negative impact to search result quality can be
        severe, and metrics will be incorrect.
If the search uses a filter,
filter
must exist and parse
        correctly.
If this field does not exist, Vertex AI Search for commerce can't
        use the filter part of the data, which can negatively impact search
        result quality.
Include the
attribution_token
field to link other events
        back to search events.
Not including an attribution token will trigger an error in the Search for commerce and have a severe negative impact on search
        quality and metrics accuracy.
Search optimization requirements
To let search automatically optimize the search experience based
on overall user trends, upload the following data.
Events should be uploaded at least daily with a maximum delay of 24 hours.
Events metric
Events volume/frequency
Description
Volume of
search
events
250K in last 90 days
At least 250,000 events in the last 90 days are
required
to
        optimize the search experience based on events ingested.
We recommend uploading events at least daily to maintain good data quality. During historical event imports make sure that data distribution skews toward the most recent timestamp. The number of events on the last timestamp day should be equal to or more than the average daily event count.
Volume of
detail-page-view
attributable to a
search
event
500,000 in last 30 days
At least 500,000 events are
required
for optimizing search
       results using user events.
Average
detail-page-view
events attributable to a
search
event per product
10 in last 30 days
Required
for optimizing search results using the events
       ingested unless events for past 21 days are uploaded.
Proportion of
search
events with parseable filters
0.1 in last 30 days
Recommended for optimizing the order of dynamic facets in
    the search response.
Proportion of searched products with price
0.95 in last 30 days
Required
for optimizing search results using the events
      ingested.
Average
add-to-cart
events attributable to a
search
event per priced product
0.5 in last 30 days
Recommended for revenue optimized search results.
Average
purchase-complete
events attributable to a
search
event per searchable priced product
0.5 in last 30 days
Recommended for revenue optimized search results.
Search personalization requirements
Search requires the following data to personalize text search
and browse search results for your users based on their activity.
After you upload the following data, search can personalize
results automatically.
Events metric
Events volume/frequency
Description
Volume of
search
events served by search
100,000 in last 30 days
At least 100,000 events served by search in the last 30 days are required to provide personalization.
search results are not cached
Less than 1% of the most recent 100,000 user events
Don't cache search results for text search or browse
        searches if you plan to use personalization. Reusing the same results
        across visitors prevents search from providing truly
        personalized results to any given user and risks exposing users'
        private data. Search automatically turns off
        personalization if caching is detected.
If you cache only search results, search can still
        personalize browse results. Conversely, if you cache only browse
        results, search can still personalize text query search
        results.
Visitor ID matches between
SearchRequests
and user events
More than 10% match for the most recent 100,000 user events
Make sure that visitor ID spacing and formatting matches across
SearchRequests
and user events. Consistent visitor ID
      formatting verifies that search can identify user activity
      correctly.
User event type examples and schemas
This section provides the data formats for each event type supported.
Examples for JavaScript Pixel and Tag Manager are provided. For
BigQuery, the full table schema for each type is provided.
For all user events types,
userId
is optional. The product information
fields (
priceInfo
and
availability
) are
optional.
Note that:
The
experimentIds
field is needed only if you are running an A/B experiment.
The
attributionToken
field is required for Vertex AI Search for commerce only. It is used to
measure performance
. Attribution tokens shouldn't be sent to
predict
,
search
, and
detail-page-view
, or click events.
Make sure your events all use a single currency, especially if you plan to use
Google Cloud console to get revenue metrics. The Vertex AI Search for commerce API does not support using
multiple currencies per catalog.
For more details about the user event object, see the
UserEvent
API reference documentation
.
Add to cart
The following shows the
add-to-cart
user event format in an example only using required fields.
The product quantity in an
add-to-cart
event must be an incremental value representing the quantity of the product associated with that specific user event. For example, if two units of a product are added to the shopping cart, the quantity field for that
add-to-cart
event should be
2
. For
add-to-cart
events, include exactly one product per event.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"add-to-cart"
,
"visitorId"
:
"
visitor-id
"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"
product-id
"
},
"quantity"
:
{
"value"
:
produc
t
-
qua
nt
i
t
y
}
}]
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'
add-to-cart
'
,
'visitorId'
:
'
visitor-id
'
,
// You can also define the visitor ID
// directly on the Tag Manager tag.
'productDetails'
:
[{
'product'
:
{
'id'
:
'
product-id
'
},
'quantity'
:
product
-
quantity
}]
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete add-to-cart object example
The following examples include both required and optional fields for the
add-to-cart
user event. If you include the pricing information,
    the
currencyCode
field is required.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"add-to-cart"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"attributionToken"
:
"abc"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
},
"quantity"
:
2
}],
"cartId"
:
"mobile"
,
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"http://example"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'add-to-cart'
,
'visitorId'
:
'visitor0'
,
// You can also define the user ID and visitor ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'attributionToken'
:
'abc'
,
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
},
'quantity'
:
{
'value'
:
2
}
}],
'cartId'
:
'mobile'
,
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Category page view
The following shows the
category-page-view
user event format.
The following examples show only the required fields of the
category-page-view
user event format.
While there is usually only one category associated with a page, the
pageCategories
field also supports a category hierarchy, which you can provide
as a list.
Note:
The
category-page-view
field is
not
for browsing on product categories. Rather, it's only for special
page_categories
for recommendations only. For example,
(sales > Black Friday)
.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"category-page-view"
,
"visitorId"
:
"
visitor-id
"
,
"pageCategories"
:
[
"
category1
>
category2
"
]
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'category-page-view'
,
'visitorId": '
visitor
-
id
',
// You can also define the user ID and visitor ID
// directly on the Tag Manager tag.
'
pageCategories
': ['
category1
>
category2
'
]
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"pageCategories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete category-page-view object example
The following examples include both required and optional fields for the
category-page-view
user event.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"category-page-view"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributionToken"
:
"abc"
,
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
}
}],
"pageCategories"
:
[
"Sales > New Year Deals"
],
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'category-page-view'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributionToken'
:
'abc'
,
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
}
}],
'pageCategories'
:
[
'Sales > New Year Deals'
],
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"pageCategories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Detail page view
The following shows the
detail-page-view
user event data format.
The following examples show only the required fields of the
detail-page-view
user event format.
In most cases,
productDetails
contains details for the associated product,
unless a bundle of items are being sold together.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"detail-page-view"
,
"visitorId"
:
"
visitor-id
"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"
product-id
"
}
}]
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'detail-page-view'
,
'visitorId'
:
'
visitor-id
'
,
// You can also define the visitor ID directly on
// the Tag Manager tag.
'productDetails'
:
[{
'product'
:
{
'id'
:
'
product-id
'
}
}]
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete detail-page-view object example
The following examples include both required and optional fields for the
detail-page-view
user event.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"detail-page-view"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributionToken"
:
"abc"
,
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
}
}],
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'detail-page-view'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributionToken'
:
'abc'
,
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
}
}],
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Home page view
The following shows the
home-page-view
user event format.
The following examples show only the required fields of the
home-page-view
user event format.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"home-page-view"
,
"visitorId"
:
"
visitor-id
"
,
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'home-page-view'
,
'visitorId'
:
'
visitor-id
'
// You can also define the visitor ID
// directly on the Tag Manager tag.
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete home-page-view object example
The following examples include both required and optional fields for the
home-page-view
user event.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"home-page-view"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"attributionToken"
:
"abc"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
},
"quantity"
:
2
}],
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'home-page-view'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'attributionToken'
:
'abc'
,
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
},
'quantity'
:
{
'value'
:
2
}
}],
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Purchase complete
The following shows the
purchase-complete
user event data format.
The following examples show only the required fields of the
purchase-complete
user event format.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"purchase-complete"
,
"visitorId"
:
"
visitor-id
"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"
product-id
"
},
"quantity"
:
produc
t
-
qua
nt
i
t
y
}],
"purchaseTransaction"
:
{
"revenue"
:
reve
nue
,
"currencyCode"
:
"
currency-code
"
}
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'purchase-complete'
,
'visitorId'
:
'
visitor-id
'
,
// You can also define the visitor ID directly on
// the Tag Manager tag.
'productDetails'
:
[{
'product'
:
{
'id'
:
'
product-id
'
},
'quantity'
:
product
-
quantity
}],
'purchaseTransaction'
:
{
'revenue'
:
revenue
,
'currencyCode'
:
'
currency-code
'
}
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"priceInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"price"
,
"type"
:
"FLOAT"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"originalPrice"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
}
]
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"purchaseTransaction"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"revenue"
,
"type"
:
"FLOAT"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"tax"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete purchase-complete object example
The following examples include both required and optional fields for the
purchase-complete
user event.

    In this example, the full price information is provided for the purchased
    product. When the user event is ingested and processed, if
priceInfo
information is provided, this is used in place of
    stored price information for the product.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"purchase-complete"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"attributionToken"
:
"abc"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
,
"priceInfo"
:
{
"price"
:
99.99
,
"originalPrice"
:
129.99
,
"currencyCode"
:
"EUR"
}
},
"quantity"
:
2
}],
"cartId"
:
"mobile"
,
"purchaseTransaction"
:
{
"revenue"
:
10.0
,
"currencyCode"
:
"EUR"
},
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'purchase-complete'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'attributionToken'
:
'abc'
,
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
,
'priceInfo'
:
{
'price'
:
99.99
,
'originalPrice'
:
129.99
,
'currencyCode'
:
'EUR'
}
},
'quantity'
:
{
'value'
:
2
}
}],
'cartId'
:
'mobile'
,
'purchaseTransaction'
:
{
'revenue'
:
10.0
,
'currencyCode'
:
'EUR'
},
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"priceInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"price"
,
"type"
:
"FLOAT"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"originalPrice"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
}
]
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"purchaseTransaction"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"revenue"
,
"type"
:
"FLOAT"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"tax"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"cost"
,
"type"
:
"FLOAT"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"currencyCode"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Search
The following shows the
search
user event format.
Minimum required search object
These are the minimum required fields for Vertex AI Search for commerce to return a list of search results:
searchQuery
is read from the
search_term
parameter or from
view_search_results
events.
productDetails
is read from the
items
parameter of the
view_item_list
event. It should include the list of product IDs. shown to the end user in the search results page.
userEvents
captures all metadata information Retail API needs to know about how end users interact with customer's website.
The following examples show only the required fields of the
search
user event
format.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"search"
,
"visitorId"
:
"
visitor-id
"
,
"searchQuery"
:
"
search-query
"
,
"pageCategories"
:
[
"
category1
>
category2
"
],
"productDetails"
:
[
{
"product"
:
{
"id"
:
"
product-id1
"
}
},
{
"product"
:
{
"id"
:
"
product-id2
"
}
}
]
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'search'
,
'visitorId'
:
'
visitor-id
'
,
// You can also define the visitor ID
// directly on the Tag Manager tag.
'searchQuery'
:
'
search-query
'
,
'pageCategories'
:
[
'
category1
>
category2
'
],
'productDetails'
:
[
{
'product'
:
{
'id'
:
'
product-id1
'
}
},
{
'product'
:
{
'id'
:
'
product-id2
'
}
}
]
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"searchQuery"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageCategories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Autocomplete
This field is only required for search events if you want to use
Autocomplete
. It is not required for search.
The following examples show the
completionDetail
field when a user types "sh"
and clicks the second suggestion, "shoes", in the suggestion list to trigger a
search event. If the user doesn't click any suggestions, the
completionDetail
field remains empty.
eventType
must be
"search"
.
completionAttributionToken
is the
attributionToken
from
completeQuery
response.
selectedSuggestion
should be the same as
searchQuery
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"search"
,
"visitorId"
:
"
visitor-id
"
,
"searchQuery"
:
"
search-query
"
,
"pageCategories"
:
[
"
category1
>
category2
"
],
"productDetails"
:
[
{
"product"
:
{
"id"
:
"
product-id1
"
}
},
{
"product"
:
{
"id"
:
"
product-id2
"
}
}
]
"completionDetail"
:
{
"completionAttributionToken"
:
"
completion_token
"
,
"selectedSuggestion"
:
"
search-query
"
,
"selectedPosition"
:
comple
t
io
n
_posi
t
io
n
}
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'search'
,
'visitorId'
:
'
visitor-id
'
,
// You can also define the visitor ID
// directly on the Tag Manager tag.
'searchQuery'
:
'
search-query
'
,
'pageCategories'
:
[
'
category1
>
category2
'
],
'productDetails'
:
[
{
'product'
:
{
'id'
:
'
product-id1
'
}
},
{
'product'
:
{
'id'
:
'
product-id2
'
}
}
]
"completionDetail"
:
{
"completionAttributionToken"
:
'
completion_token
'
,
"selectedSuggestion"
:
'
search-query
'
,
"selectedPosition"
:
completion_position
}
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"searchQuery"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageCategories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"completionDetail"
,
"type"
:
"RECORD"
"mode"
:
"NULLABLE"
"fields"
:
[
{
"name"
:
"completionAttributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"selectedSuggestion"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"selectedPosition"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
}
]
Complete search object example
The following examples include both required and optional fields for the
search
user event.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"search"
,
"visitorId"
:
"visitor0"
,
"searchQuery"
:
"Rainbow Unicorn"
,
"filter"
:
"(brands: ANY(\"brand_1\") AND price: IN(0, 100))"
,
"orderBy"
:
"rating"
,
"offset"
:
60
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributionToken"
:
"abc"
,
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"productDetails"
:
[
{
"product"
:
{
"id"
:
"abc"
}
},
{
"product"
:
{
"id"
:
"def"
}
}
],
"pageCategories"
:
[
"Sales > New Year Deals"
],
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"https://awesome"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
,
"completionDetail"
:
{
"completionAttributionToken"
:
"efg"
,
"selectedSuggestion"
:
"Rainbow Unicorn"
,
"selectedPosition"
:
3
}
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'eventType'
:
'search'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'searchQuery'
:
'Rainbow Unicorn'
,
'filter'
:
'(brands: ANY(\"brand_1\") AND price: IN(0, 100))'
,
'orderBy'
:
'rating'
,
'offset'
:
60
,
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributionToken'
:
'abc'
,
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'productDetails'
:
[
{
'product'
:
{
'id'
:
'abc'
}
},
{
'product'
:
{
'id'
:
'def'
}
}
],
'pageCategories'
:
[
'Sales > New Year Deals'
],
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
,
"completionDetail"
:
{
"completionAttributionToken"
:
"efg"
,
"selectedSuggestion"
:
"Rainbow Unicorn"
,
"selectedPosition"
:
3
}
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
}
]
},
{
"name"
:
"searchQuery"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageCategories"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"completionDetail"
,
"type"
:
"RECORD"
"mode"
:
"NULLABLE"
"fields"
:
[
{
"name"
:
"completionAttributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"selectedSuggestion"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"selectedPosition"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
}
]
Shopping cart page view
The following shows the
shopping-cart-page-view
user event data format.
The following examples show only the required fields of the
shopping-cart-page-view
user event format.
Provide the
productDetails
and
userEvents
objects unless the shopping cart is empty.
When you import events, you must provide the timestamp in the
eventTime
field in the format specified by
RFC 3339
.
Other fields might be required depending on the API method used or if
additional fields are used. (For example, if the user event is associated with
an
entity
, make sure to specify the
entity
field.)
For full details of each field and when they are required, see the
UserEvent
API reference documentation
.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"shopping-cart-page-view"",
"
visi
t
orId
": "
VISITOR
-
ID
"
"
car
t
Id
": "
CART
-
ID
",
"
produc
t
De
ta
ils
": [{
"
produc
t
": {
"
id
": "
PRODUCT
-
ID
"
},
"
qua
nt
i
t
y":
PRODUCT-QUANTITY
}]
};
Replace
PRODUCT-ID
,
PRODUCT-QUANTITY
,
VISOTOR-ID
, and
CART-ID
with your product ID, product quantity, session ID, and shopping cart ID.
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'shopping-cart-page-view'
,
'visitorId'
:
'
VISITOR-ID
'
// You can also define the visitor ID
// directly on the Tag Manager tag.
'cartId'
:
'
CART-ID
'
,
'productDetails'
:
[{
'product'
:
{
'id'
:
'
PRODUCT-ID
'
},
'quantity'
:
PRODUCT
-
QUANTITY
}]
}
});
<
/script>
Replace
PRODUCT-ID
,
PRODUCT-QUANTITY
,
VISOTOR-ID
, and
CART-ID
with your product ID, product quantity, session ID, and shopping cart ID.
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Complete shopping-cart-page-view object example
The following examples include both required and optional fields for the
shopping-cart-page-view
user event.
JavaScript Pixel
var
user_eve
nt
=
{
"eventType"
:
"shopping-cart-page-view"
,
"visitorId"
:
"visitor0"
,
"eventTime"
:
"2020-01-01T03:33:33.000001Z"
,
"experimentIds"
:
[
"321"
],
"attributes"
:
{
"example_text_attribute"
:
{
"text"
:
[
"text_1"
,
"text_2"
]
},
"example_number_attribute"
:
{
"numbers"
:
[
3.14
,
42
,
1.2345
]
}
},
"attributionToken"
:
"abc"
,
"productDetails"
:
[{
"product"
:
{
"id"
:
"abc"
},
"quantity"
:
2
}],
"cartId"
:
"mobile"
,
"userInfo"
:
{
"userId"
:
"abc@example.com"
,
"ipAddress"
:
"8.8.8.8"
,
"userAgent"
:
"Mozilla/5.0"
,
"directUserRequest"
:
true
},
"uri"
:
"http://example"
,
"referrerUri"
:
"https://google"
,
"pageViewId"
:
"currentPageUri"
,
"entity"
:
"entity_1"
}
;
Tag Manager
<
script
>
dataLayer
=
dataLayer
||
[];
dataLayer
.
push
({
'cloud_retail'
:
{
'eventType'
:
'shopping-cart-page-view'
,
'visitorId'
:
'visitor0'
,
// You can also define the visitor ID and user ID
// directly on the Tag Manager tag.
'eventTime'
:
'2020-01-01T03:33:33.000001Z'
,
'experimentIds'
:
[
'321'
],
'attributes'
:
{
'example_text_attribute'
:
{
'text'
:
[
'text_1'
,
'text_2'
]
},
'example_number_attribute'
:
{
'numbers'
:
[
3.14
,
42
,
1.2345
]
}
},
'attributionToken'
:
'abc'
,
'productDetails'
:
[{
'product'
:
{
'id'
:
'abc'
},
'quantity'
:
{
'value'
:
2
}
}],
'cartId'
:
'mobile'
,
'userInfo'
:
{
'userId'
:
'abc@example.com'
,
'ipAddress'
:
'8.8.8.8'
,
'userAgent'
:
'Mozilla/5.0'
,
'directUserRequest'
:
true
},
'uri'
:
'http://example'
,
'referrerUri'
:
'https://google'
,
'pageViewId'
:
'currentPageUri'
,
'entity'
:
'entity_1'
}
});
<
/script>
BigQuery
This is the complete JSON schema for this user event type. Specify this schema
when creating tables for this user event type in BigQuery.
Modes for required fields are set to
REQUIRED
or
REPEATED
. Modes for
optional fields are set to
NULLABLE
.
Note that
eventTime
is required for importing events with
BigQuery.
eventTime
is a string with a timestamp format.
[
{
"name"
:
"eventType"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"visitorId"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"eventTime"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
},
{
"name"
:
"experimentIds"
,
"type"
:
"STRING"
,
"mode"
:
"REPEATED"
},
{
"name"
:
"attributionToken"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"productDetails"
,
"type"
:
"RECORD"
,
"mode"
:
"REPEATED"
,
"fields"
:
[
{
"name"
:
"product"
,
"type"
:
"RECORD"
,
"mode"
:
"REQUIRED"
,
"fields"
:
[
{
"name"
:
"id"
,
"type"
:
"STRING"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"quantity"
,
"type"
:
"INTEGER"
,
"mode"
:
"REQUIRED"
}
]
},
{
"name"
:
"cartId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userInfo"
,
"type"
:
"RECORD"
,
"mode"
:
"NULLABLE"
,
"fields"
:
[
{
"name"
:
"userId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"ipAddress"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"userAgent"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"directUserRequest"
,
"type"
:
"BOOLEAN"
,
"mode"
:
"NULLABLE"
}
]
},
{
"name"
:
"uri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"referrerUri"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"pageViewId"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
},
{
"name"
:
"entity"
,
"type"
:
"STRING"
,
"mode"
:
"NULLABLE"
}
]
Google Analytics 4 user event fields
The following table shows how Google Analytics 4 user event fields map
to Vertex AI Search for commerce fields.
Before you import or record user events from Google Analytics 4, make
sure your Google Analytics 4 user events use the following fields so
that Vertex AI Search for commerce can integrate your data correctly.
Google Analytics 4
Retail
ecommerce.purchase_revenue
purchaseTransaction.revenue
event_name
eventType
event_timestamp
eventTime
items.item_id
productDetails.product.id
items.price
productDetails.product.priceInfo.price
items.quantity
productDetails.quantity
Key:
event_params.key
set to
"currency"
Value:
event_params.value.string_value
productDetails.product.priceInfo.currencyCode
Key:
event_params.key
set to
"currency"
Value:
event_params.value.string_value
purchaseTransaction.currencyCode
Key:
event_params.key
set to
"search_term"
Value:
event_params.value.string_value
searchQuery
user_id
userInfo.userId
user_pseudo_id
visitorId
What's next
Learn how to
record user events
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs/what-is-it.txt
What is Vertex AI Search for commerce?  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Guides
Reference
Support
Resources
Contact Us
Start free
Technology areas
More
Guides
Reference
Support
Resources
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Discover
Product overview
What is Vertex AI search for commerce?
Features and capabilities
Global endpoints
Guided search
About facets for search
Conversational product filtering
Overview
User experience guide
Developer guide
Conversational Commerce agent
Overview
User experience guide
Developer guide
Tile navigation
Get started
How Vertex AI search for commerce works
Before you begin
Initial setup
Authenticate to Vertex AI search for commerce
Identity and access management (IAM)
Implement Vertex AI search for commerce
Quickstart tutorials
Interactive tutorials
Troubleshoot tutorial issues
Create personalized movie recommendations
Prepare your data for indexing
About catalogs and products
Product attributes
Attribution tokens
Entities
About user events
Send your search data
Import historical user events
Record real-time user events
Import autocomplete data for search
Import catalog information
Build your commerce UI
Implement user events
Autocomplete for search
Search as you type
Query expansion
About serving configs
About serving controls
Personalization
Create serving configs
Create serving controls
Filter and order results
Boost results
Deploy Vertex AI
Recommendations
Get recommendations
Filter recommendations
Use recommendations in emails
Search
Get search results
Data quality
Manage search results
Manage serving configs
Manage serving controls
Manage site-wide attribute controls
Manage catalog information
Manage user events
Models
About recommendation models
Create recommendation models
Using a pretrained LLM
Manage models
Supported world languages
Data insights
Export your data into BigQuery
Export commerce metrics to BigQuery
Measure performance
View analytics
Get dashboards that show key performance indicators
Generate sales forecasts from commerce data
Monitor and troubleshoot
Set up Cloud Monitoring alerts
About A/B experiments
Monitor and analyze A/B experiments
Monitor and troubleshoot
Audit logging information
Govern and maintain
Update inventory
Update local inventory
Data governance for commerce
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Guides
Send feedback
What is Vertex AI Search for commerce?
Vertex AI Search for commerce is a Google Cloud product that provides Google-quality search, browsing, recommendations, and Conversational Commerce agent capabilities for your digital properties. It's specifically designed and highly tuned for ecommerce websites and mobile applications. Formerly known as Vertex AI Search for retail, the service has been rebranded.
What Vertex AI Search for commerce can do
Core capabilities
: It combines search and recommendation to help you implement personalized experiences based on machine learning models.
Goal
: Primarily, to increase conversions and reduce search abandonment on your digital platforms. Improve the shopping experience by making it easier for customers to find relevant products.
For more information, see
Features and capabilities
.
Search as an interaction
Vertex AI Search for commerce offers a range of powerful capabilities designed to enhance the ecommerce experience for your customers and drive business growth.
One way it works is through guided search features. The system can provide relevant suggestions and prompts, even after an initial broad query. These include
Conversational Commerce agent
and
conversational filtering
, where the system can guide users to refine and narrow broad search queries through AI-enabled conversation. Understanding context, it can prompt users with clarifying questions or suggest specific attributes.
Advanced filtering
is also crucial to interactive search. Using Vertex AI Search for commerce, businesses can apply rules to fine-tune what customers see and filter by product availability and custom tags. End users interact with
dynamic filtering
to narrow search results. These dynamic filtering options adapt and change based on the initial search query and available product attributes in the resulting set and drive interactive search features, such as
tiles
.
What Vertex AI Search for commerce can do for your users
Using the
Merchandising console
or the
Search for commerce console
, site merchandisers and Vertex AI Search for commerce administrators can
access and configure controls
, as well as use them for
search facets
.
Vertex AI Search for commerce is a fully managed platform accessible to users who aren't developers, such as ecommerce admins. Google Cloud automatically handles the technical complexities like data preprocessing, training and tuning machine learning models, load balancing, and infrastructure provisioning.
What Vertex AI Search for commerce can do for developers
This service helps developers focus on building engaging user experiences without the complexities of managing underlying AI infrastructure. A detailed breakdown of what Vertex AI Search for commerce can do for developers:
Integrate advanced search capabilities
: Developers can embed high-quality search into their websites and mobile applications, enabling users to find products more effectively. Onboarding to Vertex AI Search for commerce can be started with or without Google tools, converging into a
streamlined integration pathway
. Integrating it includes advanced query understanding that can handle broad search terms.
Build personalized recommendations systems
: The platform helps developers
deliver highly personalized recommendations
at scale. By understanding customer behavior, context, and product attributes, developers can
create recommendation engines
that drive user engagement across various channels.
Use Conversational Commerce agent
: Developers can guide users to refine their search queries through
back-and-forth conversation
, enhancing navigation.
Optimize search and recommendations results
: While non-developers can use business rules and ranking models such as increased engagement, revenue, or conversions, they can also
apply business rules
to fine-tune what customers see. They can diversify product displays and
filter by product availability
or
custom tags
through ranking algorithms or dynamically applied logic
based on parameters
. Developers can optimize search and recommendation results to meet specific business objectives.
Utilize the latest AI
: Developers can rely on Google's expertise in AI and machine learning for advanced query understanding and personalization, leading to better search, browse, and recommendation results.
Benefit from a fully managed platform
: Vertex AI Search for commerce handles data preprocessing, machine learning model training and hyperparameter tuning, load balancing, and infrastructure provisioning. This significantly reduces burden on development teams.
Seamlessly connect with existing tools
: Developers can integrate Vertex AI Search for commerce with a variety of existing Google Cloud services and other tools, such as Google Analytics 360, Tag Manager, Cloud Storage, and BigQuery. This allows for efficient data flow and integration with existing analytics and marketing workflows.
Ensure security and privacy
: The platform provides strong access controls to ensure data isolation, giving developers confidence in the
privacy of their users' data
.
Access comprehensive documentation and resources
: Developers can find detailed documentation, guides, client libraries (including
REST and RPC references
),
pricing information
, and
release notes
to assist with implementation and integration.
What Vertex AI Search for commerce can do for business and marketing
Vertex AI Search for commerce enhances the online shopping experience and drives revenue by doing the following:
Drives digital commerce sites and applications with capabilities highly tuned for ecommerce.
AI-powered search optimized for product ranking increases click-through, order value, and conversions, and reduces search abandonment and No Results Found.
If guided search is enabled, it refines broad search queries through back-and-forth conversation with the user.
Returns relevant results and highly personalized recommendations for long-tail searches by understanding nuanced user behavior based on search history, context, and SKUs to drive engagement across channels.
Facilitates product discovery through text and images of similar or complementary items in real-time guided search.
Helps manage costs
Vertex AI Search for commerce can help manage costs by being fully managed, eliminating the need for you to preprocess data, train or hypertune machine learning models, load balance, or manually provision infrastructure. Additionally, you can start your proof of concept with free credit and benefit from free monthly usage of popular products, including AI APIs.
For more information on this, see
Pricing
.
Send feedback
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-24 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

# Source: cloud.google.com/retail/docs.txt
Vertex AI Search for commerce documentation  |  Google Cloud
Skip to main content
Technology areas
close
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Cross-product tools
close
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Related sites
close
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
/
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어
Console
Sign in
Vertex AI Search for commerce
Contact Us
Start free
Technology areas
More
Cross-product tools
More
Related sites
More
Console
Contact Us
Start free
Google Cloud Documentation home
Get started with Google Cloud
Product list
Integrated AI assistance with Gemini for Google Cloud
What's new in documentation
Recent product release notes
Cloud Customer Care
Cross-product tools
Access and resource management
Access and resource management overview
Access management
Cloud Identity
Identity Platform
Managed Service for Microsoft Active Delivery
Access Approval
See additional products on overview page
Control and discoverability
Service Catalog
Service Usage
Optimization and service health
Cloud Hub
Recommender
See additional products on overview page
Resource management
Config Connector
See additional products on overview page
Costs and usage management
Costs and usage management overview
Monitor and optimize costs
Cloud Billing
Committed use discounts
Free cloud features and trial offer
FinOps hub
Manage resources and usage
Cloud Quotas
Sustainability
Carbon Footprint
Google Cloud SDK, languages, frameworks, and tools
Google Cloud SDK, languages, frameworks, and tools overview
General authentication guides
Google Cloud SDK client libraries and languages
Google Cloud SDK and client libraries
See additional products on overview page
Languages
C# and .NET
C++
Go
Java
JavaScript and Node.js
PHP
Python
Ruby
Frameworks and tools
Spring
Prometheus
See additional products on overview page
Infrastructure as code
Infrastructure as code overview
Provision deploy and manage infrastructure
Infrastructure Manager
Terraform on Google Cloud
Cloud Development Kit for Terraform (external website)
Google Cloud provider for Pulumi (external website)
Ansible (external website)
Crossplane (external website)
Selected related product
Cloud Deployment Manager
Migration
Migration overview
Migration tools and services
Kf
See additional products on overview page
Generative AI
Overview of generative AI
Vertex AI Studio
Generative AI Models
Google models
Model Garden
Model versions
Open models
Use open models
Google Gemma
Llama
Hugging Face text generation models
Hex-LLM
Partner models
Use partner models
Anthropic Claude
Generate an AI response
Text and code generation
Image generation
Embeddings
Prompt design and engineering
Improve AI responses
Grounding
Tuning
Function calling
Evaluation
Safety
AI/ML orchestration on GKE
AI and ML
Overview of AI and ML
Pre-trained models
Cloud Vision API
Video Intelligence AI
Cloud Natural Language
Timeseries Insights API
Customer service, conversation, and speech
Conversational Agents (Dialogflow CX)
Dialogflow ES
Text-to-Speech
Speech-to-Text
Conversational Insights
Contact Center as a Service
Agent Assist
Agentspace
Conversational AI
Document management
Document AI
Industry-specific products
See listing of products on overview page
Video, images, vision, and augmented reality
Live Stream API
Transcoder API
Vertex AI Vision
Video Stitcher API
Immersive Stream for XR
See additional products on overview page
Search and recommendations
Vertex AI Search
Vector Search
Enterprise Knowledge Graph
Translation
Cloud Translation
Translation Hub
ML model training and development
Automatic training
Vertex AI AutoML Tabular
Vertex AI AutoML Image
Vertex AI AutoML Text
Custom training
Vertex AI Training
Vertex AI Neural Architecture Search
Deep Learning Containers
Deep Learning VM Images
MLOps and production
Data and features
Vertex AI Datasets
Vertex AI Feature Store
Deployment
Vertex AI Prediction
Developer tools
Colab Enterprise
TensorFlow Enterprise
Vertex AI Workbench instances
Model iteration
Vertex AI Experiments
Monitoring and evaluation
Vertex Explainable AI
Vertex AI Model Monitoring
Vertex AI TensorBoard
Orchestration
Vertex AI Pipelines
Vertex AI Model Registry
Accelerators
Cloud TPU
See additional products on overview page
Application development
Overview of application development
API management
API Gateway
API Keys API
Apigee
Apigee Hybrid
Cloud Endpoints
Build and deploy apps with CI/CD
Cloud Build
Artifact Registry
Artifact Analysis
Software supply chain security
Cloud Deploy
Container Registry
Development platforms and tools
App Hub
Application Design Center
Cloud Code
Cloud Code for Cloud Shell
Cloud Code for IntelliJ
Cloud Code for VS Code
Cloud Shell
Cloud Workstations
Google Cloud SDK
Service Infrastructure
Tools for PowerShell
Tools for Visual Studio
See additional products on overview page
Event-driven app creation
Cloud Scheduler
Cloud Tasks
Eventarc
Workflows
Industry-specific APIs
Cloud Healthcare API
See additional products on overview page
Integration
Application Integration
Developer Connect
Integration Connectors
GitLab on Google Cloud
Source code management tools
Cloud Source Repositories
Secure Source Manager
Application hosting
Overview of application hosting infrastructure
Serverless
Cloud Run
Cloud Run functions
App Engine
Container orchestration
Google Kubernetes Engine (GKE)
See additional products on overview page
Fleet management
GKE fleet management
Selected related products
Buildpacks
Blockchain Node Engine
Blockchain RPC
Compute
Overview of compute
Virtual machines
Compute Engine
Capacity Planner
See additional products on overview page
Images
Container-Optimized OS
See additional products on overview page
Block storage
Local SSD
Persistent Disk
Hyperdisk
Migration
Migration Center
Migrate to Virtual Machines
Migrate to Containers
Mainframe Assessment Tool
Mainframe Connector
Dual Run
Workloads
AI Hypercomputer
Cluster Director
Batch
Cloud GPUs
Selected related products
Google Cloud VMware Engine
SAP on Google Cloud
Workload Manager
Cluster Toolkit
Shielded VM
VM Manager
Data analytics
Overview of data analytics
BigQuery
Data analysis
Looker
Looker Studio
See additional products on overview page
Data governance and sharing
Dataplex Universal Catalog
Data Catalog
See additional products on overview page
Data integration and orchestration
BigQuery Data Transfer Service
Cloud Composer
Cloud Data Fusion
Dataform
Datastream
See additional products on overview page
Data migration
BigQuery Migration Service
Data processing
Dataproc
Serverless for Apache Spark
Dataproc Metastore
See additional products on overview page
Streaming
Dataflow
Google Cloud Managed Service for Apache Kafka
Pub/Sub
Pub/Sub Lite
See additional products on overview page
AI and ML
BigQuery ML
Gemini in BigQuery
Gemini in Looker
Selected related products
Blockchain Analytics
Cortex Framework
Earth Engine (other Google site)
Manufacturing Data Engine
Databases
Overview of databases
Non-relational databases
Bigtable
Datastore
Firestore with MongoDB compatibility
Firestore in Native mode
Memorystore for Memcached
Memorystore for Redis
Memorystore for Redis Cluster
Memorystore for Valkey
Spanner Graph
See additional products on overview page
Relational databases
AlloyDB for PostgreSQL
AlloyDB Omni
Spanner
Cloud SQL
Cloud SQL for MySQL
Cloud SQL for PostgreSQL
Cloud SQL for SQL Server
Migration
Database Migration Service
See additional products on overview page
Fleet Management
Database Center
Distributed, hybrid, and multicloud
Overview of distributed, hybrid, and multicloud
Distributed cloud
Google Distributed Cloud air-gapped
Google Distributed Cloud connected
Google Distributed Cloud software for bare metal
Google Distributed Cloud software for VMware
Multicloud
GKE Multi-Cloud
GKE Attached Clusters
GKE on AWS
GKE on Azure
Cloud Location Finder
Knative serving
Fleet management
See product on overview page
Selected related products
Config Controller
Config Sync
Policy Controller
Service Directory
Industry solutions
Overview of industry solutions
Financial services
Anti Money Laundering AI
Healthcare
Cloud Healthcare API
Healthcare Natural Language API
Cloud Life Sciences
See additional products on overview page
Media and entertainment
See products on overview page
Commerce
Vertex AI Search for commerce
Vision API Product Search
Transport fleet, career, and telecom
Cloud Talent Solution
Telecom Subscriber Insights
Telecom Network Automation
Networking
Overview of networking
Connectivity
Core networking
Virtual Private Cloud (VPC)
Cloud NAT
Network Service Tiers
Hybrid networking
Network Connectivity Center
Cloud VPN
Cloud Interconnect
Cloud Router
Scalability
Core services
Cloud DNS
Cloud Load Balancing
Service Extensions
Cloud Domains
CDN
Media CDN
Cloud CDN
Networking security
Cloud NGFW
Secure Access Connect
Network Security Integration
Secure Web Proxy
VPC Service Controls
Google Cloud Armor
Cloud IDS
See additional products on overview page
Networking observability
Network Intelligence Center
VPC Flow Logs
See additional products on overview page
Selected related products
Cloud Service Mesh
Data Transfer Essentials
Observability and monitoring
Overview of observabililty and monitoring
Observability and monitoring
Google Cloud Observability
Cloud Logging
Cloud Monitoring
Cloud Trace
Error Reporting
Observability optimization
Cloud Profiler
Security
Overview of security
General security guides
Security operations
Advisory Notifications
Cyber Insurance Hub
Google Security Operations
Security Command Center
Access management
Access Context Manager
Certificate Authority Service
Identity and Access Management (IAM)
Application security
Binary Authorization
Certificate Manager
Identity-Aware Proxy
reCAPTCHA
Secure Web Proxy
Web Risk
See additional products on overview page
Auditing, monitoring, and logging
Access Transparency
Audit Manager
Cloud Audit Logs
Cloud provider access management
Endpoint Verification
Personalized Service Health
Unified Maintenance
See additional products on overview page
Cloud governance
Assured Workloads
Cloud Asset Inventory
Organization Policy Service
Policy Intelligence
Resource Manager
Data security
Cloud External Key Manager
Cloud HSM
Cloud Key Management Service
Confidential Computing
Secret Manager
Sensitive Data Protection
See additional products on overview page
Network security
Chrome Enterprise Premium
Spectrum Access System
See additional products on overview page
Selected related products
Assured Open Source Software
Sovereign Controls by Partners
T-Systems Sovereign Cloud
Storage
Overview of storage
Backing up your data resources
Backup and DR Service
Backup for GKE
Storage solutions
Cloud Storage
Filestore
NetApp Volumes
Parallelstore
See additional products on overview page
Data transfer
Storage Transfer Service
Transfer Appliance
AI and ML
Application development
Application hosting
Compute
Data analytics and pipelines
Databases
Distributed, hybrid, and multicloud
Generative AI
Industry solutions
Networking
Observability and monitoring
Security
Storage
Access and resources management
Costs and usage management
Infrastructure as code
Migration
SDK, languages, frameworks, and tools
Google Cloud Home
Free Trial and Free Tier
Architecture Center
Blog
Contact Sales
Google Cloud Developer Center
Google Developer Center
Google Cloud Marketplace
Google Cloud Marketplace Documentation
Google Cloud Skills Boost
Google Cloud Solution Center
Google Cloud Support
Google Cloud Tech Youtube Channel
Home
Documentation
Industry solutions
Vertex AI Search for commerce
Vertex AI Search for commerce documentation
Read product documentation
The Vertex AI Search for commerce is made up of search and recommendations capabilities. These
help you implement personalized search and
recommendations, based on machine learning models, across your websites and
mobile applications.
Go to the Vertex AI Search for commerce product page for more.
Get started for free
Start your proof of concept with $300 in free credit
Get access to Gemini 2.0 Flash Thinking
Free monthly usage of popular products, including AI APIs and BigQuery
No automatic charges, no commitment
View free product offers
Keep exploring with 20+ always-free products
Access 20+ free products for common use cases, including AI APIs, VMs, data warehouses,
          and more.
Documentation resources
Find quickstarts and guides, review key references, and get help with common issues.
format_list_numbered
Guides
Implement
Import catalog information
Record real-time user events
Before you begin
Create recommendation models
Get recommendations
Manage user events
Manage catalog information
Troubleshoot integration issues
find_in_page
Reference
Client libraries
REST reference
RPC reference
info
Resources
Pricing
Quotas and limits
Release notes
Frequently asked questions
Get support
Billing questions
Except as otherwise noted, the content of this page is licensed under the
Creative Commons Attribution 4.0 License
, and code samples are licensed under the
Apache 2.0 License
. For details, see the
Google Developers Site Policies
. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2025-10-27 UTC.
Why Google
Choosing Google Cloud
Trust and security
Modern Infrastructure Cloud
Multicloud
Global infrastructure
Customers and case studies
Analyst reports
Whitepapers
Products and pricing
See all products
See all solutions
Google Cloud for Startups
Google Cloud Marketplace
Google Cloud pricing
Contact sales
Support
Community forums
Support
Release Notes
System status
Resources
GitHub
Getting Started with Google Cloud
Google Cloud documentation
Code samples
Cloud Architecture Center
Training and Certification
Developer Center
Engage
Blog
Events
X (Twitter)
Google Cloud on YouTube
Google Cloud Tech on YouTube
Become a Partner
Google Cloud Affiliate Program
Press Corner
About Google
Privacy
Site terms
Google Cloud terms
Manage cookies
Our third decade of climate action: join us
Sign up for the Google Cloud newsletter
Subscribe
English
Deutsch
Español
Español – América Latina
Français
Indonesia
Italiano
Português
Português – Brasil
中文 – 简体
中文 – 繁體
日本語
한국어

